/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 12:32:14 GMT 2024
 */

package gnu.trove.decorator;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import gnu.trove.decorator.TShortByteMapDecorator;
import gnu.trove.impl.hash.TPrimitiveHash;
import gnu.trove.map.TShortByteMap;
import gnu.trove.map.hash.TShortByteHashMap;
import java.io.ObjectInput;
import java.util.Map;
import java.util.Set;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TShortByteMapDecorator_ESTest extends TShortByteMapDecorator_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEntrySet() throws Throwable  {
      // No Comments were added
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator();
      Set<Map.Entry<Short, Byte>> entrySet = (Set<Map.Entry<Short, Byte>>)tShortByteMapDecorator.entrySet();
      assertNotNull(entrySet);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWrapValueReturningZero() throws Throwable  {
      // Test that the wrapValue() method correctly wraps a byte value around to 0 if it exceeds the maximum value of the map.
      // Create a map with a maximum value of 1
      TShortByteHashMap arg0 = new TShortByteHashMap(1, 1, (short)2, (byte)83);
      
      // Create a decorator for the map
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      
      // Wrap the value of 256 around to 0 using the wrapValue() method
      Byte wrappedValue = tShortByteMapDecorator.wrapValue((byte)0);
      
      // Assert that the wrapped value is equal to 0
      assertEquals((byte)0, (byte)wrappedValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWrapValueReturningPositive() throws Throwable  {
      // Tests the wrapValue method of TShortByteMapDecorator by checking if it correctly wraps a byte value.
      // Creates a new instance of TShortByteMapDecorator.
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator();
      
      // Wraps the byte value 15 using the wrapValue method.
      Byte wrappedValue = tShortByteMapDecorator.wrapValue((byte)15);
      
      // Asserts that the wrapped value is equal to 15.
      assertEquals((byte)15, (byte)wrappedValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWrapValueReturningNegative() throws Throwable  {
      // Test that the wrapValue method returns the same value as the original byte when passed a negative byte value
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator();
      Byte wrappedValue = tShortByteMapDecorator.wrapValue((byte) (-83));
      assertEquals(wrappedValue, (byte) (-83));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testUnwrapValueReturningZero() throws Throwable  {
      // Given a TShortByteHashMap object with a value at key 2 (short) and byte 83
      TShortByteHashMap arg0 = new TShortByteHashMap(1, 1, (short)2, (byte)83);
      
      // When we create a TShortByteMapDecorator object with the previous hash map as an argument
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      
      // Then the unwrapValue method returns 0 (byte) since the value at key 2 is not free
      byte unwrapValue = tShortByteMapDecorator.unwrapValue(arg0.FREE);
      assertEquals((byte)0, unwrapValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testUnwrapValueReturningPositive() throws Throwable  {
      // Given a TShortByteMapDecorator instance
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator();
      
      // And a byte value of 1
      byte value = (byte) 1;
      
      // When the unwrapValue method is called with the byte value as an argument
      byte unwrappedValue = tShortByteMapDecorator.unwrapValue(value);
      
      // Then the returned value should be the same as the input value
      assertEquals(value, unwrappedValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testUnwrapValueReturningNegative() throws Throwable  {
      // Given a TShortByteMapDecorator instance, which wraps a Byte value of -86
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator();
      Byte arg0 = new Byte((byte) (-86));
      
      // When the unwrapValue method is called with the wrapped Byte value
      byte unwrapValue = tShortByteMapDecorator.unwrapValue(arg0);
      
      // Then the returned byte value should be -86, which is the same as the original Byte value
      assertEquals((byte) (-86), unwrapValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testUnwrapKeyReturningZeroAndWrapKeyReturningZero() throws Throwable  {
      // Given a TShortByteMapDecorator object and a short value
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator();
      Short arg0 = tShortByteMapDecorator.wrapKey((short)0);
      
      // When the wrapKey method is called with the short value
      short unwrapKey = tShortByteMapDecorator.unwrapKey(arg0);
      
      // Then the returned key should be equal to the original short value
      assertEquals((short)0, unwrapKey);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testUnwrapKeyReturningNegativeAndWrapKeyReturningNegative() throws Throwable  {
      // Given a TShortByteMapDecorator instance
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator();
      
      // When we wrap and then unwrap a key
      Short arg0 = tShortByteMapDecorator.wrapKey((short) (-2515));
      short unwrapKey = tShortByteMapDecorator.unwrapKey(arg0);
      
      // Then the wrapped and unwrapped keys should be equal
      assertEquals((short) (-2515), unwrapKey);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveReturningNegative() throws Throwable  {
      // rollbacked to evosuite
      TShortByteHashMap arg0 = new TShortByteHashMap((-388), (-388));
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      Byte arg1 = new Byte((byte) (-121));
      tShortByteMapDecorator.put((Short) null, arg1);
      tShortByteMapDecorator.remove((Object) null);
      assertEquals(0, tShortByteMapDecorator.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMapReturningTShortByteMapWhereGetNoEntryKeyIsZero() throws Throwable  {
      // Given: We have a TShortByteHashMap instance with a negative initial capacity and a load factor of 0.0F
      TShortByteHashMap arg0 = new TShortByteHashMap((-3618), 0.0F);
      
      // When: We create a TShortByteMapDecorator using this instance as the underlying map
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      
      // Then: The resulting map should have a size of 0, as it is an empty map
      assertEquals(0, tShortByteMapDecorator.getMap().size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMapReturningTShortByteMapWhereGetNoEntryKeyIsPositive() throws Throwable  {
      // Given a TShortByteHashMap with default parameters (-1, -1) and initial capacity of 1306
      TShortByteHashMap arg0 = new TShortByteHashMap((-1), (-1), (short)1306, (byte)15);
      
      // When we create a TShortByteMapDecorator with the given map
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      
      // Then the resulting map should be an instance of TShortByteHashMap
      assertTrue(tShortByteMapDecorator.getMap() instanceof TShortByteHashMap);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMapReturningTShortByteMapWhereGetNoEntryKeyIsNegative() throws Throwable  {
      // Given: A TShortByteMapDecorator and a TShortByteHashMap with some predefined data
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator();
      TShortByteHashMap tShortByteHashMap = new TShortByteHashMap((byte)0, (short)0, (short) (-32768), (byte) (-44));
      tShortByteMapDecorator._map = (TShortByteMap) tShortByteHashMap;
      
      // When: The decorated map is accessed and the auto-compaction factor is retrieved
      TShortByteHashMap map = (TShortByteHashMap)tShortByteMapDecorator.getMap();
      float autoCompactionFactor = map.getAutoCompactionFactor();
      
      // Then: The returned value should be equal to 0.5F with a tolerance of 0.01F
      assertEquals(0.5F, autoCompactionFactor, 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testContainsKeyReturningTrue() throws Throwable  {
      // Arrange
      TShortByteHashMap arg0 = new TShortByteHashMap();
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      
      // Act
      Byte put = tShortByteMapDecorator.put((Short) null, (Byte) (byte)1);
      
      // Assert
      assertNull(put);
      assertTrue(tShortByteMapDecorator.containsKey((Object) null));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSize() throws Throwable  {
      // Given a TShortByteHashMap with some initial data
      TShortByteHashMap arg0 = new TShortByteHashMap(3597, (-4881.31F));
      
      // When the size of the decorated map is retrieved
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      int size = tShortByteMapDecorator.size();
      
      // Then the correct size should be returned
      assertEquals(0, size);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsEmpty() throws Throwable  {
      // Given a TShortByteMapDecorator instance with an empty map
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator();
      tShortByteMapDecorator._map = new TShortByteHashMap((byte)0, (short)0, (short)0, (byte) (-44));
      
      // When we call isEmpty() on the decorator
      boolean empty = tShortByteMapDecorator.isEmpty();
      
      // Then the result should be true
      assertTrue(empty);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testContainsKeyReturningFalse() throws Throwable  {
      // Test if a key is present in the map
      TShortByteHashMap arg0 = new TShortByteHashMap();
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      boolean containsKey = tShortByteMapDecorator.containsKey("key");
      assertFalse(containsKey);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testContainsValueReturningFalse() throws Throwable  {
      // Test that the map does not contain the value 2 when it was created with a default capacity of -128.
      TShortByteHashMap arg0 = new TShortByteHashMap((-128), (-128));
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      boolean containsValue = tShortByteMapDecorator.containsValue((byte)2);
      assertFalse(containsValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTShortByteMapDecoratorTakingTShortByteMap() throws Throwable  {
      // Given a TShortByteHashMap instance, which has a capacity of -128 and is initialized with a negative value for its keys
      TShortByteHashMap arg0 = new TShortByteHashMap((-128), (-128));
      
      // When we decorate the map with a TShortByteMapDecorator
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      
      // Then we verify that the containsValue method returns false for a value of 255, as it is not present in the map
      boolean containsValue = tShortByteMapDecorator.containsValue((byte) 255);
      assertFalse(containsValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveReturningPositive() throws Throwable  {
      // rollbacked to evosuite
      TShortByteHashMap arg0 = new TShortByteHashMap((-388), (-388));
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      tShortByteMapDecorator.put((Short) null, (Byte) arg0.REMOVED);
      tShortByteMapDecorator.remove((Object) null);
      assertEquals(0, tShortByteMapDecorator.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGet() throws Throwable  {
      // Given: A TShortByteHashMap with some initial values and a TShortByteMapDecorator instance wrapping it
      TShortByteHashMap arg0 = new TShortByteHashMap((-1), 3592.716F, (short) (-1217), (byte)107);
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      
      // When: Retrieving a value from the map using the decorator's get() method
      Byte get = tShortByteMapDecorator.get(arg0);
      
      // Then: The retrieved value should be null, as the given key is not present in the map
      assertNull(get);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClear() throws Throwable  {
      // Given a TShortByteHashMap instance with a negative initial capacity
      TShortByteHashMap arg0 = new TShortByteHashMap((-388), (-388));
      
      // When the map is decorated using a TShortByteMapDecorator
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator(arg0);
      
      // Then the map should be empty after being cleared
      tShortByteMapDecorator.clear();
      assertTrue(tShortByteMapDecorator.isEmpty());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMapReturningNull() throws Throwable  {
      // Given a TShortByteMapDecorator instance with a map of shorts to bytes
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator();
      
      // When the getMap method is called on the decorator
      TShortByteMap map = tShortByteMapDecorator.getMap();
      
      // Then the returned map should be null, as it has not been initialized yet
      assertNull(map);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReadExternalThrowsNullPointerException() throws Throwable  {
      // Arrange
      TShortByteMapDecorator tShortByteMapDecorator = new TShortByteMapDecorator();
      
      try {
      // Act
      tShortByteMapDecorator.readExternal((ObjectInput) null);
      
      // Assert
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      // Verify
      assertEquals(null, e.getMessage());}
  }
}
