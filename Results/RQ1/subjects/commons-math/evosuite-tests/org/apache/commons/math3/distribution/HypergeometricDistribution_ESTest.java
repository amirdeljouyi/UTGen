/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 11:28:01 GMT 2024
 */

package org.apache.commons.math3.distribution;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import org.apache.commons.math3.distribution.HypergeometricDistribution;
import org.apache.commons.math3.random.RandomGenerator;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class HypergeometricDistribution_ESTest extends HypergeometricDistribution_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSupportUpperBoundReturningPositive() throws Throwable  {
      // Given a hypergeometric distribution with n=4500 and N=4500
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(4500, 4500, 4500);
      
      // When we query the numerical mean of the distribution
      double numericalMean = hypergeometricDistribution.getNumericalMean();
      
      // Then we expect the numerical mean to be equal to n=4500
      assertEquals(4500.0, numericalMean, 0.01);
      
      // When we query the support upper bound of the distribution
      int supportUpperBound = hypergeometricDistribution.getSupportUpperBound();
      
      // Then we expect the support upper bound to be equal to N=4500
      assertEquals(4500, supportUpperBound);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSupportLowerBoundReturningZero() throws Throwable  {
      // Given a Hypergeometric Distribution with 1 success in the population of size 1
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(1, 1, 0);
      
      // When the support lower bound is obtained
      int supportLowerBound = hypergeometricDistribution.getSupportLowerBound();
      
      // Then the support lower bound should be equal to the population size
      assertEquals(1, supportLowerBound);
      
      // And the population size should be 1
      assertEquals(1, hypergeometricDistribution.getPopulationSize());
      
      // And the sample size should be 0
      assertEquals(0, hypergeometricDistribution.getSampleSize());
      
      // And the number of successes should be 1
      assertEquals(1, hypergeometricDistribution.getNumberOfSuccesses());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSupportLowerBoundReturningPositive() throws Throwable  {
      // Given: We have a HypergeometricDistribution object with parameters (1718, 1718, 1718)
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(1718, 1718, 1718);
      
      // When: We call the getSupportLowerBound() method on the HypergeometricDistribution object
      int supportLowerBound = hypergeometricDistribution.getSupportLowerBound();
      
      // Then: The returned value is the lower bound of the support interval for the distribution, which should be 1718
      assertEquals(1718, supportLowerBound);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSampleSizeReturningZero() throws Throwable  {
      // Create a new instance of the HypergeometricDistribution class with parameters (75, 75, 0)
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(75, 75, 0);
      
      // Get the sample size from the hypergeometric distribution object
      int sampleSize = hypergeometricDistribution.getSampleSize();
      
      // Assert that the population size is 75
      assertEquals(75, hypergeometricDistribution.getPopulationSize());
      
      // Assert that the numerical mean is approximately equal to 0 with a delta of 0.01
      assertEquals(0.0, hypergeometricDistribution.getNumericalMean(), 0.01);
      
      // Assert that the number of successes is 75
      assertEquals(75, hypergeometricDistribution.getNumberOfSuccesses());
      
      // Assert that the sample size is 0
      assertEquals(0, sampleSize);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNumericalVarianceReturningZero() throws Throwable  {
      // Given a Hypergeometric distribution with population size 2, sample size 2, and no successes
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(2, 0, 2);
      
      // When we get the numerical variance of the distribution
      double numericalVariance = hypergeometricDistribution.getNumericalVariance();
      
      // Then the numerical variance should be equal to 2
      assertEquals(2, numericalVariance, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNumericalVarianceReturningPositive() throws Throwable  {
      // Given a Hypergeometric Distribution with N=1347, K=579 and n=579
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(1347, 579, 579);
      
      // When we calculate the numerical variance of this distribution
      double numericalVariance = hypergeometricDistribution.getNumericalVariance();
      
      // Then we expect the result to be approximately equal to 80.96537210712938 with a margin of error of 0.01
      assertEquals(80.96537210712938, numericalVariance, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNumericalMeanReturningZero() throws Throwable  {
      // Given a Hypergeometric distribution with population size 2, sample size 2
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(2, 0, 2);
      
      // When the numerical mean is requested
      double numericalMean = hypergeometricDistribution.getNumericalMean();
      
      // Then the returned value should be equal to 2 (the population size)
      assertEquals(2.0, numericalMean, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNumericalMeanReturningPositive() throws Throwable  {
      // Given a HypergeometricDistribution object with n=2134, N=2134 and k=2134
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(2134, 2134, 2134);
      
      // When the numerical mean of the distribution is requested
      double numericalMean = hypergeometricDistribution.getNumericalMean();
      
      // Then the expected value (n*k/N) should be returned, with a precision of 0.01
      assertEquals(2134.0, numericalMean, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNumberOfSuccessesReturningZero() throws Throwable  {
      // Given a Hypergeometric distribution with n = 2 and k = 0
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(2, 0, 2);
      
      // When we retrieve the number of successes
      int numberOfSuccesses = hypergeometricDistribution.getNumberOfSuccesses();
      
      // Then the number of successes should be 0
      assertEquals(0, numberOfSuccesses);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCalculateNumericalVarianceReturningZero() throws Throwable  {
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(419, 419, 419);
      double numericalMean = hypergeometricDistribution.getNumericalMean();
      double numericalVariance = hypergeometricDistribution.calculateNumericalVariance();
      assertEquals(419.0, numericalMean, 0.01); // Given the distribution is instantiated with mean of 419
      assertEquals(0.0, numericalVariance, 0.01); // Then the variance should be 0
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCalculateNumericalVarianceReturningPositive() throws Throwable  {
      // rollbacked to evosuite
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(465, 441, 441);
      double calculateNumericalVariance = hypergeometricDistribution.calculateNumericalVariance();
      assertEquals(1.1165438300620762, calculateNumericalVariance, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbabilityReturningPositive() throws Throwable  {
      // This test checks the probability of drawing no red balls from a bag containing 247 red and 2 green balls, given that we want to draw 2 balls.
      
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(247, 2, 2);
      double probability = hypergeometricDistribution.probability(0);
      
      // The probability of drawing no red balls is 98.38% according to the formula for the hypergeometric distribution.
      assertEquals(0.9838385833251042, probability, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPopulationSize() throws Throwable  {
      // Given a hypergeometric distribution with n=1347, K=579, and N=579
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(1347, 579, 579);
      
      // When we calculate the numerical mean of the distribution
      double numericalMean = hypergeometricDistribution.getNumericalMean();
      
      // Then the numerical mean should be approximately equal to 248.87973273942094
      assertEquals(248.87973273942094, numericalMean, 0.01);
      
      // And the population size should be equal to 1347
      int populationSize = hypergeometricDistribution.getPopulationSize();
      assertEquals(1347, populationSize);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNumberOfSuccessesReturningPositive() throws Throwable  {
      // Given a hypergeometric distribution with n=1347, N=579, and k=579
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(1347, 579, 579);
      
      // When we calculate the number of successes
      int numberOfSuccesses = hypergeometricDistribution.getNumberOfSuccesses();
      
      // Then the number of successes should be equal to k=579
      assertEquals(579, numberOfSuccesses);
      
      // And the numerical mean of the distribution should be approximately 248.87973273942094
      assertEquals(248.87973273942094, hypergeometricDistribution.getNumericalMean(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSampleSizeReturningPositive() throws Throwable  {
      // Given: A HypergeometricDistribution object with n = 1347, K = 579, and N = 579
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(1347, 579, 579);
      
      // When: The numerical mean of the distribution is requested
      double numericalMean = hypergeometricDistribution.getNumericalMean();
      
      // Then: The expected numerical mean should be approximately equal to 248.87973273942094
      assertEquals(248.87973273942094, numericalMean, 0.01);
      
      // Then: The sample size should be equal to 579
      assertEquals(579, hypergeometricDistribution.getSampleSize());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNumericalVariance() throws Throwable  {
      // Given a HypergeometricDistribution with n=1, K=0, and N=1
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(1, 0, 1);
      
      // When we call the sample method on this distribution
      double sampleValue = hypergeometricDistribution.sample();
      
      // Then the resulting value should be Double.NaN, since it is not possible to draw a sample from this distribution
      assertEquals(Double.NaN, sampleValue, 0.01);
      
      // And the numerical variance of this distribution should be Double.NaN, since it is not defined
      double numericalVariance = hypergeometricDistribution.getNumericalVariance();
      assertEquals(Double.NaN, numericalVariance, 0.01);
      
      // And the sample size of this distribution should be 1
      assertEquals(1, hypergeometricDistribution.getSampleSize());
      
      // And the numerical mean of this distribution should be 0.0, since it is not defined
      double numericalMean = hypergeometricDistribution.getNumericalMean();
      assertEquals(0.0, numericalMean, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testUpperCumulativeProbability0() throws Throwable  {
      // Test that the hypergeometric distribution calculates the correct cumulative probability for a value above the population size
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(465, 441, 441);
      double upperCumulativeProbability = hypergeometricDistribution.upperCumulativeProbability(441);
      assertEquals(1.0865886174980112E-40, upperCumulativeProbability, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testUpperCumulativeProbability1() throws Throwable  {
      // Given a Hypergeometric distribution with n=465, N=441, and K=441
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(465, 441, 441);
      
      // When calculating the upper cumulative probability for x=11
      double upperCumulativeProbability = hypergeometricDistribution.upperCumulativeProbability(11);
      
      // Then the result should be 1.0 with an error of +/- 0.01
      assertEquals(1.0, upperCumulativeProbability, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testUpperCumulativeProbabilityReturningZero() throws Throwable  {
      // Given a population size of 1, a number of successes of 1, and a number of draws of 0
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(1, 1, 0);
      
      // When calculating the upper cumulative probability of drawing at least 375 balls from the population
      double upperCumulativeProbability = hypergeometricDistribution.upperCumulativeProbability(375);
      
      // Then we expect the result to be exactly 1, as there is no chance of getting more than the total number of successes in the population
      assertEquals(1, hypergeometricDistribution.getPopulationSize());
      assertEquals(0.0, upperCumulativeProbability, 0.01);
      
      // And we expect the numerical mean to be exactly 0, as there is no chance of getting any successes in the population
      assertEquals(0.0, hypergeometricDistribution.getNumericalMean(), 0.01);
      
      // Finally, we expect the number of successes to be exactly 1, as this is the only outcome possible given the parameters of the distribution
      assertEquals(1, hypergeometricDistribution.getNumberOfSuccesses());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbabilityWithPositive() throws Throwable  {
      // Given a HypergeometricDistribution with n=1, N=1, and x=1134
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(1, 0, 1);
      
      // When we calculate the probability of getting 1134 heads in a sequence of coin flips
      double probability = hypergeometricDistribution.probability(1134);
      
      // Then we expect the probability to be close to 0, since it is highly unlikely for this number of heads to occur in a single sequence of coin flips
      assertEquals(0.0, probability, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProbabilityWithNegative() throws Throwable  {
      // Given a Hypergeometric distribution with n=2 and N=2,
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(2, 0, 2);
      
      // When the probability of drawing x=(-4417) is calculated,
      double probability = hypergeometricDistribution.probability((-4417));
      
      // Then the result should be 2 (i.e., the probability of drawing x=(-4417) is 2),
      assertEquals(2, probability, 0.01);
      
      // And the numerical mean should also be 2 (since both n and N are equal to 2).
      assertEquals(2, hypergeometricDistribution.getNumericalMean(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCumulativeProbabilityReturningPositive() throws Throwable  {
      // Given a hypergeometric distribution with parameters n = 586, m = 586, and k = 586
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(586, 586, 586);
      
      // When computing the cumulative probability of drawing a red ball from the urn
      double cumulativeProbability = hypergeometricDistribution.cumulativeProbability(586);
      
      // Then the probability should be equal to 1 with an accuracy of 0.01
      assertEquals(1.0, cumulativeProbability, 0.01);
      
      // And the numerical mean should also be equal to 586 with an accuracy of 0.01
      assertEquals(586.0, hypergeometricDistribution.getNumericalMean(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCumulativeProbabilityReturningZero() throws Throwable  {
      // Given a HypergeometricDistribution with populationSize = 2, sampleSize = 2, and numberOfSuccesses = 0
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(2, 0, 2);
      
      // When the cumulativeProbability method is called with an argument of -2117
      double cumulativeProbability = hypergeometricDistribution.cumulativeProbability(-2117);
      
      // Then the returned value should be 2 (the populationSize)
      assertEquals(2, hypergeometricDistribution.getPopulationSize());
      
      // And the sampleSize should still be 2
      assertEquals(2, hypergeometricDistribution.getSampleSize());
      
      // And the numberOfSuccesses should still be 0
      assertEquals(0.0, cumulativeProbability, 0.01);
      
      // And the returned value should be 0 (the number of successes)
      assertEquals(0, hypergeometricDistribution.getNumberOfSuccesses());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesHypergeometricDistributionTaking3Arguments0() throws Throwable  {
      // No Comments were added
      HypergeometricDistribution hypergeometricDistribution = null;
      try {
        hypergeometricDistribution = new HypergeometricDistribution(5, 3, 7);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // sample size (7) must be less than or equal to population size (5)
         //
         verifyException("org.apache.commons.math3.distribution.HypergeometricDistribution", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesHypergeometricDistributionTaking3Arguments1() throws Throwable  {
      // No Comments were added
      HypergeometricDistribution hypergeometricDistribution = null;
      try {
        hypergeometricDistribution = new HypergeometricDistribution(10, 20, 30);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // number of successes (20) must be less than or equal to population size (10)
         //
         verifyException("org.apache.commons.math3.distribution.HypergeometricDistribution", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesHypergeometricDistributionTaking3Arguments2() throws Throwable  {
      // No Comments were added
      HypergeometricDistribution hypergeometricDistribution = null;
      try {
        hypergeometricDistribution = new HypergeometricDistribution(11, 11, (-200));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // number of samples (-200)
         //
         verifyException("org.apache.commons.math3.distribution.HypergeometricDistribution", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesHypergeometricDistributionTaking4Arguments() throws Throwable  {
      // Given a random generator and the number of successes, trials, and population
      HypergeometricDistribution hypergeometricDistribution = null;
      
      try {
      // When I construct the distribution with negative values for the number of successes or trials
      hypergeometricDistribution = new HypergeometricDistribution((RandomGenerator) null, 1039, (-1049), 836);
      
      // Then I expect an IllegalArgumentException to be thrown
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      // Verify that the correct exception is thrown
      verifyException("org.apache.commons.math3.distribution.HypergeometricDistribution", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesHypergeometricDistributionTaking3Arguments3() throws Throwable  {
      // Create a new instance of the HypergeometricDistribution class with invalid population size.
      HypergeometricDistribution hypergeometricDistribution = null;
      try {
      hypergeometricDistribution = new HypergeometricDistribution(-186, 0, 4033);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Verify that the expected exception is thrown.
      verifyException("org.apache.commons.math3.distribution.HypergeometricDistribution", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSupportConnected() throws Throwable  {
      // Given a Hypergeometric distribution with a population size of 2 and a sample size of 2
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(2, 0, 2);
      
      // When the support is connected?
      boolean supportConnected = hypergeometricDistribution.isSupportConnected();
      
      // Then the support should be connected
      assertTrue(supportConnected);
      
      // And the population size should be equal to 2
      assertEquals(2, hypergeometricDistribution.getPopulationSize());
      
      // And the sample size should be equal to 2
      assertEquals(2, hypergeometricDistribution.getSampleSize());
      
      // And the numerical mean should be close to 0
      assertEquals(0.0, hypergeometricDistribution.getNumericalMean(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesHypergeometricDistributionTaking3Arguments4() throws Throwable  {
      // Test the Hypergeometric distribution with 1037 successes, 931 failures and 931 total counts.
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(1037, 931, 931);
      
      // Generate a sample of size 931 using the Hypergeometric distribution.
      int sample = hypergeometricDistribution.sample();
      
      // Check that the generated sample has 840 successes.
      assertEquals(840, sample);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNumericalMeanReturningNegative() throws Throwable  {
      // Given a HypergeometricDistribution with parameters n=9999957, N=9999957 and K=9999957
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(9999957, 9999957, 9999957);
      
      // When we call the getNumericalMean method on the distribution
      double numericalMean = hypergeometricDistribution.getNumericalMean();
      
      // Then we should get a numerical mean close to (-58.35534282797416) with an error of 0.01
      assertEquals((-58.35534282797416), numericalMean, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSupportUpperBoundReturningZero() throws Throwable  {
      // Given: A HypergeometricDistribution object with parameters 2, 0, and 2
      HypergeometricDistribution hypergeometricDistribution = new HypergeometricDistribution(2, 0, 2);
      
      // When: The getSupportUpperBound() method is called on the object
      int supportUpperBound = hypergeometricDistribution.getSupportUpperBound();
      
      // Then: The returned value should be 0 (the upper bound of the support is 0)
      assertEquals(0, supportUpperBound);
      
      // When: The getSampleSize() method is called on the object
      int sampleSize = hypergeometricDistribution.getSampleSize();
      
      // Then: The returned value should be 2 (the sample size is 2)
      assertEquals(2, sampleSize);
      
      // When: The getPopulationSize() method is called on the object
      int populationSize = hypergeometricDistribution.getPopulationSize();
      
      // Then: The returned value should be 2 (the population size is 2)
      assertEquals(2, populationSize);
  }
}
