/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 16:20:50 GMT 2024
 */

package org.apache.commons.math3.fraction;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import org.apache.commons.math3.fraction.Fraction;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class Fraction_ESTest extends Fraction_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSubtractTakingFractionReturningFractionWhereIntValueIsNegative() throws Throwable  {
      // Given: We have a Fraction object with the value of 1/2 and another Fraction object with the value of 2/1.
      Fraction fraction = Fraction.ONE_HALF;
      Fraction arg0 = Fraction.TWO;
      
      // When: We subtract the second Fraction object from the first one.
      Fraction subtract = fraction.subtract(arg0);
      
      // Then: The result of the subtraction should be a new Fraction object with a denominator of 2 and a numerator of -1.5.
      assertEquals(2, subtract.getDenominator());
      assertEquals((-1.5F), subtract.floatValue(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPercentageValueReturningZero() throws Throwable  {
      // rollbacked to evosuite
      Fraction arg0 = Fraction.MINUS_ONE;
      Fraction fraction = Fraction.ONE;
      Fraction add = fraction.add(arg0);
      double percentageValue = add.percentageValue();
      assertEquals(100.0, fraction.percentageValue(), 0.01);
      assertEquals(0.0, percentageValue, 0.01);
      assertEquals(1, add.getDenominator());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPercentageValueReturningNegative() throws Throwable  {
      // Given a fraction of -359 / -359
      Fraction fraction = new Fraction(-359, -359);
      
      // When the fraction is negated
      Fraction negate = fraction.ONE_FIFTH.negate();
      
      // Then the negative value of the fraction should be 20%
      assertEquals(20.0, negate.percentageValue(), 0.01);
      
      // And the denominator of the fraction should be 1
      assertEquals(1, fraction.getDenominator());
      
      // And the denominator of the negative fraction should be 5
      assertEquals(5, negate.getDenominator());
      
      // And the percentage value of the original fraction should be 100%
      assertEquals(100.0, fraction.percentageValue(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNegateReturningFractionWhereShortValueIsNegative() throws Throwable  {
      // Given a fraction with numerator 5 and denominator 5
      Fraction fraction = new Fraction(5, 5);
      
      // When we negate the fraction
      Fraction negate = fraction.negate();
      
      // Then the resulting fraction has a negative numerator and denominator
      assertEquals(-1, negate.getNumerator());
      assertEquals(1, negate.getDenominator());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNegateReturningFractionWhereShortValueIsPositive() throws Throwable  {
      // Given a fraction of 3088.777495463214 / (-806)
      Fraction fraction = new Fraction(3088.777495463214, -806);
      
      // When the fraction is negated
      Fraction negate = fraction.MINUS_ONE.negate();
      
      // Then the long value of the fraction should be 3088
      assertEquals(3088L, fraction.longValue());
      
      // And the percentage value of the negated fraction should be close to 100%
      assertEquals(100.0, negate.percentageValue(), 0.01);
      
      // And the denominator of the negated fraction should be 1
      assertEquals(1, negate.getDenominator());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTakingFractionReturningFractionWhereShortValueIsNegative() throws Throwable  {
      // No Comments were added
      Fraction fraction = Fraction.ONE_FIFTH;
      Fraction arg0 = new Fraction((-15));
      Fraction multiply = fraction.ONE_THIRD.multiply(arg0);
      assertEquals((-15), arg0.getNumerator());
      assertEquals((-500.0), multiply.percentageValue(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTakingIntReturningFractionWhereShortValueIsZero() throws Throwable  {
      // Given: We have a Fraction object named "fraction" with a value of 0
      Fraction fraction = Fraction.ZERO;
      
      // When: We call the multiply method on the fraction object with an argument of 9
      Fraction multiply = fraction.multiply(9);
      
      // Then: The result of the multiplication should be a new Fraction object with a value of 0
      assertTrue(multiply.equals((Object)fraction));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLongValueReturningPositive() throws Throwable  {
      // Given: A Fraction object with a numerator of 5 and a denominator of 5
      Fraction fraction = new Fraction(5, 5);
      
      // When: We call the longValue() method on the Fraction object
      long longValue = fraction.longValue();
      
      // Then: The longValue() method should return the numerator of the Fraction as a long value
      assertEquals(1L, longValue);
      
      // And: The percentageValue() method should return the fraction of the numerator as a double value with 2 decimal places
      assertEquals(100.0, fraction.percentageValue(), 0.01);
      
      // And: The getDenominator() method should return the denominator of the Fraction
      assertEquals(1, fraction.getDenominator());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLongValueReturningNegative() throws Throwable  {
      // Create a fraction object with the given numerator and denominator
      Fraction fraction = new Fraction(5, 5);
      
      // Use the ONE_FIFTH constant to subtract the given value from the fraction
      Fraction subtract = fraction.ONE_FIFTH.subtract(813);
      
      // Check that the numerator of the resulting fraction is 1
      assertEquals(1, subtract.getNumerator());
      
      // Check that the float value of the resulting fraction is close to 1.0
      assertEquals((-4064), subtract.getNumerator());
      
      // Check that the double value of the resulting fraction is close to -812.8
      assertEquals((-812L), subtract.longValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIntValueReturningZero() throws Throwable  {
      // Given a fraction object with a negative numerator and denominator
      Fraction fraction = new Fraction(1, -2236);
      
      // When we get the integer value of the fraction
      int intValue = fraction.intValue();
      
      // Then the integer value should be 0
      assertEquals(0, intValue);
      
      // And the percentage value of the fraction should be close to (-0.044722719141323794)
      assertEquals((-0.044722719141323794), fraction.percentageValue(), 0.01);
      
      // And the denominator of the fraction should be equal to 2236
      assertEquals(2236, fraction.getDenominator());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNumeratorReturningZero() throws Throwable  {
      // Given a Fraction with a zero value
      Fraction fraction = new Fraction(0);
      
      // When the numerator is retrieved
      int numerator = fraction.getNumerator();
      
      // Then the numerator should be equal to 0
      assertEquals(0, numerator);
      
      // And the denominator should be equal to 1
      assertEquals(1, fraction.getDenominator());
      
      // And the double value of the fraction should be close to 0.0 with a tolerance of 0.01
      assertEquals(0.0, fraction.doubleValue(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNumeratorReturningNegative() throws Throwable  {
      // Create a fraction with a negative numerator and denominator
      Fraction fraction = new Fraction((-3247), (-3247));
      
      // Subtract an integer from the fraction, which should result in a negative value
      Fraction subtract = fraction.subtract(Integer.MAX_VALUE);
      
      // Add one to the result of the subtraction, which should make the result positive
      Fraction add = subtract.add(1);
      
      // Get the numerator and denominator of the result
      int numerator = add.getNumerator();
      int denominator = add.getDenominator();
      
      // Assert that the numerator is equal to the expected value
      assertEquals((-2147483645), numerator);
      
      // Assert that the denominator is equal to 1
      assertEquals(1, denominator);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFloatValueReturningNegative() throws Throwable  {
      // Given a fraction with a negative numerator and denominator
      Fraction fraction = new Fraction(1, (-2236));
      
      // When the fraction is converted to a float value
      float floatValue = fraction.floatValue();
      
      // Then the resulting float value should be equal to the absolute value of the numerator divided by the denominator, rounded to 4 decimal places
      assertEquals(2236, fraction.getDenominator());
      assertEquals((-4.4722718E-4F), floatValue, 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDoubleValueReturningZero() throws Throwable  {
      // Given a fraction with a small numerator and denominator
      Fraction fraction = new Fraction(1.7827257129423813E-8, 0);
      
      // When we convert the fraction to a double value
      double doubleValue = fraction.doubleValue();
      
      // Then we expect the resulting double value to be zero
      assertEquals(1, fraction.getDenominator());
      assertEquals(0.0, doubleValue, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDoubleValueReturningPositive() throws Throwable  {
      // Given a fraction with a numerator of 5 and a denominator of 5,
      // when we call the doubleValue method on it,
      // then the returned value should be equal to 1.0.
      Fraction fraction = new Fraction(5, 5);
      double doubleValue = fraction.doubleValue();
      assertEquals(1.0, doubleValue, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideTakingFractionReturningFractionWhereShortValueIsPositive() throws Throwable  {
      // Given a fraction of one fifth
      Fraction arg0 = Fraction.ONE_FIFTH;
      
      // When dividing by two thirds
      Fraction divide = arg0.divide(arg0);
      
      // Then the result should be three hundred and thirty-three point three three three three three three three seven
      assertEquals(333.33333333333337, divide.percentageValue(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideTakingFractionReturningFractionWhereShortValueIsNegative() throws Throwable  {
      // Given: a fraction with a negative numerator
      Fraction fraction = new Fraction(-460);
      
      // When: we take the reciprocal of that fraction
      Fraction arg0 = fraction.ONE.reciprocal();
      
      // Then: we get a fraction with a positive numerator and denominator
      assertEquals(100, arg0.percentageValue(), 0.01);
      
      // When: we divide that fraction by another negative one
      Fraction divide = arg0.MINUS_ONE.divide(arg0);
      
      // Then: we get a fraction with a negative numerator and denominator
      assertEquals(-1, divide.intValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFloatValueReturningZero() throws Throwable  {
      // Given a fraction with a value of 1/3
      Fraction fraction = Fraction.ONE_THIRD;
      
      // When we divide it by 751
      Fraction divide = fraction.divide(751);
      
      // Then the result should be 0.0 (with a tolerance of ±0.01)
      assertEquals(0.0F, divide.floatValue(), 0.01F);
      
      // And the percentage value should be 33.33333333333333% (with a tolerance of ±0.01%)
      assertEquals(33.33333333333333, fraction.percentageValue(), 0.01);
      
      // And the denominator should be 1
      assertEquals(1, divide.getDenominator());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideTakingIntReturningFractionWhereShortValueIsNegative() throws Throwable  {
      // rollbacked to evosuite
      Fraction fraction = new Fraction(310, 87);
      Fraction subtract = fraction.ONE_HALF.subtract((-123));
      Fraction divide = subtract.divide((-123));
      assertEquals((-247), divide.getNumerator());
      assertEquals((-1.004065F), divide.floatValue(), 0.01F);
      assertEquals(310, fraction.getNumerator());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTakingFractionReturningFractionWhereShortValueIsNegative() throws Throwable  {
      // Test that the add method returns the correct result when adding a negative number to a Fraction
      Fraction arg0 = Fraction.ONE_FIFTH;
      Fraction fraction = new Fraction((-15));
      Fraction add = fraction.add(arg0);
      assertEquals((-1480.0), add.percentageValue(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetReducedFractionReturningFractionWhereShortValueIsNegative() throws Throwable  {
      // rollbacked to evosuite
      Fraction reducedFraction = Fraction.getReducedFraction((-1807), 1);
      assertEquals((byte) (-15), reducedFraction.byteValue());
      assertEquals((-1807), reducedFraction.getNumerator());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTakingIntReturningFractionWhereShortValueIsZero() throws Throwable  {
      // Create a new fraction object with a numerator and denominator of 969 and 21
      Fraction arg0 = new Fraction(969, 21);
      
      // Calculate the percentage value of the fraction
      Fraction multiply = arg0.multiply(Fraction.ZERO);
      Fraction add = multiply.add(0);
      
      // Assert that the percentage value is equal to 4614.285714285715 with a tolerance of 0.01
      assertEquals(4614.285714285715, arg0.percentageValue(), 0.01);
      
      // Assert that the sum is equal to 0 with a tolerance of 0.01
      assertEquals(0.0, add.percentageValue(), 0.01);
      
      // Assert that the denominator is equal to 7
      assertEquals(7, arg0.getDenominator());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNegateReturningFractionWherePercentageValueIsZero() throws Throwable  {
      // Given a Fraction object with a numerator and denominator
      Fraction fraction = new Fraction(218, 218);
      
      // When we call the negate method on this fraction
      Fraction negatedFraction = fraction.negate();
      
      // Then the resulting fraction should have a negative numerator
      assertEquals(-218, negatedFraction.getNumerator());
      
      // And the same denominator as the original fraction
      assertEquals(fraction.getDenominator(), negatedFraction.getDenominator());
      
      // And the float value of the resulting fraction should be 0
      assertEquals(0.0F, negatedFraction.floatValue(), 0.01F);
      
      // And the percentage value of the resulting fraction should be 1
      assertEquals(1, negatedFraction.percentageValue(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDoubleValueReturningNegative() throws Throwable  {
      // Given: A Fraction object representing -1/1
      Fraction fraction = Fraction.MINUS_ONE;
      
      // When: The doubleValue method is called on the Fraction object
      double doubleValue = fraction.doubleValue();
      
      // Then: The resulting double value should be -1.0, with a margin of error of 0.01
      assertEquals((-1.0), doubleValue, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFractionTaking2ArgumentsAndCreatesFractionTaking2ArgumentsAndToString() throws Throwable  {
      // Given a fraction with a numerator and denominator of 218
      Fraction fraction = new Fraction(218, 218);
      
      // When the toString method is called on the fraction
      String string = fraction.toString();
      
      // Then the resulting string should be "1"
      assertEquals("1", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToString() throws Throwable  {
      // Given a Fraction object initialized with a negative value
      Fraction fraction = new Fraction((-1357.16721891));
      
      // When the toString method is called on the Fraction object
      String string = fraction.toString();
      
      // Then the returned string should be in the format of "negative numerator / denominator"
      assertEquals("-405793 / 299", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetReducedFractionThrowsArithmeticException0() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        Fraction.getReducedFraction(Integer.MIN_VALUE, (-706));
        fail("Expecting exception: ArithmeticException");
      
      } catch(ArithmeticException e) {
         //
         // overflow in fraction -2,147,483,648/-706, cannot negate
         //
         verifyException("org.apache.commons.math3.fraction.Fraction", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetReducedFractionReturningFractionWhereShortValueIsPositive() throws Throwable  {
      // Given an integer value as the numerator and denominator, we expect the method to return a reduced fraction.
      Fraction reducedFraction = Fraction.getReducedFraction(Integer.MIN_VALUE, Integer.MIN_VALUE);
      
      // When we call the getReducedFraction() method with the minimum integer values as arguments.
      double actualValue = reducedFraction.doubleValue();
      
      // Then we expect the result to be equal to 1.0 within a tolerance of 0.01.
      assertEquals(1.0, actualValue, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetReducedFractionThrowsArithmeticException1() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        Fraction.getReducedFraction((-779), Integer.MIN_VALUE);
        fail("Expecting exception: ArithmeticException");
      
      } catch(ArithmeticException e) {
         //
         // overflow in fraction -779/-2,147,483,648, cannot negate
         //
         verifyException("org.apache.commons.math3.fraction.Fraction", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetReducedFractionReturningFractionWhereShortValueIsZero() throws Throwable  {
      // No Comments were added
      Fraction reducedFraction = Fraction.getReducedFraction(0, (-1226));
      assertEquals(0.0, reducedFraction.doubleValue(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetReducedFractionWithZero() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        Fraction.getReducedFraction(0, 0);
        fail("Expecting exception: ArithmeticException");
      
      } catch(ArithmeticException e) {
         //
         // zero denominator in fraction 0/0
         //
         verifyException("org.apache.commons.math3.fraction.Fraction", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideTakingFractionThrowsArithmeticException() throws Throwable  {
      // Given a fraction of 0/1
      Fraction arg0 = Fraction.ZERO;
      
      // When we try to divide by 0
      try {
      arg0.divide(arg0);
      
      // Then an ArithmeticException is thrown
      fail("Expecting exception: ArithmeticException");
      } catch (ArithmeticException e) {
      // the fraction to divide by must not be zero: 0/1
      verifyException("org.apache.commons.math3.fraction.Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideTakingFractionWithNull() throws Throwable  {
      // Given a fraction object
      Fraction fraction = Fraction.TWO_QUARTERS;
      
      // When dividing by null
      try {
      fraction.divide((Fraction) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Then an exception is thrown
      verifyException("org.apache.commons.math3.fraction.Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTakingFractionWithFractionWhereShortValueIsZero() throws Throwable  {
      // Given: We have a Fraction object with numerator 969 and denominator 21
      Fraction fraction = new Fraction(969, 21);
      
      // When: We multiply the Fraction by zero
      Fraction arg0 = Fraction.ZERO;
      Fraction multiply = fraction.multiply(arg0);
      
      // Then: The result should be a Fraction with numerator 323 and denominator 46
      assertEquals(323, fraction.getNumerator());
      assertEquals(0, multiply.getNumerator());
      assertEquals(46.142857142857146, fraction.doubleValue(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideTakingFractionReturningFractionWhereShortValueIsZero() throws Throwable  {
      // Create a fraction with a value of 0
      Fraction fraction = Fraction.ZERO;
      
      // Divide the fraction by -1
      Fraction divide = fraction.divide(Fraction.MINUS_ONE);
      
      // Assert that the result is equal to 0, with a tolerance of 0.01
      assertEquals(0.0, divide.percentageValue(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTakingFractionWithNull() throws Throwable  {
      // Given
      Fraction fraction = Fraction.ONE;
      
      try {
      // When
      fraction.multiply((Fraction) null);
      
      // Then
      fail("Expecting exception: IllegalArgumentException");
      
      } catch (IllegalArgumentException e) {
      // Verify that the correct exception was thrown
      verifyException("org.apache.commons.math3.fraction.Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTakingFractionReturningFractionWhereShortValueIsPositive() throws Throwable  {
      // Given: A fraction with a value of 1
      Fraction arg0 = Fraction.ONE;
      
      // When: We multiply the fraction by itself
      Fraction multiply = arg0.multiply(arg0);
      
      // Then: The result should be 100%
      assertEquals(100.0, multiply.percentageValue(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTakingFractionThrowsArithmeticException() throws Throwable  {
      Fraction arg0 = new Fraction((-220.81));
      Fraction fraction = new Fraction((-2147483645), (-40));
      
      // This test is checking that an ArithmeticException is thrown when the numerator of the second fraction is too large after being multiplied by the first fraction.
      
      try {
      fraction.add(arg0);
      fail("Expecting exception: ArithmeticException");
      } catch (ArithmeticException e) {
      // This is the expected exception, as the numerator of the second fraction is too large after being multiplied by the first fraction.
      verifyException("org.apache.commons.math3.fraction.Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTakingFractionReturningFractionWhereShortValueIsPositive() throws Throwable  {
      // Given: A fraction with a numerator and denominator
      Fraction arg0 = new Fraction(5, 5);
      
      // When: Adding the fraction to itself
      Fraction add = arg0.ONE_THIRD.add(arg0);
      
      // Then: The result is one-third of the original value
      assertEquals((byte)1, arg0.byteValue());
      assertEquals(1.3333333333333333, add.doubleValue(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReciprocalReturningFractionWhereShortValueIsZero() throws Throwable  {
      // Given a fraction of 1/5 and an argument -15
      Fraction fraction = Fraction.ONE_FIFTH;
      Fraction arg0 = new Fraction((-15));
      
      // When we subtract the argument from the fraction
      Fraction subtract = fraction.subtract(arg0);
      
      // Then the result should be -12/5 and have a reciprocal of 5/(-12)
      assertEquals(new Fraction(-12, 5), subtract);
      assertEquals(new Fraction(5, -12), subtract.reciprocal());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSubtractTakingFractionReturningFractionWhereGetDenominatorIsZero() throws Throwable  {
      // Test that subtracting zero returns the same fraction
      Fraction arg0 = Fraction.ZERO;
      Fraction fraction = new Fraction(Double.NaN, 1);
      Fraction subtract = fraction.subtract(arg0);
      assertEquals(fraction, subtract);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSubtractTakingFraction() throws Throwable  {
      // Given: A Fraction object with a value of 2/3 and a denominator of 3
      Fraction arg0 = Fraction.TWO_THIRDS;
      
      // When: The fraction is subtracted from itself
      Fraction fraction = Fraction.ZERO;
      Fraction subtract = fraction.subtract(arg0);
      
      // Then: The result should be a negative value with a denominator of 3, and the percentage value should be -66.67%
      assertEquals((-66.66666666666666), subtract.percentageValue(), 0.01);
      assertEquals(3, subtract.getDenominator());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTakingFractionWithFractionWherePercentageValueIsZero() throws Throwable  {
      // Given: We have a fraction with value 0
      Fraction zeroFraction = Fraction.ZERO;
      
      // When: We add the fraction to itself
      Fraction result = zeroFraction.add(zeroFraction);
      
      // Then: The result should be the same as the original fraction
      assertSame(result, zeroFraction);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTakingFractionWithNull() throws Throwable  {
      // Given: a fraction with value 2/3
      Fraction fraction = Fraction.TWO_THIRDS;
      
      // When: adding null as an argument
      try {
      fraction.add((Fraction) null);
      
      // Then: an IllegalArgumentException is thrown
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the correct exception was thrown
      verifyException("org.apache.commons.math3.fraction.Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNegateThrowsArithmeticException() throws Throwable  {
      // Given a fraction with the minimum value
      Fraction fraction = new Fraction(Integer.MIN_VALUE);
      
      // When we try to negate it
      try {
      fraction.negate();
      
      // Then an ArithmeticException is thrown, because the negation of this fraction would cause an overflow
      fail("Expecting exception: ArithmeticException");
      } catch(ArithmeticException e) {
      verifyException("org.apache.commons.math3.fraction.Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndReciprocalAndEqualsReturningTrue() throws Throwable  {
      // Given: a fraction of 1
      Fraction arg0 = Fraction.ONE;
      
      // When: calling reciprocal on the fraction
      Fraction reciprocal = arg0.reciprocal();
      
      // Then: the reciprocal is also 1
      boolean equals = reciprocal.equals(arg0);
      assertTrue(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndReciprocalAndEqualsReturningFalse() throws Throwable  {
      // No Comments were added
      Fraction fraction = Fraction.ONE_HALF;
      Fraction arg0 = fraction.TWO_QUARTERS.reciprocal();
      boolean equals = fraction.equals(arg0);
      assertEquals(1, arg0.getDenominator());
      assertEquals(2.0F, arg0.floatValue(), 0.01F);
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndEqualsReturningFalse() throws Throwable  {
      // Given
      Fraction arg0 = Fraction.ONE;
      Fraction fraction = Fraction.ONE_THIRD;
      
      // When
      boolean equals = fraction.equals(arg0);
      
      // Then
      assertFalse(equals);
      
      // Verify that the fraction is not equal to ONE
      assertFalse(arg0.equals((Object)fraction));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndEqualsReturningTrue() throws Throwable  {
      // Given: a fraction with value 1/3
      Fraction arg0 = new Fraction(1, 3);
      
      // When: comparing the fraction to itself
      boolean equals = arg0.equals(arg0);
      
      // Then: the result should be true, indicating that the fraction is equal to itself
      assertTrue(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsWithNull() throws Throwable  {
      // Given a fraction with a value of 5/5
      Fraction fraction = new Fraction(5, 5);
      
      // When the equals method is called with null as an argument
      boolean equals = fraction.equals((Object) null);
      
      // Then the result should be false, indicating that the fraction is not equal to null
      assertFalse(equals);
      
      // And when the doubleValue method is called
      double doubleValue = fraction.doubleValue();
      
      // Then the result should be 1.0, which is the value of the fraction as a decimal number
      assertEquals(1.0, doubleValue, 0.01);
      
      // And when the getDenominator method is called
      int denominator = fraction.getDenominator();
      
      // Then the result should be 1, which is the value of the fraction's denominator
      assertEquals(1, denominator);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCompareToReturningPositive() throws Throwable  {
      // Given: We have two fractions, one being ONE_FIFTH and the other THREE_QUARTERS
      Fraction arg0 = Fraction.ONE_FIFTH;
      Fraction fraction = Fraction.THREE_QUARTERS;
      
      // When: We compare the two fractions using the compareTo method
      int compareTo = fraction.compareTo(arg0);
      
      // Then: The result of the comparison is 1, indicating that the first fraction is greater than the second
      assertEquals(1, compareTo);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCompareToReturningNegative() throws Throwable  {
      // Given a Fraction with value -1
      Fraction fraction = Fraction.MINUS_ONE;
      
      // And a second Fraction with value 3/5
      Fraction arg0 = Fraction.THREE_FIFTHS;
      
      // When we call compareTo on the first Fraction with the second one
      int compareTo = fraction.compareTo(arg0);
      
      // Then we expect the result to be -1
      assertEquals(-1, compareTo);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCompareToReturningZero() throws Throwable  {
      // Given: A fraction is being compared to itself
      Fraction arg0 = Fraction.ONE_QUARTER;
      int expectedCompareTo = 0;
      
      // When: Comparing the fraction to itself
      int compareTo = arg0.compareTo(arg0);
      
      // Then: The result of the comparison is 0, indicating that the fractions are equal
      assertEquals(expectedCompareTo, compareTo);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAbsReturningFractionWhereShortValueIsZero() throws Throwable  {
      // Given a fraction with a negative numerator
      Fraction fraction = new Fraction(1, (-2236));
      
      // When the abs method is called on the fraction
      Fraction abs = fraction.abs();
      
      // Then the result should be a fraction with a positive numerator and a denominator that matches the original fraction's denominator
      assertEquals((-1), abs.getNumerator());
      assertEquals(0.0F, abs.floatValue(), 0.01F);
      
      // And the result should have the same value as the original fraction when converted to a float with a precision of 0.01
      assertEquals((-4.4722718E-4F), abs.floatValue(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateFractionTaking2ArgumentsThrowsArithmeticException0() throws Throwable  {
      Fraction fraction = null;
      try {
      fraction = new Fraction(2146348014, Integer.MIN_VALUE);
      fail("Expecting exception: ArithmeticException");
      
      } catch (ArithmeticException e) {
      verifyException("org.apache.commons.math3.fraction.Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateFractionTaking2ArgumentsThrowsArithmeticException1() throws Throwable  {
      // Test for overflow in negation of a fraction with the minimum value of both numerator and denominator
      Fraction fraction = null;
      try {
      fraction = new Fraction(Integer.MIN_VALUE, Integer.MIN_VALUE);
      fail("Expecting exception: ArithmeticException");
      } catch (ArithmeticException e) {
      // Verify that the correct exception is thrown for overflow in negation of a fraction with the minimum value of both numerator and denominator
      verifyException("org.apache.commons.math3.fraction.Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateFractionTaking2ArgumentsThrowsArithmeticException2() throws Throwable  {
      // Test that an exception is thrown when the denominator is zero
      Fraction fraction = null;
      try {
      fraction = new Fraction(1, 0);
      fail("Expecting exception: ArithmeticException");
      } catch(ArithmeticException e) {
      // Check that the correct exception was thrown
      verifyException("org.apache.commons.math3.fraction.Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIntValueReturningNegative() throws Throwable  {
      // Given a fraction with a negative numerator and denominator
      Fraction fraction = new Fraction(3088.777495463214, (-806));
      
      // When we add four fifths to the fraction
      Fraction add = fraction.FOUR_FIFTHS.add((-806));
      
      // Then the result should have a numerator of 5 and a denominator of -805
      assertEquals(5, add.getNumerator());
      assertEquals(-805, add.getDenominator());
      
      // And the double value should be close to (-805.2) with a precision of 0.01
      assertEquals((-805.2), add.doubleValue(), 0.01);
      
      // And the int value should be equal to -805
      assertEquals(-805, add.intValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFractionTaking3Arguments() throws Throwable  {
      // Given a fraction with two equal numerators and denominators,
      // create a new fraction object with the same values
      Fraction fraction1 = null;
      try {
      fraction1 = new Fraction(0.29213721752603306, 0.29213721752603306, (-648));
      } catch(IllegalStateException e) {
      // illegal state: Unable to convert 0.292 to fraction after -648 iterations
      verifyException("org.apache.commons.math3.fraction.Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFractionTaking2Arguments0() throws Throwable  {
      // Test for overflow when converting a double to a fraction
      Fraction fraction = null;
      try {
      fraction = new Fraction(1, 3);
      fail("Expecting exception: IllegalStateException");
      } catch (IllegalStateException e) {
      // Verify that the correct exception is thrown
      verifyException("org.apache.commons.math3.fraction.Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFractionTakingDouble() throws Throwable  {
      // Given a fraction with a small value
      Fraction fraction = new Fraction(1.0E-8);
      
      // When the percentage value is calculated
      double percentageValue = fraction.percentageValue();
      
      // Then the percentage value should be close to 0
      assertEquals(0.0, percentageValue, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFractionTaking2Arguments1() throws Throwable  {
      // Test that Fraction throws an exception when trying to create a fraction with a negative numerator or denominator
      Fraction fraction = null;
      try {
      // Create a fraction with a large negative numerator and denominator, which should overflow
      fraction = new Fraction((double) Integer.MIN_VALUE, Integer.MIN_VALUE);
      
      // Verify that an IllegalStateException is thrown by the Fraction constructor
      fail("Expecting exception: IllegalStateException");
      } catch(IllegalStateException e) {
      
      // Verify that the exception message contains the expected information about the overflow
      verifyException("org.apache.commons.math3.fraction.Fraction", e);
      
      // Print a debug message indicating the fraction that caused the error
      System.out.println("Overflow trying to convert " + Integer.MIN_VALUE + "/" + Integer.MIN_VALUE + " to fraction");}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFractionTaking2Arguments2() throws Throwable  {
      // Given: A Fraction object is instantiated with a negative numerator and denominator
      Fraction fraction = null;
      
      // When: The Fraction object is created with an overflowing numerator and denominator
      try {
      fraction = new Fraction((double) (-2147483625), (-2147483625));
      
      // Then: An IllegalStateException is thrown indicating that the conversion has caused an overflow
      fail("Expecting exception: IllegalStateException");
      } catch(IllegalStateException e) {
      // Verify that the correct exception is thrown with the correct message
      verifyException("org.apache.commons.math3.fraction.Fraction", e);
      
      // Verify that the exception message indicates an overflow has occurred when converting the given numerator and denominator to a fraction
      assertEquals("illegal state: Overflow trying to convert -2,147,483,625 to fraction (-9,223,372,034,707,292,182/9,223,372,036,854,775,807)", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPercentageValueReturningPositive() throws Throwable  {
      // Given
      Fraction fraction = Fraction.ONE_FIFTH;
      
      // When
      double percentageValue = fraction.percentageValue();
      
      // Then
      assertEquals(20.0, percentageValue, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFloatValueReturningPositive() throws Throwable  {
      // Given a fraction representing 1/5
      Fraction fraction = Fraction.ONE_FIFTH;
      
      // When the float value is retrieved
      float floatValue = fraction.floatValue();
      
      // Then the float value should be equal to 0.2 within a tolerance of 0.01
      assertEquals(0.2F, floatValue, 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNumeratorReturningPositive() throws Throwable  {
      // Given: We have a Fraction object representing 1/4
      Fraction fraction = Fraction.ONE_QUARTER;
      
      // When: We call the getNumerator() method on this Fraction object
      int numerator = fraction.getNumerator();
      
      // Then: The returned value should be 1
      assertEquals(1, numerator);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashCode() throws Throwable  {
      // No Comments were added
      Fraction fraction = Fraction.ONE_HALF;
      fraction.hashCode();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIntValueReturningPositive() throws Throwable  {
      // Given: A fraction with a value of 1
      Fraction fraction = Fraction.ONE;
      
      // When: We call the intValue() method on the fraction
      int intValue = fraction.intValue();
      
      // Then: The result should be 1
      assertEquals(1, intValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSubtractTakingIntReturningFractionWhereShortValueIsZero() throws Throwable  {
      // Given: A fraction with a value of 1256
      Fraction fraction = new Fraction(1256);
      
      // When: Subtracting the same value from the fraction
      Fraction subtract = fraction.subtract(1256);
      
      // Then: The result should be 0.0F with a tolerance of 0.01F
      assertEquals(0.0F, subtract.floatValue(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLongValueReturningZero() throws Throwable  {
      // Given: We have a Fraction object initialized to ONE_FIFTH
      Fraction fraction = Fraction.ONE_FIFTH;
      
      // When: We call the longValue() method on the Fraction object
      long longValue = fraction.longValue();
      
      // Then: The long value of the Fraction object should be 0L, since it cannot be represented as a long
      assertEquals(0L, longValue);
      
      // And: The double value of the Fraction object should be close to 0.2, since it is approximately equal to that number
      assertEquals(0.2, fraction.doubleValue(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetField() throws Throwable  {
      // No Comments were added
      Fraction fraction = new Fraction(218, 218);
      fraction.ONE.getField();
      assertEquals(1.0F, fraction.floatValue(), 0.01F);
      assertEquals(1, fraction.getNumerator());
      assertEquals(1, fraction.intValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAbsReturningFractionWhereShortValueIsPositive() throws Throwable  {
      // Given: A fraction object with a negative value of -15 is created
      Fraction fraction = new Fraction(-15);
      
      // When: The absolute value of the fraction is calculated using the abs() method
      Fraction abs = fraction.abs();
      
      // Then: The resulting fraction is positive and has a value of 15
      assertEquals((byte) 15, abs.byteValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSubtractTakingFractionReturningFractionWherePercentageValueIsZero() throws Throwable  {
      // Given a fraction of 1/5
      Fraction arg0 = Fraction.ONE_FIFTH;
      
      // When we subtract the same fraction from it twice
      Fraction subtract = arg0.subtract(arg0);
      
      // Then the resulting fraction should have a denominator of 1 and a float value close to 0
      assertEquals(1, subtract.getDenominator());
      assertEquals(0.0F, subtract.floatValue(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideTakingIntReturningFractionWhereShortValueIsPositive() throws Throwable  {
      // rollbacked to evosuite
      Fraction fraction = Fraction.ONE;
      Fraction divide = fraction.divide(1);
      assertTrue(divide.equals((Object)fraction));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTakingIntReturningFractionWherePercentageValueIsPositive() throws Throwable  {
      // Given a fraction with a value of 1/5
      Fraction fraction = Fraction.ONE_FIFTH;
      
      // When we add 1 to the fraction
      Fraction add = fraction.add(1);
      
      // Then the result should have a denominator of 5
      assertEquals(5, add.getDenominator());
      
      // And the float value should be equal to 1.2F
      assertEquals(1.2F, add.floatValue(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDenominator() throws Throwable  {
      // Given a fraction object
      Fraction fraction = new Fraction(218, 218);
      
      // When converting to float value
      float floatValue = fraction.floatValue();
      
      // Then the result is expected to be 1.0F with an error tolerance of 0.01F
      assertEquals(1.0F, floatValue, 0.01F);
      
      // Given a denominator for the fraction object
      int denominator = fraction.getDenominator();
      
      // Then the result is expected to be 1 with an error tolerance of 0.01F
      assertEquals(1, denominator, 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTakingIntReturningFractionWhereShortValueIsPositive() throws Throwable  {
      // Given a fraction with a negative denominator
      Fraction fraction = new Fraction(1, -2236);
      
      // When we multiply it by 629
      Fraction multiply = fraction.TWO_QUARTERS.multiply(629);
      
      // Then the result is a fraction with a positive denominator
      assertEquals(2236, multiply.getDenominator());
      
      // And the float value of the result is 314.5F
      assertEquals(314.5F, multiply.floatValue(), 0.01F);
      
      // And the double value of the result is (-4.472271914132379E-4)
      assertEquals((-4.472271914132379E-4), multiply.doubleValue(), 0.01);
  }
}
