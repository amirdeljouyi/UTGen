/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 16:52:24 GMT 2024
 */

package org.apache.commons.math3.util;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import org.apache.commons.math3.exception.util.Localizable;
import org.apache.commons.math3.exception.util.LocalizedFormats;
import org.apache.commons.math3.util.MathUtils;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class MathUtils_ESTest extends MathUtils_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReduceReturningPositive() throws Throwable  {
      // Test that the MathUtils.reduce() method reduces a number by another number to its lowest value
      double reduce = MathUtils.reduce(-2929.2347500249, -1133.281908434397, 0.0);
      // The expected result of reducing -2929.2347500249 by -1133.281908434397 is 470.6109752782909
      assertEquals(470.6109752782909, reduce, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReduceReturningNegative() throws Throwable  {
      // No Comments were added
      double reduce = MathUtils.reduce((-4.9E-324), 2892.0, 0.0);
      assertEquals((-4.9E-324), reduce, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNormalizeAngleReturningPositive() throws Throwable  {
      // No Comments were added
      double normalizeAngle = MathUtils.normalizeAngle((-1065.0), 283.1012312);
      assertEquals(285.884841043611, normalizeAngle, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNormalizeAngleReturningNegative() throws Throwable  {
      // No Comments were added
      double normalizeAngle = MathUtils.normalizeAngle((-2630), (-234.749));
      assertEquals((-236.1063979645778), normalizeAngle, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashTakingDoubleArrayReturningPositive() throws Throwable  {
      // Given: An array of doubles with 4 elements
      double[] arg0 = new double[] {1.0, 2.0, 3.0, 4.0};
      
      // When: The hash function is applied to the array
      int hash = MathUtils.hash(arg0);
      
      // Then: The returned value should be equal to a predefined constant
      assertEquals(923521, hash);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashTakingDoubleArrayReturningNegative() throws Throwable  {
      // No Comments were added
      double[] arg0 = new double[9];
      arg0[1] = (double) (-1643);
      arg0[6] = 1643.0;
      int hash = MathUtils.hash(arg0);
      assertEquals((-795545313), hash);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashTakingDoubleReturningZero() throws Throwable  {
      // Given: A hash function that takes a double value and returns an integer hash code
      // When: The hash function is applied to the byte 0
      // Then: The returned hash code should be 0
      int hash = MathUtils.hash((double) (byte) 0);
      assertEquals(0, hash);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashTakingDoubleReturningNegative() throws Throwable  {
      // Calculate the hash code of a negative long value
      int hash = MathUtils.hash((double) (-1786L));
      assertEquals(-1063524352, hash);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNotNullTakingObjectWithNull() throws Throwable  {
      // rollbacked to evosuite
      try { 
        MathUtils.checkNotNull((Object) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // null is not allowed
         //
         verifyException("org.apache.commons.math3.util.MathUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNotNullTakingObject() throws Throwable  {
      // Given: a non-null object
      Object arg0 = new Object();
      
      // When: we call the method with this object as an argument
      MathUtils.checkNotNull(arg0);
      
      // Then: no exception is thrown
      assertDoesNotThrow(() -> MathUtils.checkNotNull(arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNotNullTaking3ArgumentsWithNullAndNonEmptyArray() throws Throwable  {
      // Given
      LocalizedFormats arg1 = LocalizedFormats.OBJECT_TRANSFORMATION;
      Object[] arg2 = new Object[7];
      
      try {
      // When
      MathUtils.checkNotNull(null, arg1, arg2);
      
      // Then
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // conversion exception in transformation
      verifyException("org.apache.commons.math3.util.MathUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNotNullTaking3Arguments() throws Throwable  {
      // Given a null argument and a non-null message
      Object arg0 = null;
      LocalizedFormats arg1 = LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE;
      
      // When checking that the argument is not null with a custom message
      MathUtils.checkNotNull(arg0, (Localizable) arg1, (Object[]) null);
      
      // Then an IllegalArgumentException should be thrown with the expected message
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckFiniteTakingDoubleArrayWithNonEmptyArray() throws Throwable  {
      // Given
      double[] input = new double[8];
      input[1] = Double.NaN;
      
      try {
      // When
      MathUtils.checkFinite(input);
      
      // Then
      fail("Expecting exception: IllegalArgumentException");
      
      } catch (IllegalArgumentException e) {
      // value \uFFFD at index 1
      verifyException("org.apache.commons.math3.util.MathUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckFiniteTakingDoubleArray0() throws Throwable  {
      // Test that a negative infinity value throws an IllegalArgumentException
      double[] args = new double[7];
      args[1] = Double.NEGATIVE_INFINITY;
      try {
      MathUtils.checkFinite(args);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Verify that the correct message is displayed
      assertEquals("value -\u221E at index 1", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckFiniteTakingDoubleArray1() throws Throwable  {
      // rollbacked to evosuite
      double[] arg0 = new double[8];
      MathUtils.checkFinite(arg0);
      assertArrayEquals(new double[] {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, arg0, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckFiniteTakingDouble() throws Throwable  {
      try {
      // Attempt to pass a non-finite number (NaN) to the checkFinite method
      MathUtils.checkFinite(Double.NaN);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that an IllegalArgumentException is thrown as expected
      verifyException("org.apache.commons.math3.util.MathUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckFiniteTakingDoubleAndCheckFiniteTakingDouble() throws Throwable  {
      // rollbacked to evosuite
      MathUtils.checkFinite((double) 1079L);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckFiniteTakingDoubleWithNegative() throws Throwable  {
      // Test that checkFinite throws an IllegalArgumentException for negative infinity
      try {
      MathUtils.checkFinite(Double.NEGATIVE_INFINITY);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Verify that the expected exception was thrown
      verifyException("org.apache.commons.math3.util.MathUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2LongsThrowsArithmeticException() throws Throwable  {
      // No Comments were added
      try { 
        MathUtils.copySign((-9223372036854775808L), 1512L);
        fail("Expecting exception: ArithmeticException");
      
      } catch(ArithmeticException e) {
         //
         // overflow
         //
         verifyException("org.apache.commons.math3.util.MathUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2Longs() throws Throwable  {
      // No Comments were added
      long copySign = MathUtils.copySign((-31L), (-901L));
      assertEquals((-31L), copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2LongsWithPositive() throws Throwable  {
      // Tests that MathUtils.copySign() returns a positive value when both arguments are positive, and a negative value when both arguments are negative.
      long copySign = MathUtils.copySign(3595L, (-1776L));
      assertEquals((-3595L), copySign);
      
      // Tests that MathUtils.copySign() returns the same sign as the first argument when the second argument is 0.
      long copySignZero = MathUtils.copySign(3595L, 0L);
      assertEquals(3595L, copySignZero);
      
      // Tests that MathUtils.copySign() returns the same sign as the first argument when the second argument is a positive value.
      long copySignPositive = MathUtils.copySign(3595L, 1776L);
      assertEquals(3595L, copySignPositive);
      
      // Tests that MathUtils.copySign() returns the opposite sign as the first argument when the second argument is a negative value.
      long copySignNegative = MathUtils.copySign(3595L, (-1776L));
      assertEquals((-3595L), copySignNegative);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2LongsReturningZero() throws Throwable  {
      // No Comments were added
      long copySign = MathUtils.copySign(0L, 647L);
      assertEquals(0L, copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2LongsReturningPositive() throws Throwable  {
      // No Comments were added
      long copySign = MathUtils.copySign((-1079L), 0L);
      assertEquals(1079L, copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2IntsThrowsArithmeticException() throws Throwable  {
      // Test the overflow condition of MathUtils.copySign() for Integer.MIN_VALUE
      
      try {
      MathUtils.copySign(Integer.MIN_VALUE, 3030);
      
      // This line should not be reached, as we are expecting an ArithmeticException to be thrown
      fail("Expecting exception: ArithmeticException");
      
      } catch (ArithmeticException e) {
      verifyException("org.apache.commons.math3.util.MathUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2Ints() throws Throwable  {
      // Test that the copySign method returns the correct sign for a given value
      int copySign = MathUtils.copySign((-2630), (-963));
      assertEquals((-2630), copySign); // Check that the result has the same sign as the input value
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2IntsWithPositive() throws Throwable  {
      // No Comments were added
      int copySign = MathUtils.copySign(2827, (int) (short) (-412));
      assertEquals((-2827), copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2IntsReturningZero() throws Throwable  {
      int copySign = MathUtils.copySign((int) (short)0, 1052270332);
      assertEquals(0, copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2IntsReturningPositive() throws Throwable  {
      // No Comments were added
      int copySign = MathUtils.copySign((-2198), 292);
      assertEquals(2198, copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2ShortsReturningPositive() throws Throwable  {
      // No Comments were added
      short copySign = MathUtils.copySign((short) (-4974), (short)20344);
      assertEquals((short)4974, copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2ShortsThrowsArithmeticException() throws Throwable  {
      try {
      // Try to copy the sign of a short value that is less than -32768
      MathUtils.copySign((short) (-32768), (short)108);
      fail("Expecting exception: ArithmeticException");
      } catch(ArithmeticException e) {
      // Catch the expected exception and verify that it is an overflow error
      verifyException("org.apache.commons.math3.util.MathUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2ShortsWithPositive() throws Throwable  {
      // No Comments were added
      short copySign = MathUtils.copySign((short)1331, (short) (-2050));
      assertEquals((short) (-1331), copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2ShortsReturningZero() throws Throwable  {
      // No Comments were added
      short copySign = MathUtils.copySign((short)0, (short)0);
      assertEquals((short)0, copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2Shorts() throws Throwable  {
      // No Comments were added
      short copySign = MathUtils.copySign((short) (-2050), (short) (-1331));
      assertEquals((short) (-2050), copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2BytesReturningPositive() throws Throwable  {
      // No Comments were added
      byte copySign = MathUtils.copySign((byte) (-66), (byte)121);
      assertEquals((byte)66, copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2BytesThrowsArithmeticException() throws Throwable  {
      // Test that copySign throws an ArithmeticException when the result of the operation is outside the range of the destination type.
      try {
      MathUtils.copySign((byte) (-128), (byte)38);
      fail("Expecting exception: ArithmeticException");
      } catch(ArithmeticException e) {
      // Verify that the exception is the expected one.
      verifyException("org.apache.commons.math3.util.MathUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2BytesReturningZero() throws Throwable  {
      // No Comments were added
      byte copySign = MathUtils.copySign((byte)0, (byte)37);
      assertEquals((byte)0, copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2BytesWithPositive() throws Throwable  {
      // Test that the copySign method returns a negative value if the first argument is negative and the second argument is positive
      byte copySign = MathUtils.copySign((byte)13, (byte) (-66));
      assertEquals((byte) (-13), copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopySignTaking2Bytes() throws Throwable  {
      // Given: A byte value of -101 is provided as the first argument to MathUtils.copySign() method
      // When: The method is called with the provided byte value and a second argument also being a byte value of -101
      byte copySign = MathUtils.copySign((byte) (-101), (byte) (-101));
      // Then: The return value should be a byte value of -101, which is the same as the first argument provided
      assertEquals((byte) (-101), copySign);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashTakingDoubleArrayReturningZero() throws Throwable  {
      // Test that passing null as input to MathUtils.hash returns 0
      int hash = MathUtils.hash((double[]) null);
      assertEquals(0, hash);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashTakingDoubleReturningPositive() throws Throwable  {
      // No Comments were added
      int hash = MathUtils.hash(123.456);
      assertEquals(1522623320, hash);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNormalizeAngleReturningZero() throws Throwable  {
      // rollbacked to evosuite
      double normalizeAngle = MathUtils.normalizeAngle(0.0, 1.9987994582857286E-8);
      assertEquals(0.0, normalizeAngle, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReduceReturningZero() throws Throwable  {
      // Test the reduce method with negative numbers
      double reduce = MathUtils.reduce((short) (-15419), (short) (-15419), (short) (-15419));
      assertEquals(0.0, reduce, 0.01);
  }
}
