/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 17:18:05 GMT 2024
 */

package org.apache.commons.math3.optim.nonlinear.scalar.noderiv;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Comparator;
import org.apache.commons.math3.analysis.MultivariateFunction;
import org.apache.commons.math3.optim.PointValuePair;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class AbstractSimplex_ESTest extends AbstractSimplex_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSize() throws Throwable  {
      // Given
      double[] arg0 = new double[1];
      arg0[0] = Double.NaN;
      
      // When
      MultiDirectionalSimplex multiDirectionalSimplex = new MultiDirectionalSimplex(arg0);
      multiDirectionalSimplex.build(arg0);
      
      // Then
      int size = multiDirectionalSimplex.getSize();
      assertEquals(2, size);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPoints() throws Throwable  {
      // Given a MultiDirectionalSimplex with dimension 2
      MultiDirectionalSimplex multiDirectionalSimplex = new MultiDirectionalSimplex(2);
      
      // When the build method is called on the MultiDirectionalSimplex object
      double[] arg0 = new double[2];
      multiDirectionalSimplex.build(arg0);
      
      // Then the MultiDirectionalSimplex object should have a PointValuePair array with 3 elements
      PointValuePair[] points = multiDirectionalSimplex.getPoints();
      assertEquals(3, points.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetPointWithPositiveAndNonNull() throws Throwable  {
      double[] arg0 = new double[1];
      arg0[0] = Double.NaN;
      MultiDirectionalSimplex multiDirectionalSimplex = new MultiDirectionalSimplex(arg0);
      multiDirectionalSimplex.build(arg0);
      PointValuePair arg1 = new PointValuePair(arg0, 2439.77302223);
      // This test verifies that the setPoint method throws an IllegalArgumentException
      // when passed a point outside of the [0, 1] range.
      try {
      multiDirectionalSimplex.setPoint(1038, arg1);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // The IllegalArgumentException is expected because the point (1038, 2439.77302223)
      // is outside of the [0, 1] range.
      verifyException("org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetPointThrowsNullPointerException() throws Throwable  {
      // Test that setPoint throws a NullPointerException when passed a null point value pair
      NelderMeadSimplex nelderMeadSimplex = new NelderMeadSimplex(101);
      try {
      nelderMeadSimplex.setPoint(-444, (PointValuePair) null);
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      // Verify that the exception is an instance of the expected type and has no message
      assertTrue(e instanceof NullPointerException);
      assertNull(e.getMessage());
      throw e;}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPointWithPositive() throws Throwable  {
      // Given: A MultiDirectionalSimplex instance with a non-null initial point
      double[] arg0 = new double[1];
      arg0[0] = Double.NaN;
      MultiDirectionalSimplex multiDirectionalSimplex = new MultiDirectionalSimplex(arg0);
      
      // When: The build method is called with the same initial point
      multiDirectionalSimplex.build(arg0);
      
      // Then: An exception should be thrown, indicating that the point is outside the [0, 1] range
      try {
      multiDirectionalSimplex.getPoint(2);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // 2 out of [0, 1] range
      verifyException("org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPoint() throws Throwable  {
      // Given a valid input array of doubles
      double[] arg0 = new double[1];
      arg0[0] = Double.NaN;
      
      // When the build method is called with the input array
      MultiDirectionalSimplex multiDirectionalSimplex = new MultiDirectionalSimplex(arg0);
      multiDirectionalSimplex.build(arg0);
      
      // Then the resulting object should not be null
      assertNotNull(multiDirectionalSimplex);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPointThrowsNullPointerException() throws Throwable  {
      // Given a MultiDirectionalSimplex object with 95 points
      MultiDirectionalSimplex multiDirectionalSimplex = new MultiDirectionalSimplex(95);
      
      // When the getPoint method is called with a negative index
      try {
      multiDirectionalSimplex.getPoint((-1789));
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      // Then an exception should be thrown because the index is invalid
      
      // Verify that the exception is of the expected type and has no message
      verifyException("org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuildWithEmptyArray() throws Throwable  {
      MultiDirectionalSimplex multiDirectionalSimplex = new MultiDirectionalSimplex(22);
      double[] arg0 = new double[0];
      // Undeclared exception!
      try {
      multiDirectionalSimplex.build(arg0);
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      //
      // The method build() requires a non-empty array of doubles as argument, but an empty array was provided.
      //
      verifyException("org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test0() throws Throwable  {
      double[] doubleArray = new double[1];
      // Initialize a 1D array of doubles with a single value of Double.NaN
      doubleArray[0] = Double.NaN;
      // Create a 2D array of doubles where each row is a copy of the doubleArray
      double[][] arg0 = new double[2][2];
      arg0[0] = doubleArray;
      arg0[1] = doubleArray;
      
      // Initialize a MultiDirectionalSimplex object with the 2D array of doubles
      MultiDirectionalSimplex multiDirectionalSimplex = new MultiDirectionalSimplex(arg0);
      
      // Assert that the MultiDirectionalSimplex has a dimension of 1
      assertEquals(1, multiDirectionalSimplex.getDimension());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test1() throws Throwable  {
      double[] doubleArray = new double[4];
      // A 2D array of doubles representing a simplex configuration
      double[][] arg0 = new double[5][5];
      arg0[0] = doubleArray; // First row of the simplex configuration
      arg0[1] = doubleArray; // Second row of the simplex configuration
      MultiDirectionalSimplex multiDirectionalSimplex = null;
      try {
      multiDirectionalSimplex = new MultiDirectionalSimplex(arg0);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Test that the constructor throws an IllegalArgumentException when two vertices are equal in a simplex configuration.
      verifyException("org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDimensionReturningZero() throws Throwable  {
      // Given a 1x0 double matrix as input, we expect the MultiDirectionalSimplex class to return a dimension of 0
      double[][] arg0 = new double[1][0];
      MultiDirectionalSimplex multiDirectionalSimplex = new MultiDirectionalSimplex(arg0);
      int expectedDimension = 0;
      
      // When we call the getDimension method on the MultiDirectionalSimplex object, we expect it to return the dimension of the input matrix
      int actualDimension = multiDirectionalSimplex.getDimension();
      
      // Then we assert that the returned dimension is equal to the expected dimension
      assertEquals(expectedDimension, actualDimension);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test2() throws Throwable  {
      // Given a set of points to form a simplex, check if the simplex contains at least one point.
      double[][] arg0 = new double[0][1];
      NelderMeadSimplex nelderMeadSimplex = null;
      try {
      // When trying to create a Nelder-Mead simplex with an empty set of points, it should throw an IllegalArgumentException.
      nelderMeadSimplex = new NelderMeadSimplex(arg0, Double.NaN, (-1.0), Double.NaN, Double.NaN);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Then verify that the exception is thrown due to the simplex containing no points.
      verifyException("org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test3() throws Throwable  {
      // Given a 2x2 double array as input to the MultiDirectionalSimplex constructor
      double[][] arg0 = new double[2][2];
      
      // When the MultiDirectionalSimplex object is constructed with this input
      MultiDirectionalSimplex multiDirectionalSimplex = null;
      try {
      multiDirectionalSimplex = new MultiDirectionalSimplex(arg0);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Then an IllegalArgumentException is thrown because the array dimensions are not equal to 1
      verifyException("org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test4() throws Throwable  {
      // Given: an array of double values representing the vertices of a simplex
      double[] vertices = new double[10];
      
      // When: the MultiDirectionalSimplex class is instantiated with these vertices
      MultiDirectionalSimplex simplex = null;
      try {
      simplex = new MultiDirectionalSimplex(vertices);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Then: an IllegalArgumentException is thrown due to the equal vertices 0 and {1} in the simplex configuration
      assertTrue(e.getMessage().contains("equal vertices 0 and 1 in simplex configuration"));}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test5() throws Throwable  {
      NelderMeadSimplex nelderMeadSimplex = null;
      try {
      // Attempt to create a Nelder-Mead simplex with a zero value, which is not allowed.
      nelderMeadSimplex = new NelderMeadSimplex(0);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Verify that the correct exception was thrown
      verifyException("org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test6() throws Throwable  {
      // No Comments were added
      NelderMeadSimplex nelderMeadSimplex = null;
      try {
        nelderMeadSimplex = new NelderMeadSimplex((double[]) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // null is not allowed
         //
         verifyException("org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuild() throws Throwable  {
      double[] arg0 = new double[1];
      arg0[0] = Double.NaN;
      MultiDirectionalSimplex multiDirectionalSimplex = new MultiDirectionalSimplex(arg0);
      multiDirectionalSimplex.build(arg0);
      Comparator<PointValuePair> arg1 = (Comparator<PointValuePair>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      
      // Test that a NullPointerException is thrown when passing null as the function
      assertThrows(NullPointerException.class, () -> {
      multiDirectionalSimplex.iterate(null, arg1);});
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDimensionReturningPositive() throws Throwable  {
      // Given a MultiDirectionalSimplex instance with 104 vertices
      MultiDirectionalSimplex multiDirectionalSimplex = new MultiDirectionalSimplex(104);
      
      // When we call the getDimension method
      int dimension = multiDirectionalSimplex.getDimension();
      
      // Then the returned value should be 104
      assertEquals(104, dimension);
  }
}
