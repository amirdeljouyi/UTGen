/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 09:58:30 GMT 2024
 */

package org.joda.time.chrono;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.LocalDate;
import org.joda.time.Period;
import org.joda.time.ReadableDateTime;
import org.joda.time.ReadablePeriod;
import org.joda.time.chrono.CopticChronology;
import org.joda.time.chrono.ISOChronology;
import org.joda.time.chrono.LimitChronology;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class LimitChronology_ESTest extends LimitChronology_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckLimits() throws Throwable  {
      // Given a CopticChronology instance, arg0
      CopticChronology arg0 = CopticChronology.getInstance();
      
      // When creating a LimitChronology instance using the given CopticChronology and null start and end dates
      LimitChronology instance = LimitChronology.getInstance(arg0, (ReadableDateTime) null, (ReadableDateTime) null);
      
      // Then the instance must not contain duplicate entries in the "Types" array
      instance.checkLimits(1L, "Types array must not contain duplicate: ");
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateTimeMillisTaking5ArgumentsReturningPositive() throws Throwable  {
      // Given a CopticChronology instance with a specific set of parameters
      CopticChronology arg0 = CopticChronology.getInstance();
      
      // When we create a LimitChronology instance using the CopticChronology instance and null start and end dates
      LimitChronology instance = LimitChronology.getInstance(arg0, (ReadableDateTime) null, (ReadableDateTime) null);
      
      // Then the getDateTimeMillis method should return a specific value for a given set of parameters
      long dateTimeMillis = instance.getDateTimeMillis((long) 1, 1, 1, 1, 1);
      assertEquals(3661001L, dateTimeMillis);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateTimeMillisTaking5ArgumentsReturningNegative() throws Throwable  {
      // Given a CopticChronology instance with the default start of the epoch as 0 BC
      CopticChronology copticChronology = CopticChronology.getInstance();
      
      // And a LimitChronology instance using the CopticChronology instance and null start and end dates
      LimitChronology limitChronology = LimitChronology.getInstance(copticChronology, (ReadableDateTime) null, (ReadableDateTime) null);
      
      // When we call getDateTimeMillis with arguments (-290, 0, 1, 26, 26)
      long dateTimeMillis = limitChronology.getDateTimeMillis(-290L, 0, 1, 26, 26);
      
      // Then the result should be the number of milliseconds since the epoch (January 1, 1 BC) for the Coptic date -290-0-01-26-26
      assertEquals(-86313974L, dateTimeMillis);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateTimeMillisTaking4ArgumentsReturningPositive() throws Throwable  {
      // Test the LimitChronology class with CopticChronology as its base chronology
      // Create a CopticChronology instance
      CopticChronology arg0 = CopticChronology.getInstanceUTC();
      // Create a LimitChronology instance with the CopticChronology as its base chronology and null start and end limits
      LimitChronology instance = LimitChronology.getInstance(arg0, (ReadableDateTime) null, (ReadableDateTime) null);
      // Get the DateTimeMillis for 2727-01-01T04:845 in the Coptic calendar
      long dateTimeMillis = instance.getDateTimeMillis(2727, 1, 1, 4845);
      // Assert that the DateTimeMillis is equal to the expected value of 32841763204845L
      assertEquals(32841763204845L, dateTimeMillis);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateTimeMillisTaking5ArgumentsThrowsIllegalArgumentException() throws Throwable  {
      // Arrange
      CopticChronology arg0 = CopticChronology.getInstanceUTC();
      DateTime arg2 = new DateTime((Chronology) arg0);
      LimitChronology instance = LimitChronology.getInstance(arg0, (ReadableDateTime) null, arg2);
      
      // Act and Assert
      try {
      instance.getDateTimeMillis(1L, 1, -5000, 3827, 3827);
      fail("Expected exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Value -5000 for minuteOfHour must be in the range [0,59]
      verifyException("org.joda.time.field.FieldUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZone() throws Throwable  {
      // rollbacked to evosuite
      CopticChronology arg0 = CopticChronology.getInstanceUTC();
      LimitChronology instance = LimitChronology.getInstance(arg0, (ReadableDateTime) null, (ReadableDateTime) null);
      Chronology withZone = instance.withZone((DateTimeZone) null);
      assertNotSame(withZone, instance);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLowerLimit() throws Throwable  {
      // No Comments were added
      CopticChronology arg0 = CopticChronology.getInstanceUTC();
      DateTime arg1 = new DateTime(1, 1, 1, 1, 1, 1, 1);
      DateTime arg2 = arg1.withMillis((-42697411200247L));
      LimitChronology instance = LimitChronology.getInstance(arg0, arg1, arg2);
      DateTime lowerLimit = instance.getLowerLimit();
      assertNotSame(arg2, lowerLimit);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetInstanceThrowsIllegalArgumentException() throws Throwable  {
      // Setup
      CopticChronology arg0 = CopticChronology.getInstanceUTC();
      DateTime arg2 = DateTime.now((Chronology) arg0);
      
      // Test
      try {
      LimitChronology.getInstance(arg0, arg2, arg2);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Verify
      assertEquals("The lower limit must be before than the upper limit", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetInstanceWithNull() throws Throwable  {
      // Test that a NullPointerException is thrown when trying to get an instance of LimitChronology with a null chronology
      try {
      LimitChronology.getInstance((Chronology) null, (ReadableDateTime) null, (ReadableDateTime) null);
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      //
      // Must supply a chronology
      //
      verifyException("org.joda.time.chrono.LimitChronology", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetInstanceWithReadableDateTimeWhereGetMillisIsZero() throws Throwable  {
      // Given a Coptic Chronology and a limit DateTime
      CopticChronology arg0 = CopticChronology.getInstanceUTC();
      LocalDate localDate = new LocalDate((long) 1, (Chronology) arg0);
      DateTime arg1 = localDate.toDateTimeAtStartOfDay((DateTimeZone) null);
      
      // When we create a LimitChronology with the Chronology and limit DateTime
      LimitChronology instance = LimitChronology.getInstance(arg0, arg1, (ReadableDateTime) null);
      
      // Then the returned chronology should have the same zone as the input Chronology
      assertNotSame(instance.withZone((DateTimeZone) null), instance);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetInstanceWithNullAndReadableDateTimeWhereGetMillisIsPositive() throws Throwable  {
      // Given a CopticChronology instance with UTC as the timezone
      CopticChronology arg0 = CopticChronology.getInstanceUTC();
      
      // And a DateTime object created using the CopticChronology instance
      DateTime arg2 = new DateTime((Chronology) arg0);
      
      // When we create a LimitChronology instance using the CopticChronology instance and the DateTime object
      LimitChronology instance = LimitChronology.getInstance(arg0, (ReadableDateTime) null, arg2);
      
      // Then we get an instance of the LimitChronology class with the CopticChronology as its underlying chronology, NoLimit as its limit, and a DateTime object representing 1730-06-07T20:21:21.320Z
      String string = instance.toString();
      assertEquals("LimitChronology[CopticChronology[UTC], NoLimit, 1730-06-07T20:21:21.320Z]", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test() throws Throwable  {
      // rollbacked to evosuite
      CopticChronology instanceUTC = CopticChronology.getInstanceUTC();
      Period period = Period.ZERO;
      Period arg0 = period.withHours(2727);
      long add = instanceUTC.add((ReadablePeriod) arg0, (-53184209313999L), 4845);
      assertEquals((-5619875313999L), add);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateTimeMillisTaking7Arguments() throws Throwable  {
      // Arrange
      CopticChronology arg0 = CopticChronology.getInstance();
      LimitChronology instance = LimitChronology.getInstance(arg0, (ReadableDateTime) null, (ReadableDateTime) null);
      
      // Act
      long dateTimeMillis = instance.getDateTimeMillis(1, 1, 1, 1, 1, 1, 1);
      
      // Assert
      assertEquals((-53184207538999L), dateTimeMillis);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetInstanceWithReadableDateTimeWhereGetMillisIsPositiveAndNull() throws Throwable  {
      // Create a CopticChronology instance for the current time
      CopticChronology arg0 = CopticChronology.getInstance();
      DateTime arg1 = new DateTime();
      
      // Create a LimitChronology instance with the CopticChronology and the current time as the limit,
      // with no upper bound on the limit (i.e., noLimit)
      LimitChronology instance = LimitChronology.getInstance(arg0, arg1, (ReadableDateTime) null);
      
      // Convert the LimitChronology instance to a string representation
      String string = instance.toString();
      
      // Assert that the string representation matches the expected value
      assertEquals("LimitChronology[CopticChronology[Etc/UTC], 2014-02-14T20:21:21.320Z, NoLimit]", string);
      
      // End of test
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetUpperLimit() throws Throwable  {
      // Given: We have a CopticChronology object named "arg0" and a LimitChronology object named "instance" created with the CopticChronology object as an argument.
      CopticChronology arg0 = CopticChronology.getInstance();
      LimitChronology instance = LimitChronology.getInstance(arg0, (ReadableDateTime) null, (ReadableDateTime) null);
      
      // When: We call the getUpperLimit() method on the "instance" object.
      DateTime upperLimit = instance.getUpperLimit();
      
      // Then: The returned value is null.
      assertNull(upperLimit);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateTimeMillisTaking4ArgumentsReturningNegative() throws Throwable  {
      // Given a CopticChronology object
      CopticChronology copticChronology = CopticChronology.getInstance();
      
      // And a LimitChronology object with null start and end date times
      LimitChronology limitChronology = LimitChronology.getInstance(copticChronology, (ReadableDateTime) null, (ReadableDateTime) null);
      
      // When the getDateTimeMillis method is called with a valid year, month, day, and hour
      long dateTimeMillis = limitChronology.getDateTimeMillis(1, 1, 1, 1);
      
      // Then the returned value should be -53184211199999L
      assertEquals((-53184211199999L), dateTimeMillis);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateTimeMillisTaking5ArgumentsWithNegative() throws Throwable  {
      // Create an instance of ISOChronology with no time zone
      ISOChronology arg0 = ISOChronology.getInstance((DateTimeZone) null);
      
      // Create a new DateTime object with the current date and time in the UTC time zone
      DateTime arg2 = new DateTime((DateTimeZone) null);
      
      // Create an instance of LimitChronology using the previously created ISOChronology and DateTime objects
      LimitChronology instance = LimitChronology.getInstance(arg0, (ReadableDateTime) null, arg2);
      
      try {
      // Call getDateTimeMillis with a large value for the instant parameter, which is above the supported maximum of 2014-02-14T20:21:21.320Z (ISOChronology[Etc/UTC])
      instance.getDateTimeMillis(9223372036854775807L, 2147482509, (-6), 2147483051, (-6));
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the exception is an IllegalArgumentException with a message containing "The instant is above the supported maximum"
      verifyException("org.joda.time.chrono.LimitChronology", e);}
  }
}
