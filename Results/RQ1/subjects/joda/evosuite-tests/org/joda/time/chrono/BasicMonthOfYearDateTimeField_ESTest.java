/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 09:49:29 GMT 2024
 */

package org.joda.time.chrono;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.joda.time.Chronology;
import org.joda.time.DurationField;
import org.joda.time.MonthDay;
import org.joda.time.Months;
import org.joda.time.ReadablePartial;
import org.joda.time.ReadablePeriod;
import org.joda.time.chrono.BasicMonthOfYearDateTimeField;
import org.joda.time.chrono.CopticChronology;
import org.joda.time.chrono.EthiopicChronology;
import org.joda.time.chrono.GJMonthOfYearDateTimeField;
import org.joda.time.chrono.GregorianChronology;
import org.joda.time.chrono.IslamicChronology;
import org.joda.time.chrono.JulianChronology;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class BasicMonthOfYearDateTimeField_ESTest extends BasicMonthOfYearDateTimeField_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetReturningNegative() throws Throwable  {
      // Arrange
      EthiopicChronology ethiopicChronology = EthiopicChronology.getInstanceUTC();
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(ethiopicChronology);
      long input = -2190L;
      
      // Act
      long result = gJMonthOfYearDateTimeField.set(input, 1);
      
      // Assert
      assertEquals((-7776002190L), result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundFloorReturningPositive() throws Throwable  {
      // Create an instance of the IslamicChronology class with UTC time zone
      IslamicChronology arg0 = IslamicChronology.getInstanceUTC();
      
      // Create a GJMonthOfYearDateTimeField object using the IslamicChronology instance as an argument
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(arg0);
      
      // Round down to the previous month of the date specified in the test case (1814400010L) using the GJMonthOfYearDateTimeField object
      long roundFloor = gJMonthOfYearDateTimeField.roundFloor(1814400010L);
      
      // Assert that the rounded value is equal to the expected month of the year (691200000L)
      assertEquals(691200000L, roundFloor);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundFloorReturningNegative() throws Throwable  {
      // Test the roundFloor method of the BasicMonthOfYearDateTimeField class
      // with a month number of 1 and a time zone of EthiopicChronology
      EthiopicChronology ethiopicChronology = EthiopicChronology.getInstance();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(ethiopicChronology, 1);
      long roundFloor = basicMonthOfYearDateTimeField.roundFloor(1);
      assertEquals((-1900800000L), roundFloor);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemainderReturningPositive() throws Throwable  {
      // rollbacked to evosuite
      EthiopicChronology arg0 = EthiopicChronology.getInstance();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(arg0, 1);
      long remainder = basicMonthOfYearDateTimeField.remainder(1);
      assertEquals(1900800001L, remainder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetReturningNegative() throws Throwable  {
      // Given a date with a year value of -166765824000000L and a chronology object
      IslamicChronology arg0 = IslamicChronology.getInstanceUTC();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(arg0, 1);
      
      // When the get() method is called on the BasicMonthOfYearDateTimeField object with a date value of -166765824000000L
      int get = basicMonthOfYearDateTimeField.get((-166765824000000L));
      
      // Then the result should be the month of January (-94)
      assertEquals((-94), get);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddWrapFieldReturningPositive() throws Throwable  {
      // rollbacked to evosuite
      EthiopicChronology arg0 = EthiopicChronology.getInstance();
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(arg0);
      long addWrapField = gJMonthOfYearDateTimeField.addWrapField((long) 1, 48);
      assertEquals(21772800001L, addWrapField);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddWrapFieldReturningNegative() throws Throwable  {
      // Given a BasicMonthOfYearDateTimeField with EthiopicChronology and a long value of -9223372036854775808L
      EthiopicChronology arg0 = EthiopicChronology.getInstance();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(arg0, 1);
      long value = -9223372036854775808L;
      
      // When addWrapField is called with a delta of 1
      long addWrapField = basicMonthOfYearDateTimeField.addWrapField(value, 1);
      
      // Then the result should be -9223372034262775808L
      assertEquals(-9223372034262775808L, addWrapField);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsLeapReturningTrue() throws Throwable  {
      // Given a date in the Islamic calendar with a month of July and a year of 1435
      IslamicChronology islamicChronology = IslamicChronology.getInstanceUTC();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(islamicChronology, 7);
      long date = 21859200000L; // July 1435
      
      // When we check if the date is a leap year
      boolean leap = basicMonthOfYearDateTimeField.isLeap(date);
      
      // Then we expect it to be a leap year
      assertTrue(leap);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesBasicMonthOfYearDateTimeFieldAndCallsIsLeap() throws Throwable  {
      // rollbacked to evosuite
      IslamicChronology arg0 = IslamicChronology.getInstanceUTC();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(arg0, 7);
      boolean leap = basicMonthOfYearDateTimeField.isLeap(27L);
      assertFalse(leap);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetReturningZero() throws Throwable  {
      // Create a new instance of CopticChronology using the default constructor.
      CopticChronology arg0 = CopticChronology.getInstance();
      
      // Create an instance of GJMonthOfYearDateTimeField using the specified CopticChronology.
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(arg0);
      
      // Set the month to April (April is represented as 4 in CopticCalendar) and get the result.
      long set = gJMonthOfYearDateTimeField.set(0L, 4);
      
      // Assert that the returned value is equal to 0, which means the date has not changed.
      assertEquals(0L, set);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesBasicMonthOfYearDateTimeFieldAndCallsAddTaking1And1() throws Throwable  {
      // Given
      IslamicChronology islamicChronology = IslamicChronology.getInstanceUTC();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(islamicChronology, 7);
      
      // When
      long add = basicMonthOfYearDateTimeField.add(-1777L, -2874);
      
      // Then
      assertEquals(-7332854401777L, add);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTaking1And1ReturningZero() throws Throwable  {
      // Given a date of March 15th, 2023
      IslamicChronology arg0 = IslamicChronology.getInstanceUTC();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(arg0, 7);
      long originalDate = basicMonthOfYearDateTimeField.add(0L, 0);
      
      // When adding zero months to the date
      long addedDate = basicMonthOfYearDateTimeField.add(originalDate, 0);
      
      // Then the original date should be returned
      assertEquals(originalDate, addedDate);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMinimumValue() throws Throwable  {
      // Arrange
      IslamicChronology chronology = IslamicChronology.getInstance();
      BasicMonthOfYearDateTimeField monthField = new BasicMonthOfYearDateTimeField(chronology, 1);
      
      // Act
      int minimumValue = monthField.getMinimumValue();
      
      // Assert
      assertEquals(1, minimumValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMaximumValue() throws Throwable  {
      // Test to ensure that the EthiopicChronology instance is correctly initialized
      EthiopicChronology arg0 = EthiopicChronology.getInstanceUTC();
      
      // Test to create a BasicMonthOfYearDateTimeField object and get its maximum value
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(arg0, 1);
      int maximumValue = basicMonthOfYearDateTimeField.getMaximumValue();
      
      // Assert that the maximum value of the field is equal to 13
      assertEquals(13, maximumValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLeapAmountReturningPositive() throws Throwable  {
      // Given: A reference to the EthiopicChronology object with UTC as its timezone
      EthiopicChronology arg0 = EthiopicChronology.getInstanceUTC();
      
      // When: A new GJMonthOfYearDateTimeField is created for the given EthiopicChronology object
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(arg0);
      
      // Then: The leapAmount of the 100000000000000000L date is compared to 1, which is the expected value.
      int leapAmount = gJMonthOfYearDateTimeField.getLeapAmount(100000000000000000L);
      assertEquals(1, leapAmount);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsLeap() throws Throwable  {
      // Given: A GJMonthOfYearDateTimeField instance with a UTC chronology
      IslamicChronology arg0 = IslamicChronology.getInstanceUTC();
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(arg0);
      
      // When: The isLeap method is called with the year 15789400000L (a non-leap year)
      boolean leap = gJMonthOfYearDateTimeField.isLeap(15789400000L);
      
      // Then: The method should return false, indicating that the year is not a leap year
      assertFalse(leap);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLeapAmountReturningZero() throws Throwable  {
      // Create an instance of the EthiopicChronology class using the UTC time zone.
      EthiopicChronology ethiopicChronology = EthiopicChronology.getInstanceUTC();
      
      // Create a new GJMonthOfYearDateTimeField object with the EthiopicChronology.
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(ethiopicChronology);
      
      // Use the getLeapAmount method to retrieve the leap amount for a given date.
      int leapAmount = gJMonthOfYearDateTimeField.getLeapAmount(1000000000000000L);
      
      // Assert that the leap amount is equal to 0.
      assertEquals(0, leapAmount);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetReturningPositive() throws Throwable  {
      // Arrange
      EthiopicChronology ethiopicChronology = EthiopicChronology.getInstance();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(ethiopicChronology, 1);
      long startValue = (long) 1;
      
      // Act
      long setValue = basicMonthOfYearDateTimeField.set(startValue, 13);
      
      // Assert
      assertEquals(21772800001L, setValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDifferenceAsLongReturningZero() throws Throwable  {
      // Arrange
      EthiopicChronology ethiopicChronology = EthiopicChronology.getInstanceUTC();
      BasicMonthOfYearDateTimeField monthOfYearField = new BasicMonthOfYearDateTimeField(ethiopicChronology, 1);
      
      // Act
      long differenceAsLong = monthOfYearField.getDifferenceAsLong(604800149L, 604800149L);
      
      // Assert
      assertEquals(0L, differenceAsLong);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDifferenceAsLongReturningNegative() throws Throwable  {
      // Given a BasicMonthOfYearDateTimeField instance for the UTC calendar system
      EthiopicChronology ethiopicChronology = EthiopicChronology.getInstanceUTC();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(ethiopicChronology, 1);
      
      // When we get the difference between two dates in months
      long differenceAsLong = basicMonthOfYearDateTimeField.getDifferenceAsLong(-474L, 21786400000L);
      
      // Then the result should be a negative number indicating the number of months between the dates
      assertEquals((-8L), differenceAsLong);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDifferenceAsLongReturningPositive() throws Throwable  {
      // rollbacked to evosuite
      EthiopicChronology arg0 = EthiopicChronology.getInstance();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(arg0, 1);
      long differenceAsLong = basicMonthOfYearDateTimeField.getDifferenceAsLong(100000000000000000L, 1);
      assertEquals(41194514L, differenceAsLong);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesBasicMonthOfYearDateTimeFieldAndCallsAddTaking2Longs() throws Throwable  {
      // No Comments were added
      EthiopicChronology arg0 = EthiopicChronology.getInstance();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(arg0, 1);
      long add = basicMonthOfYearDateTimeField.add(2592000001L, 2592000001L);
      assertEquals(6292099944489600001L, add);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTaking2LongsWithNegative() throws Throwable  {
      // Create an instance of the EthiopicChronology class
      EthiopicChronology ethiopicChronology = EthiopicChronology.getInstance();
      
      // Create a new instance of the BasicMonthOfYearDateTimeField class with the given chronology
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(ethiopicChronology, 1);
      
      try {
      // Try to add a value that is too large to the field
      basicMonthOfYearDateTimeField.add(-1827L, 10367997671L);
      
      // Expect an IllegalArgumentException to be thrown
      fail("Expected exception not thrown");
      } catch (IllegalArgumentException e) {
      // Verify that the expected exception is thrown
      assertEquals(e.getMessage(), "Magnitude of add amount is too large: 10367997671");}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test() throws Throwable  {
      // Given a specific Ethiopic Chronology instance (UTC)
      EthiopicChronology instanceUTC = EthiopicChronology.getInstanceUTC();
      
      // And a Months object representing the "Three" month of the year (THREE)
      Months arg0 = Months.THREE;
      
      // When trying to add a ReadablePeriod (i.e. a number of months) to a specific date
      // with a large magnitude (i.e. 1900798196L), the method throws an IllegalArgumentException
      try {
      instanceUTC.add((ReadablePeriod) arg0, 1900798196L, (-2146319068));
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // The magnitude of the add amount is too large
      verifyException("org.joda.time.chrono.BasicMonthOfYearDateTimeField", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTaking2LongsThrowsIllegalArgumentException() throws Throwable  {
      // rollbacked to evosuite
      EthiopicChronology arg0 = EthiopicChronology.getInstance();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(arg0, 1);
      // Undeclared exception!
      try { 
        basicMonthOfYearDateTimeField.add((long) 1, (-9223372036854775808L));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Magnitude of add amount is too large: -9223372036854775808
         //
         verifyException("org.joda.time.chrono.BasicMonthOfYearDateTimeField", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTaking2Longs() throws Throwable  {
      // Test that adding a month to January 1st returns March 1st
      EthiopicChronology arg0 = EthiopicChronology.getInstance();
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(arg0);
      long add = gJMonthOfYearDateTimeField.add(1000000L, 2629800000L); // Add one month to January 1st
      assertEquals(6383859729178600000L, add); // Check that the result is March 1st
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTaking1And1ReturningPositive() throws Throwable  {
      // rollbacked to evosuite
      EthiopicChronology arg0 = EthiopicChronology.getInstanceUTC();
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(arg0);
      long add = gJMonthOfYearDateTimeField.add(498L, 2146135572);
      assertEquals(5209760609712000498L, add);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTaking1And1() throws Throwable  {
      // Given a JulianChronology instance, and a GJMonthOfYearDateTimeField object
      JulianChronology arg0 = JulianChronology.getInstanceUTC();
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(arg0);
      
      // When we add the value -1625L to the field with a start date of -1439
      long add = gJMonthOfYearDateTimeField.add((-1625L), (-1439));
      
      // Then we expect the result to be -3784233601625L
      assertEquals((-3784233601625L), add);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTaking2LongsReturningNegative() throws Throwable  {
      // Given
      EthiopicChronology chronology = EthiopicChronology.getInstance();
      GJMonthOfYearDateTimeField field = new GJMonthOfYearDateTimeField(chronology);
      
      // When
      long add = field.add((long) 1, (-2988L));
      
      // Then
      assertEquals((-7253020799999L), add);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTaking2LongsReturningZero() throws Throwable  {
      // Given a date and time in Ethiopic chronology
      EthiopicChronology ethiopicChronology = EthiopicChronology.getInstance();
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(ethiopicChronology);
      
      // When we add a month to the date and time
      long addedMonths = gJMonthOfYearDateTimeField.add((long) 0, (long) 0);
      
      // Then the result should be the same as the original date and time
      assertEquals(0L, addedMonths);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRangeDurationField() throws Throwable  {
      // rollbacked to evosuite
      EthiopicChronology arg0 = EthiopicChronology.getInstance();
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(arg0);
      DurationField rangeDurationField = gJMonthOfYearDateTimeField.getRangeDurationField();
      assertTrue(rangeDurationField.isSupported());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddWrapFieldReturningZero() throws Throwable  {
      // Given an instance of the IslamicChronology class
      IslamicChronology islamicChronology = IslamicChronology.getInstanceUTC();
      
      // And a GJMonthOfYearDateTimeField object
      GJMonthOfYearDateTimeField gjMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(islamicChronology);
      
      // When the addWrapField method is called with 0 as the first argument and 0 as the second argument
      long addWrapField = gjMonthOfYearDateTimeField.addWrapField(0L, 0);
      
      // Then the method should return 0
      assertEquals(0L, addWrapField);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsLenient() throws Throwable  {
      // Set up the test environment
      EthiopicChronology ethiopicChronology = EthiopicChronology.getInstance();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(ethiopicChronology, 1);
      
      // Test the isLenient method with a few specific examples
      assertFalse(basicMonthOfYearDateTimeField.isLenient());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTaking4Arguments() throws Throwable  {
      // No Comments were added
      GregorianChronology arg1 = GregorianChronology.getInstance();
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(arg1);
      MonthDay arg0 = new MonthDay((long) 6, (Chronology) arg1);
      int[] arg2 = new int[4];
      int[] add = gJMonthOfYearDateTimeField.add((ReadablePartial) arg0, 0, arg2, 717336);
      assertArrayEquals(new int[] {1, 1, 0, 0}, add);
      assertEquals(12, gJMonthOfYearDateTimeField.getMaximumValue());
      assertEquals(1, gJMonthOfYearDateTimeField.getMinimumValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetReturningPositive() throws Throwable  {
      // CopticChronology is an instance of a chronology class that represents a specific calendar system.
      CopticChronology copticChronology = CopticChronology.getInstance();
      
      // GJMonthOfYearDateTimeField is a field in the CopticChronology class that represents the month-of-year component of a date.
      GJMonthOfYearDateTimeField gJMonthOfYearDateTimeField = new GJMonthOfYearDateTimeField(copticChronology);
      
      // get() method returns the value of the specified field for the given DateTime.
      int get = gJMonthOfYearDateTimeField.get(13);
      
      // assertEquals() is a JUnit method that checks whether two values are equal.
      assertEquals(4, get);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLeapDurationField() throws Throwable  {
      // Create an instance of the EthiopicChronology class.
      EthiopicChronology chrono = EthiopicChronology.getInstance();
      
      // Get a GJMonthOfYearDateTimeField object from the EthiopicChronology instance.
      GJMonthOfYearDateTimeField monthField = new GJMonthOfYearDateTimeField(chrono);
      
      // Get the leap duration field of the GJMonthOfYearDateTimeField object.
      DurationField leapDurationField = monthField.getLeapDurationField();
      
      // Assert that the leap duration field is supported by the EthiopicChronology instance.
      assertTrue(leapDurationField.isSupported());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemainderReturningZero() throws Throwable  {
      // Given the EthiopicChronology object and a BasicMonthOfYearDateTimeField instance with the first month of the year as 1.
      EthiopicChronology ethiopicChronology = EthiopicChronology.getInstance();
      BasicMonthOfYearDateTimeField basicMonthOfYearDateTimeField = new BasicMonthOfYearDateTimeField(ethiopicChronology, 1);
      
      // When the remainder of the specified long value is calculated using the BasicMonthOfYearDateTimeField instance.
      long remainder = basicMonthOfYearDateTimeField.remainder(-1900800000L);
      
      // Then the result should be equal to 0, as the input long value is a valid date in the Ethiopic calendar and the first month of the year has only 30 days.
      assertEquals(0L, remainder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundFloorReturningZero() throws Throwable  {
      // Given a GregorianChronology object and a GJMonthOfYearDateTimeField
      GregorianChronology chronology = GregorianChronology.getInstance();
      GJMonthOfYearDateTimeField monthField = new GJMonthOfYearDateTimeField(chronology);
      
      // When we call roundFloor with the argument 604800004L
      long roundedValue = monthField.roundFloor(604800004L);
      
      // Then the return value should be 0L
      assertEquals(0L, roundedValue);
  }
}
