/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 06:54:15 GMT 2024
 */

package org.joda.time.format;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.CharArrayWriter;
import java.io.Writer;
import java.util.LinkedList;
import java.util.Locale;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFileWriter;
import org.joda.time.Days;
import org.joda.time.Hours;
import org.joda.time.LocalTime;
import org.joda.time.Minutes;
import org.joda.time.Months;
import org.joda.time.MutablePeriod;
import org.joda.time.Period;
import org.joda.time.PeriodType;
import org.joda.time.ReadWritablePeriod;
import org.joda.time.ReadablePeriod;
import org.joda.time.Weeks;
import org.joda.time.Years;
import org.joda.time.format.PeriodFormatter;
import org.joda.time.format.PeriodFormatterBuilder;
import org.joda.time.format.PeriodParser;
import org.joda.time.format.PeriodPrinter;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class PeriodFormatterBuilder_ESTest extends PeriodFormatterBuilder_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking1And1AndPrintToTaking1And1AndCreatesSimpleAffixTakingString() throws Throwable  {
      // Given
      PeriodFormatterBuilder.SimpleAffix affix = new PeriodFormatterBuilder.SimpleAffix("above the supported maximum of ");
      StringBuffer buffer = new StringBuffer(23118750);
      
      // When
      affix.printTo(buffer, 23118750);
      
      // Then
      assertEquals("above the supported maximum of ", buffer.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking1And1() throws Throwable  {
      // Given
      PeriodFormatterBuilder.SimpleAffix simpleAffix = new PeriodFormatterBuilder.SimpleAffix("rSTr45?%c8C4:03P)|");
      
      // When
      try {
      simpleAffix.printTo((Writer) null, (-1138));
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      // Then
      verifyException("org.joda.time.format.PeriodFormatterBuilder$SimpleAffix", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSimpleAffixTakingStringAndCallsCalculatePrintedLengthTakingInt() throws Throwable  {
      // Given: A PeriodFormatterBuilder.SimpleAffix object with an empty string as its prefix and suffix
      PeriodFormatterBuilder.SimpleAffix simpleAffix = new PeriodFormatterBuilder.SimpleAffix("");
      
      // When: The calculatePrintedLength method is called with the argument 469
      int printedLength = simpleAffix.calculatePrintedLength(469);
      
      // Then: The length of the printed string should be 0
      assertEquals(0, printedLength);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseIntoAndParseInto() throws Throwable  {
      // Given a PeriodFormatterBuilder.Literal object
      PeriodFormatterBuilder.Literal periodFormatterBuilder_Literal = PeriodFormatterBuilder.Literal.EMPTY;
      
      // And a Locale object with the US locale
      Locale arg3 = Locale.US;
      
      // When we parse a string into a MutablePeriod object
      MutablePeriod arg0 = new MutablePeriod();
      int parseInto = periodFormatterBuilder_Literal.parseInto(arg0, "ReadableInstant objects must not be null", (-3579), arg3);
      
      // Then the result should be the expected number of days parsed into the MutablePeriod object
      assertEquals(3578, parseInto);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCalculatePrintedLengthTaking2ArgumentsAndCalculatePrintedLengthTaking2Arguments() throws Throwable  {
      // Given: A PeriodFormatterBuilder.Literal with an empty string
      PeriodFormatterBuilder.Literal periodFormatterBuilder_Literal = PeriodFormatterBuilder.Literal.EMPTY;
      
      // And: A Weeks object with value TWO
      Weeks arg0 = Weeks.TWO;
      
      // When: Calculating the printed length of the string using the literal
      int calculatePrintedLength = periodFormatterBuilder_Literal.calculatePrintedLength(arg0, (Locale) null);
      
      // Then: The calculated printed length should be zero
      assertEquals(0, calculatePrintedLength);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11And1AndCreatesFieldFormatterTaking8ArgumentsAndCreatesPluralAffixTaking2Arguments() throws Throwable  {
      // rollbacked to evosuite
      PeriodFormatterBuilder.PluralAffix arg7 = new PeriodFormatterBuilder.PluralAffix("", "");
      PeriodFormatterBuilder.FieldFormatter[] arg5 = new PeriodFormatterBuilder.FieldFormatter[0];
      PeriodFormatterBuilder.FieldFormatter periodFormatterBuilder_FieldFormatter = new PeriodFormatterBuilder.FieldFormatter(61, 0, (-86), true, (-86), arg5, arg7, arg7);
      Locale arg2 = Locale.KOREA;
      // Undeclared exception!
      try { 
        periodFormatterBuilder_FieldFormatter.printTo((Writer) null, (ReadablePeriod) null, arg2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.PeriodFormatterBuilder$FieldFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsZero() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder.SimpleAffix arg6 = new PeriodFormatterBuilder.SimpleAffix("jQ4n\"Hg3%");
      PeriodFormatterBuilder.FieldFormatter periodFormatterBuilder_FieldFormatter = new PeriodFormatterBuilder.FieldFormatter(85, 85, 85, false, 85, (PeriodFormatterBuilder.FieldFormatter[]) null, arg6, (PeriodFormatterBuilder.PeriodFieldAffix) null);
      MutablePeriod arg0 = new MutablePeriod(85, (-23), 85, 85);
      boolean zero = periodFormatterBuilder_FieldFormatter.isZero(arg0);
      assertFalse(zero);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFieldFormatterTaking2Arguments() throws Throwable  {
      // Given
      PeriodFormatterBuilder.SimpleAffix arg7 = new PeriodFormatterBuilder.SimpleAffix("0:nt>pm ");
      PeriodFormatterBuilder.FieldFormatter arg0 = new PeriodFormatterBuilder.FieldFormatter((-2963), 4, (-2963), true, 4, (PeriodFormatterBuilder.FieldFormatter[]) null, arg7, arg7);
      PeriodFormatterBuilder.PluralAffix arg1 = new PeriodFormatterBuilder.PluralAffix("S/n={", "S/n={");
      
      // When
      PeriodFormatterBuilder.FieldFormatter periodFormatterBuilder_FieldFormatter = new PeriodFormatterBuilder.FieldFormatter(arg0, arg1);
      
      // Then
      assertFalse(periodFormatterBuilder_FieldFormatter.equals((Object)arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPeriodFormatterBuilderTakingNoArgumentsAndCallsCalculatePrintedLengthTaking2Arguments() throws Throwable  {
      // Given
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodPrinter printer = periodFormatterBuilder.toPrinter();
      Months arg0 = Months.NINE;
      Locale arg1 = Locale.KOREAN;
      
      // When and Then
      try {
      printer.calculatePrintedLength(arg0, arg1);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      assertEquals("Months should be within 0-11 range.", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToFormatterReturningPeriodFormatterWhereIsPrinterIsFalse() throws Throwable  {
      // Given a PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When we append a Literal to it
      PeriodFormatterBuilder.Literal arg1 = PeriodFormatterBuilder.Literal.EMPTY;
      periodFormatterBuilder.append((PeriodPrinter) null, (PeriodParser) arg1);
      
      // Then the formatter should be a parser
      PeriodFormatter formatter = periodFormatterBuilder.toFormatter();
      assertTrue(formatter.isParser());
      
      // And not a printer
      assertFalse(formatter.isPrinter());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSuffixTaking2Arguments() throws Throwable  {
      // Given a PeriodFormatterBuilder object, we want to append the seconds with milliseconds suffix
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When we call the appendSecondsWithMillis method on the PeriodFormatterBuilder object
      periodFormatterBuilder.appendSecondsWithMillis();
      
      // Then the PeriodFormatterBuilder object should be returned, indicating that the operation was successful
      assertSame(periodFormatterBuilder, periodFormatterBuilder);
      
      // Given a PeriodFormatterBuilder object, we want to append the suffix "Offset is too large" if the offset is too large
      PeriodFormatterBuilder appendSuffix = periodFormatterBuilder.appendSuffix("", "Offset is too large");
      
      // Then the PeriodFormatterBuilder object should be returned, indicating that the operation was successful
      assertSame(appendSuffix, periodFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendMinutes() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder appendMinutes = periodFormatterBuilder.appendMinutes();
      PeriodFormatterBuilder.Composite arg4 = (PeriodFormatterBuilder.Composite)appendMinutes.toPrinter();
      PeriodFormatterBuilder.Separator periodFormatterBuilder_Separator = new PeriodFormatterBuilder.Separator("Y\";]|x&IOQ66", "org.joda.time.format.PeriodFormatterBuilder$Literal", (String[]) null, arg4, arg4, true, false);
      StringBuffer arg0 = new StringBuffer("f");
      Period arg1 = Period.seconds((-1));
      Locale arg2 = Locale.PRC;
      // Undeclared exception!
      try { 
        periodFormatterBuilder_Separator.printTo(arg0, (ReadablePeriod) arg1, arg2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.PeriodFormatterBuilder$Separator", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFieldValue0() throws Throwable  {
      // Given
      PeriodFormatterBuilder.PluralAffix pluralAffix = new PeriodFormatterBuilder.PluralAffix("pb", "Mp{z");
      PeriodFormatterBuilder.FieldFormatter[] fieldFormatters = new PeriodFormatterBuilder.FieldFormatter[0];
      PeriodFormatterBuilder.FieldFormatter fieldFormatter = new PeriodFormatterBuilder.FieldFormatter(1549, 1549, 1549, true, 0, fieldFormatters, pluralAffix, pluralAffix);
      Years years = Years.THREE;
      
      // When
      long fieldValue = fieldFormatter.getFieldValue(years);
      
      // Then
      assertEquals(3L, fieldValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToFormatter() throws Throwable  {
      // Given
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When
      periodFormatterBuilder.appendSeconds();
      PeriodFormatterBuilder.Composite arg1 = (PeriodFormatterBuilder.Composite) periodFormatterBuilder.toPrinter();
      PeriodFormatterBuilder append = periodFormatterBuilder.append((PeriodPrinter) arg1, (PeriodParser) arg1);
      PeriodFormatter formatter = append.toFormatter();
      
      // Then
      assertTrue(formatter.isParser());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesCompositeTakingList() throws Throwable  {
      // Given a PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When appending a Composite object to the builder
      LinkedList<Object> arg0 = new LinkedList<>();
      PeriodFormatterBuilder.Composite arg1 = new PeriodFormatterBuilder.Composite(arg0);
      periodFormatterBuilder.append((PeriodPrinter) arg1, (PeriodParser) arg1);
      
      // Then the builder should have a formatter that is a parser
      PeriodFormatter formatter = periodFormatterBuilder.toFormatter();
      assertTrue(formatter.isParser());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSeparatorTaking7ArgumentsAndCallsPrintToTaking11And1() throws Throwable  {
      // Given
      PeriodFormatterBuilder.Literal arg4 = PeriodFormatterBuilder.Literal.EMPTY;
      PeriodFormatterBuilder.Separator periodFormatterBuilder_Separator = new PeriodFormatterBuilder.Separator(")}b@Kqm", ")}b@Kqm", (String[]) null, arg4, arg4, false, false);
      StringBuffer arg0 = new StringBuffer("#Wm");
      
      // When
      try {
      periodFormatterBuilder_Separator.printTo(arg0, (ReadablePeriod) null, (Locale) null);
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Then
      assertEquals("Expected NullPointerException when trying to print a separator with a null ReadablePeriod", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11And1AndPrintToTaking11And1() throws Throwable  {
      // Setup
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder appendSecondsWithMillis = periodFormatterBuilder.appendSecondsWithMillis();
      PeriodFormatterBuilder appendSeparator = appendSecondsWithMillis.appendSeparator("", "");
      PeriodPrinter printer = appendSeparator.toPrinter();
      
      // Run the test
      StringBuffer arg0 = new StringBuffer();
      Period arg1 = Period.seconds(934);
      Locale arg2 = Locale.PRC;
      printer.printTo(arg0, (ReadablePeriod) arg1, arg2);
      
      // Verify the results
      assertEquals("934.000", arg0.toString());
      assertEquals(7, arg0.length());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFinish() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder appendSecondsWithMillis = periodFormatterBuilder.appendSecondsWithMillis();
      PeriodFormatterBuilder.Composite arg1 = (PeriodFormatterBuilder.Composite)appendSecondsWithMillis.toPrinter();
      Period arg0 = Period.ZERO;
      String[] arg2 = new String[0];
      PeriodFormatterBuilder.Separator periodFormatterBuilder_Separator = new PeriodFormatterBuilder.Separator("l,0i!::1o6>p", "No formatter supplied", arg2, arg1, arg1, true, false);
      periodFormatterBuilder_Separator.finish(arg1, arg1);
      int calculatePrintedLength = periodFormatterBuilder_Separator.calculatePrintedLength(arg0, (Locale) null);
      assertEquals(22, calculatePrintedLength);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test0() throws Throwable  {
      // Try to parse the input string with an invalid format
      try {
      Hours.parseHours("10:30 AM");
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the thrown exception is correct
      verifyException("org.joda.time.format.PeriodFormatter", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetFieldValue() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder.PluralAffix arg7 = new PeriodFormatterBuilder.PluralAffix("", "kqmq>X}7UB4:phGN`H");
      MutablePeriod arg0 = new MutablePeriod(0, 0, 55, 55);
      PeriodFormatterBuilder.FieldFormatter[] arg5 = new PeriodFormatterBuilder.FieldFormatter[0];
      PeriodFormatterBuilder.FieldFormatter periodFormatterBuilder_FieldFormatter = new PeriodFormatterBuilder.FieldFormatter(0, 0, (-2168), true, 0, arg5, arg7, arg7);
      periodFormatterBuilder_FieldFormatter.setFieldValue(arg0, 0, (-1));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToPrinter() throws Throwable  {
      // rollbacked to evosuite
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder appendSecondsWithMillis = periodFormatterBuilder.appendSecondsWithMillis();
      PeriodFormatterBuilder.Composite arg1 = (PeriodFormatterBuilder.Composite)appendSecondsWithMillis.toPrinter();
      PeriodFormatter periodFormatter = new PeriodFormatter(arg1, arg1);
      PeriodType arg0 = PeriodType.millis();
      PeriodFormatter withParseType = periodFormatter.withParseType(arg0);
      // Undeclared exception!
      try { 
        withParseType.parsePeriod("23 hours, 59 minutes, and 59 seconds");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Period does not support field 'seconds'
         //
         verifyException("org.joda.time.base.BasePeriod", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendDays() throws Throwable  {
      // Given a period formatter builder with print zero rarely first enabled
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder().printZeroRarelyFirst();
      
      // When appending seconds with optional millis and days to the formatter builder
      periodFormatterBuilder.appendSecondsWithOptionalMillis().appendDays();
      
      // Then the resulting printer should print 0 for zero periods
      PeriodPrinter printer = periodFormatterBuilder.toPrinter();
      StringBuffer arg0 = new StringBuffer();
      Locale arg2 = Locale.CANADA_FRENCH;
      Period arg1 = Period.ZERO;
      printer.printTo(arg0, (ReadablePeriod) arg1, arg2);
      assertEquals(1, arg0.length());
      assertEquals("0", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11And1AndPrintZeroRarelyFirst0() throws Throwable  {
      // Given
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder printZeroRarelyFirst = periodFormatterBuilder.printZeroRarelyFirst();
      PeriodFormatterBuilder appendSecondsWithOptionalMillis = printZeroRarelyFirst.appendSecondsWithOptionalMillis();
      
      // When
      PeriodPrinter printer = periodFormatterBuilder.toPrinter();
      StringBuffer output = new StringBuffer();
      Locale locale = Locale.CHINESE;
      Period period = new Period(9223372036854775807L, 9223372036854775807L);
      printer.printTo(output, period, locale);
      
      // Then
      assertEquals(1, output.length());
      assertEquals("0", output.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11And1() throws Throwable  {
      // Given a PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When appending seconds with optional millis to the builder
      PeriodFormatterBuilder appendSecondsWithOptionalMillis = periodFormatterBuilder.appendSecondsWithOptionalMillis();
      appendSecondsWithOptionalMillis.appendSecondsWithOptionalMillis();
      
      // Then the resulting PeriodPrinter should print 0 seconds with optional millis
      PeriodPrinter printer = periodFormatterBuilder.toPrinter();
      StringBuffer arg0 = new StringBuffer();
      Locale arg2 = Locale.US;
      Period arg1 = Period.ZERO;
      printer.printTo(arg0, (ReadablePeriod) arg1, arg2);
      
      // Assert that the printed string is "0" and has a length of 1
      assertEquals("0", arg0.toString());
      assertEquals(1, arg0.length());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesCompositeAffixTaking2ArgumentsAndCallsGetFieldValue() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder.CompositeAffix arg6 = new PeriodFormatterBuilder.CompositeAffix((PeriodFormatterBuilder.PeriodFieldAffix) null, (PeriodFormatterBuilder.PeriodFieldAffix) null);
      PeriodFormatterBuilder.FieldFormatter periodFormatterBuilder_FieldFormatter = new PeriodFormatterBuilder.FieldFormatter((-232), 1232, 612, false, 2, (PeriodFormatterBuilder.FieldFormatter[]) null, arg6, (PeriodFormatterBuilder.PeriodFieldAffix) null);
      Period arg0 = new Period((long) 2);
      long fieldValue = periodFormatterBuilder_FieldFormatter.getFieldValue(arg0);
      assertEquals(0L, fieldValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFieldValue1() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder.PluralAffix arg7 = new PeriodFormatterBuilder.PluralAffix("pb", "Mp{z");
      PeriodFormatterBuilder.FieldFormatter[] arg5 = new PeriodFormatterBuilder.FieldFormatter[0];
      PeriodFormatterBuilder.FieldFormatter periodFormatterBuilder_FieldFormatter = new PeriodFormatterBuilder.FieldFormatter(1549, 1549, 1549, true, 1549, arg5, arg7, arg7);
      Years arg0 = Years.THREE;
      long fieldValue = periodFormatterBuilder_FieldFormatter.getFieldValue(arg0);
      assertEquals(9223372036854775807L, fieldValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSeparatorTaking7ArgumentsAndCallsParseInto() throws Throwable  {
      // Arrange
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      periodFormatterBuilder.appendSecondsWithMillis();
      PeriodFormatterBuilder.Composite arg4 = (PeriodFormatterBuilder.Composite)periodFormatterBuilder.toPrinter();
      String[] arg2 = new String[1];
      arg2[0] = "9p4-S;HwJtm'{ZLs";
      PeriodFormatterBuilder.Separator periodFormatterBuilder_Separator = new PeriodFormatterBuilder.Separator("9p4-S;HwJtm'{ZLs", "9p4-S;HwJtm'{ZLs", arg2, arg4, arg4, false, false);
      MutablePeriod arg0 = new MutablePeriod();
      Locale arg3 = Locale.ITALIAN;
      
      // Act
      try {
      periodFormatterBuilder_Separator.parseInto(arg0, "Cutover too early. Must be on or after 0001-01-01.", 47, arg3);
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Verify exception
      verifyException("org.joda.time.format.PeriodFormatterBuilder$Separator", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseIntoAndParseIntoAndToPrinter() throws Throwable  {
      // Create a period formatter builder and append seconds with milliseconds.
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder appendSecondsWithMillis = periodFormatterBuilder.appendSecondsWithMillis();
      
      // Convert the appended period formatter to a printer.
      PeriodFormatterBuilder.Composite printer = (PeriodFormatterBuilder.Composite)appendSecondsWithMillis.toPrinter();
      
      // Create a mutable period object and set it to the maximum value for minutes.
      MutablePeriod arg0 = Minutes.MAX_VALUE.toMutablePeriod();
      
      // Parse the string "h]+D_x-'SM7" into the mutable period object using the printer.
      Locale arg3 = Locale.ITALIAN;
      int parseInto = printer.parseInto(arg0, "h]+D_x-'SM7", 6, arg3);
      
      // Assert that the parsed value is equal to -7.
      assertEquals((-7), parseInto);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseInto0() throws Throwable  {
      // No Comments were added
      Locale arg3 = Locale.KOREA;
      PeriodFormatterBuilder.SimpleAffix arg7 = new PeriodFormatterBuilder.SimpleAffix("");
      PeriodFormatterBuilder.FieldFormatter periodFormatterBuilder_FieldFormatter = new PeriodFormatterBuilder.FieldFormatter((-1446), (-4539), (-1550), false, 4039, (PeriodFormatterBuilder.FieldFormatter[]) null, arg7, arg7);
      MutablePeriod arg0 = new MutablePeriod((-2021559599), 78, (-4539), 26);
      int parseInto = periodFormatterBuilder_FieldFormatter.parseInto(arg0, "=?/1PEJkQp3|Q:", 13, arg3);
      assertEquals((-14), parseInto);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test1() throws Throwable  {
      // Given a string representation of hours in the format "p", where p is an integer
      // When parsing the string using the Hours.parseHours() method
      // Then the returned Hours object should have a value of 0 hours
      Hours parseHours = Hours.parseHours("p");
      assertEquals(0, parseHours.getHours());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseInto1() throws Throwable  {
      // Create a new PeriodFormatterBuilder.SimpleAffix instance with the given string.
      PeriodFormatterBuilder.SimpleAffix simpleAffix = new PeriodFormatterBuilder.SimpleAffix("0:nt>pm ");
      
      // Create a new PeriodFormatterBuilder.FieldFormatter instance using the given arguments.
      PeriodFormatterBuilder.FieldFormatter fieldFormatter = new PeriodFormatterBuilder.FieldFormatter((-2963), 4, (-2963), true, 4, null, simpleAffix, simpleAffix);
      
      // Create a new Locale instance with the given locale string.
      Locale locale = Locale.TAIWAN;
      
      // Parse the given input string using the given field formatter and locale.
      int parseInto = fieldFormatter.parseInto(null, "org.joda.time.format.PeriodFormatterBuilder$PluralAffix", 4, locale);
      
      // Assert that the result is equal to the expected value.
      assertEquals((-5), parseInto);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11And1AndAppendSecondsWithOptionalMillisAndCreatesSeparatorTaking7Arguments() throws Throwable  {
      // Create a new instance of the PeriodFormatterBuilder class
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // Append the number of seconds with optional milliseconds to the formatter
      periodFormatterBuilder.appendSecondsWithOptionalMillis();
      
      // Use the toPrinter method to create a composite printer
      PeriodFormatterBuilder.Composite arg4 = (PeriodFormatterBuilder.Composite) periodFormatterBuilder.toPrinter();
      
      // Create an array of strings with one element: "0"
      String[] arg2 = new String[1];
      arg2[0] = "0";
      
      // Create a new instance of the PeriodFormatterBuilder.Separator class
      PeriodFormatterBuilder.Separator periodFormatterBuilder_Separator = new PeriodFormatterBuilder.Separator("0", "|j3w9WwF", arg2, arg4, arg4, false, false);
      
      // Create a new instance of the MutablePeriod class with the same values as the argument1 parameter
      MutablePeriod arg1 = new MutablePeriod((-1183), (-1183), (-1183), Integer.MAX_VALUE, (-1183), (-1183), Integer.MAX_VALUE, Integer.MAX_VALUE);
      
      // Create a new instance of the MockFileWriter class with the string "0" as its argument
      MockFileWriter arg0 = new MockFileWriter("0");
      
      // Test that the printTo method throws a NullPointerException when called with a null writer
      try {
      periodFormatterBuilder_Separator.printTo((Writer) arg0, (ReadablePeriod) arg1, (Locale) null);
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Verify that the exception is of the expected type and has no message (getMessage() returned null)
      verifyException("org.joda.time.format.PeriodFormatterBuilder$Separator", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11And1AndAppendSecondsWithMillisAndCreatesSeparatorTaking7Arguments() throws Throwable  {
      // Given
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder appendSecondsWithMillis = periodFormatterBuilder.appendSecondsWithMillis();
      PeriodFormatterBuilder.Composite arg4 = (PeriodFormatterBuilder.Composite) appendSecondsWithMillis.toPrinter();
      PeriodFormatterBuilder.Separator periodFormatterBuilder_Separator = new PeriodFormatterBuilder.Separator("%{bG$3}", "%{bG$3}", (String[]) null, arg4, arg4, true, true);
      StringBuffer arg0 = new StringBuffer();
      Period arg1 = new Period(50, 50, (-1), 653);
      Locale arg2 = Locale.FRENCH;
      
      // When
      periodFormatterBuilder_Separator.printTo(arg0, (ReadablePeriod) arg1, arg2);
      
      // Then
      fail("Expecting exception: NullPointerException");
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11And1AndPrintToTaking11And1AndCreatesFieldFormatterTaking8Arguments() throws Throwable  {
      // rollbacked to evosuite
      PeriodFormatterBuilder.PluralAffix arg7 = new PeriodFormatterBuilder.PluralAffix("", "kqmq>X}7UB4:phGN`H");
      PeriodFormatterBuilder.FieldFormatter periodFormatterBuilder_FieldFormatter = new PeriodFormatterBuilder.FieldFormatter(8, 962, 8, true, 8, (PeriodFormatterBuilder.FieldFormatter[]) null, (PeriodFormatterBuilder.PeriodFieldAffix) null, arg7);
      MutablePeriod arg1 = new MutablePeriod(8, 8, 8, (-613));
      Locale arg2 = Locale.KOREA;
      StringBuffer arg0 = new StringBuffer(962);
      periodFormatterBuilder_FieldFormatter.printTo(arg0, (ReadablePeriod) arg1, arg2);
      assertEquals(30, arg0.length());
      assertEquals("00000007.387kqmq>X}7UB4:phGN`H", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test2() throws Throwable  {
      // Given a negative number of seconds
      Period seconds = Period.seconds((-1));
      
      // When converting to a String representation
      String string = seconds.toString();
      
      // Then the resulting String should be "PT-1S"
      assertEquals("PT-1S", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCountFieldsToPrint() throws Throwable  {
      // Given
      PeriodFormatterBuilder.SimpleAffix mpPrefix = new PeriodFormatterBuilder.SimpleAffix("Mp{z");
      PeriodFormatterBuilder.CompositeAffix compositeAffix = new PeriodFormatterBuilder.CompositeAffix(mpPrefix, mpPrefix);
      PeriodFormatterBuilder.FieldFormatter fieldFormatter = new PeriodFormatterBuilder.FieldFormatter(43, -1, 532, true, 532, null, compositeAffix, mpPrefix);
      Days days = Days.FOUR;
      Locale locale = Locale.US;
      
      // When
      int countFieldsToPrint = fieldFormatter.countFieldsToPrint(days, -85, locale);
      
      // Then
      assertEquals(0, countFieldsToPrint);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPluralAffixTaking2ArgumentsAndCallsScan0() throws Throwable  {
      // Given
      PeriodFormatterBuilder.PluralAffix pluralAffix = new PeriodFormatterBuilder.PluralAffix("org.joda.time.format.DateTimeParserBucket", "ConverterManager.alterPeriodConverters");
      
      // When
      PeriodFormatterBuilder.CompositeAffix compositeAffix = new PeriodFormatterBuilder.CompositeAffix(pluralAffix, pluralAffix);
      int scan = compositeAffix.scan("ConverterManager.alterPeriodConverters", (-2820));
      
      // Then
      assertEquals(0, scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPluralAffixTaking2ArgumentsAndCallsScan1() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder.PluralAffix arg1 = new PeriodFormatterBuilder.PluralAffix("Pac[ific/Apia", "B=bHT(Hm0~");
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(arg1, arg1);
      int scan = periodFormatterBuilder_CompositeAffix.scan("Pac[ific/Apia", 84);
      assertEquals((-85), scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPluralAffixTaking2ArgumentsAndCallsScan2() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder.PluralAffix arg1 = new PeriodFormatterBuilder.PluralAffix("[xV)dSO%Ya!|q\"K/Ucp", "[xV)dSO%Ya!|q\"K/Ucp");
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(arg1, arg1);
      int scan = periodFormatterBuilder_CompositeAffix.scan("[xV)dSO%Ya!|q\"K/Ucp", (-3717));
      assertEquals(0, scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPluralAffixTaking2ArgumentsAndCallsParse() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder.PluralAffix arg1 = new PeriodFormatterBuilder.PluralAffix("", "7K%P\"9K)0)");
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(arg1, arg1);
      int parse = periodFormatterBuilder_CompositeAffix.parse("7K%P\"9K)0)", 0);
      assertEquals(10, parse);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPluralAffixTaking2ArgumentsAndCallsPrintToTaking1And10() throws Throwable  {
      // Given a PeriodFormatterBuilder.PluralAffix object with the singular and plural forms of a time unit
      PeriodFormatterBuilder.PluralAffix pluralAffix = new PeriodFormatterBuilder.PluralAffix("orgcKa.tme:.Durion", "orgcKa.tme:.Durion");
      
      // When the printTo method is called with a Writer and an integer representing the number of units
      CharArrayWriter writer = new CharArrayWriter();
      pluralAffix.printTo((Writer) writer, 1);
      
      // Then the output should be the singular form of the time unit
      assertEquals("orgcKa.tme:.Durion", writer.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPluralAffixTaking2ArgumentsAndCallsPrintToTaking1And11() throws Throwable  {
      // Given a PeriodFormatterBuilder.PluralAffix instance
      PeriodFormatterBuilder.PluralAffix pluralAffix = new PeriodFormatterBuilder.PluralAffix("orgjoda.tme.Durion", "orgjoda.tme.Durion");
      
      // When the printTo method is called with a Writer argument
      CharArrayWriter writer = new CharArrayWriter();
      pluralAffix.printTo((Writer)writer, 0);
      
      // Then the string representation of the PluralAffix should be printed to the Writer
      assertEquals("orgjoda.tme.Durion", writer.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking1And1AndPrintToTaking1And1() throws Throwable  {
      // Arrange
      PeriodFormatterBuilder.PluralAffix pluralAffix = new PeriodFormatterBuilder.PluralAffix("", "");
      StringBuffer buffer = new StringBuffer();
      
      // Act
      pluralAffix.printTo(buffer, 1);
      
      // Assert
      assertEquals("", buffer.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCalculatePrintedLengthTakingIntAndCalculatePrintedLengthTakingInt() throws Throwable  {
      // Given a PeriodFormatterBuilder.PluralAffix instance with a plural affix
      PeriodFormatterBuilder.PluralAffix periodFormatterBuilder_PluralAffix = new PeriodFormatterBuilder.PluralAffix("Builder has created neither a printer nor a parser", "|EkG:#IaX");
      
      // When the calculatePrintedLength method is called with an argument of 1
      int calculatedPrintedLength = periodFormatterBuilder_PluralAffix.calculatePrintedLength(1);
      
      // Then the printed length should be equal to 50
      assertEquals(50, calculatedPrintedLength);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSimpleAffixTakingStringAndCallsScan0() throws Throwable  {
      // Create a SimpleAffix with the string "3_>7W ZDvY%UmV^q"
      PeriodFormatterBuilder.SimpleAffix simpleAffix = new PeriodFormatterBuilder.SimpleAffix("3_>7W ZDvY%UmV^q");
      
      // Create a CompositeAffix with the SimpleAffix and itself as arguments
      PeriodFormatterBuilder.CompositeAffix compositeAffix = new PeriodFormatterBuilder.CompositeAffix(simpleAffix, simpleAffix);
      
      // Scan the string "9>~^}d73O(tK8N!k" with the CompositeAffix starting at index 0
      int scan = compositeAffix.scan("9>~^}d73O(tK8N!k", 0);
      
      // Assert that the scan result is -1
      assertEquals(-1, scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSimpleAffixTakingStringAndCallsScan1() throws Throwable  {
      // Create a PeriodFormatterBuilder.SimpleAffix with the message "below the supported minimum of ".
      PeriodFormatterBuilder.SimpleAffix belowMinimum = new PeriodFormatterBuilder.SimpleAffix("below the supported minimum of ");
      // Create a PeriodFormatterBuilder.CompositeAffix using the above SimpleAffix and itself.
      PeriodFormatterBuilder.CompositeAffix compositeAffix = new PeriodFormatterBuilder.CompositeAffix(belowMinimum, belowMinimum);
      // Scan the input string "72%&I" for the percentage sign.
      int scan = compositeAffix.scan("72%&I", 0);
      // Assert that the scanned value is -1, indicating a negative percentage.
      assertEquals(-1, scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSimpleAffixTakingStringAndCallsScan2() throws Throwable  {
      // Create a SimpleAffix with the prefix and suffix
      PeriodFormatterBuilder.SimpleAffix arg1 = new PeriodFormatterBuilder.SimpleAffix("0,uJfM ");
      
      // Create a CompositeAffix with the SimpleAffix as the prefix and suffix
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(arg1, arg1);
      
      // Scan the string "xr6Z$ME/][T/WfF-~`Q" with an offset of 2
      int scan = periodFormatterBuilder_CompositeAffix.scan("xr6Z$ME/][T/WfF-~`Q", 2);
      
      // Assert that the scan value is equal to -3
      assertEquals(-3, scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSimpleAffixTakingStringAndCallsScan3() throws Throwable  {
      // Create a new instance of the PeriodFormatterBuilder.SimpleAffix class with the specified string as the prefix and suffix.
      PeriodFormatterBuilder.SimpleAffix arg1 = new PeriodFormatterBuilder.SimpleAffix("rSTr45?%c8C4:03P)|");
      
      // Create a new instance of the PeriodFormatterBuilder.CompositeAffix class with the specified prefix and suffix.
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(arg1, arg1);
      
      // Scan the specified string for a match using the CompositeAffix object. The '5' argument specifies the starting index of the search.
      int scan = periodFormatterBuilder_CompositeAffix.scan("rSTr45?%c8C4:03P)|", 5);
      
      // Assert that the scan returned a negative value indicating no match was found.
      assertEquals((-6), scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSimpleAffixTakingStringAndCallsScan4() throws Throwable  {
      // Given a composite affix with two simple affixes
      PeriodFormatterBuilder.SimpleAffix arg1 = new PeriodFormatterBuilder.SimpleAffix("rSTr45?%c8C4:03P)|");
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(arg1, arg1);
      
      // When the scan method is called with a string and an index
      int scan = periodFormatterBuilder_CompositeAffix.scan("rSTr45?%c8C4:03P)|", 11);
      
      // Then the scan method should return -12
      assertEquals(-12, scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSimpleAffixTakingStringAndCallsScan5() throws Throwable  {
      // Given a PeriodFormatterBuilder and a CompositeAffix with two SimpleAffixes,
      // create a new CompositeAffix with the same two SimpleAffixes.
      PeriodFormatterBuilder.SimpleAffix pacificApia = new PeriodFormatterBuilder.SimpleAffix("Pacific/Apia");
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(pacificApia, pacificApia);
      
      // When we scan the string "3r{*l{8xKzE;]$Ido" with the CompositeAffix,
      int scan = periodFormatterBuilder_CompositeAffix.scan("3r{*l{8xKzE;]$Ido", 0);
      
      // Then we expect the scan to return -1, indicating that no period was found in the string.
      assertEquals((-1), scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSimpleAffixTakingStringAndCallsScan6() throws Throwable  {
      // rollbacked to evosuite
      PeriodFormatterBuilder.SimpleAffix arg1 = new PeriodFormatterBuilder.SimpleAffix("(=w[V`=U\"8|");
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(arg1, arg1);
      int scan = periodFormatterBuilder_CompositeAffix.scan("1qm`:cak{#09t", 0);
      assertEquals((-1), scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSimpleAffixTakingStringAndCallsScan7() throws Throwable  {
      // Create a new instance of PeriodFormatterBuilder.SimpleAffix with the prefix and suffix values
      PeriodFormatterBuilder.SimpleAffix affix = new PeriodFormatterBuilder.SimpleAffix("jc)h");
      
      // Create a new instance of PeriodFormatterBuilder.CompositeAffix with the affix and itself as arguments
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(affix, affix);
      
      // Call the scan method on the CompositeAffix instance and pass in the input string and starting position
      int scan = periodFormatterBuilder_CompositeAffix.scan("/9}VmP[}*Y", 0);
      
      // Assert that the returned value is negative one, indicating that no matching pattern was found
      assertEquals((-1), scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testScanAndScan() throws Throwable  {
      // Given a PeriodFormatterBuilder.SimpleAffix instance with the prefix "org.joda.time.format.PeriodFormatterBuilder$Composite"
      PeriodFormatterBuilder.SimpleAffix periodFormatterBuilder_SimpleAffix = new PeriodFormatterBuilder.SimpleAffix("org.joda.time.format.PeriodFormatterBuilder$Composite");
      
      // When the scan method is called with the prefix and the expected length of 8
      int scan = periodFormatterBuilder_SimpleAffix.scan("org.joda.time.format.PeriodFormatterBuilder$Composite", 8);
      
      // Then the scanned value should be -9
      assertEquals((-9), scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSimpleAffixTakingStringAndCallsScan8() throws Throwable  {
      // Given a period formatter builder with a simple affix and composite affixes
      PeriodFormatterBuilder.SimpleAffix arg1 = new PeriodFormatterBuilder.SimpleAffix("rSTr45?%c8C4:03P)|");
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(arg1, arg1);
      
      // When the scan method is called with a specific input
      int scan = periodFormatterBuilder_CompositeAffix.scan("hk#zF-2Q`C", 5);
      
      // Then the scan method should return the expected value of -6
      assertEquals((-6), scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesSimpleAffixTakingStringAndCallsScan9() throws Throwable  {
      // Given a PeriodFormatterBuilder.CompositeAffix object with a SimpleAffix and a string pattern
      PeriodFormatterBuilder.SimpleAffix arg1 = new PeriodFormatterBuilder.SimpleAffix("0,un}vjfms");
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(arg1, arg1);
      
      // When the scan method is called with a string and an integer offset
      int scan = periodFormatterBuilder_CompositeAffix.scan("0,f3 pJfMs", 0);
      
      // Then the scan method should return -1 as there are no periods in the string
      assertEquals(-1, scan);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test3() throws Throwable  {
      // Test that an exception is thrown when trying to parse a malformed hour string
      try {
      Hours.parseHours("ph"); // Try parsing the "ph" string as a hour
      fail("Expecting exception: IllegalArgumentException"); // Assert that an exception is thrown
      } catch(IllegalArgumentException e) {
      // Verify that the exception is of type IllegalArgumentException and has the expected message
      verifyException("org.joda.time.format.PeriodFormatter", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test4() throws Throwable  {
      // Test that parsing an invalid format throws the correct exception with a descriptive message
      try {
      Hours.parseHours("p8");
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      //
      // Invalid format: \"p8\" is malformed at \"8\"
      //
      verifyException("org.joda.time.format.PeriodFormatter", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseAndParse() throws Throwable  {
      // Create a new SimpleAffix with the value "org.!oda.time.format.PeriodFormattrBuilder$Literal"
      PeriodFormatterBuilder.SimpleAffix simpleAffix = new PeriodFormatterBuilder.SimpleAffix("org.!oda.time.format.PeriodFormattrBuilder$Literal");
      
      // Parse the input string "org.!oda.time.format.PeriodFormattrBuilder$Literal" using the SimpleAffix instance
      int parseResult = simpleAffix.parse("org.!oda.time.format.PeriodFormattrBuilder$Literal", 0);
      
      // Assert that the parsed result is equal to 50
      assertEquals(50, parseResult);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParse() throws Throwable  {
      // Create two SimpleAffix objects that represent the prefix and suffix used in the parse method
      PeriodFormatterBuilder.SimpleAffix prefix = new PeriodFormatterBuilder.SimpleAffix("MpEwaJ:p+7r!LF&");
      PeriodFormatterBuilder.SimpleAffix suffix = new PeriodFormatterBuilder.SimpleAffix("MpEwaJ:p+7r!LF&");
      
      // Create a CompositeAffix object that combines the prefix and suffix into a single affix
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(prefix, suffix);
      
      // Call the parse method on the CompositeAffix object with the input string "below the supported minimum of " and starting at index 0
      int parse = periodFormatterBuilder_CompositeAffix.parse("below the supported minimum of ", 0);
      
      // Assert that the parse result is -1, indicating that the input string does not match the expected format
      assertEquals((-1), parse);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToFormatterReturningPeriodFormatterWhereIsParserIsFalse() throws Throwable  {
      // Given: A PeriodFormatter object with a Literal printer and no parser
      PeriodFormatterBuilder builder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder.Literal arg0 = PeriodFormatterBuilder.Literal.EMPTY;
      builder.append((PeriodPrinter) arg0, (PeriodParser) null);
      PeriodFormatter formatter = builder.toFormatter();
      
      // When: Checking if the formatter is a parser or not
      boolean actualResult = formatter.isParser();
      
      // Then: The result should be false, since there is no parser for this formatter
      assertFalse(actualResult);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSeparatorIfFieldsAfter() throws Throwable  {
      // Given a PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When appending a separator if fields after is called with a specific type
      periodFormatterBuilder.appendSeparatorIfFieldsAfter("org.joda.time.format.PeriodFormatterBuilder$PluralAffix");
      
      // Then the resulting formatter should be a parser
      PeriodFormatter formatter = periodFormatterBuilder.toFormatter();
      assertTrue(formatter.isParser());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToParserReturningNonNull() throws Throwable  {
      // Given a PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When we create a Literal instance with an empty string
      PeriodFormatterBuilder.Literal arg1 = PeriodFormatterBuilder.Literal.EMPTY;
      
      // And append the null parser and the Literal instance to the PeriodFormatterBuilder
      PeriodFormatterBuilder append = periodFormatterBuilder.append((PeriodPrinter) null, (PeriodParser) arg1);
      
      // Then we should get a non-null parser
      PeriodParser parser = append.toParser();
      assertNotNull(parser);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendLiteralThrowsIllegalStateException() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder appendPrefix = periodFormatterBuilder.appendPrefix("'f");
      // Undeclared exception!
      try { 
        appendPrefix.appendLiteral("'f");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Prefix not followed by field
         //
         verifyException("org.joda.time.format.PeriodFormatterBuilder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSeparatorTaking2ArgumentsWithNonEmptyStringAndNonEmptyString() throws Throwable  {
      // Arrange
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder appendSeparatorIfFieldsAfter = periodFormatterBuilder.appendSeparatorIfFieldsAfter("pacificg/apia;]$ido");
      
      // Act
      PeriodFormatterBuilder appendSecondsWithMillis = appendSeparatorIfFieldsAfter.appendSecondsWithMillis();
      
      // Assert
      assertSame(appendSeparatorIfFieldsAfter, appendSecondsWithMillis);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSeparatorIfFieldsBeforeThrowsIllegalStateException() throws Throwable  {
      // rollbacked to evosuite
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder appendSeparatorIfFieldsAfter = periodFormatterBuilder.appendSeparatorIfFieldsAfter("p,fm");
      // Undeclared exception!
      try { 
        appendSeparatorIfFieldsAfter.appendSeparatorIfFieldsBefore("p,fm");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Cannot have two adjacent separators
         //
         verifyException("org.joda.time.format.PeriodFormatterBuilder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSeparatorIfFieldsBefore() throws Throwable  {
      // Given a PeriodFormatterBuilder object
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When we append a separator if fields before "org.joda.time.LocalDateTime"
      PeriodFormatterBuilder appendSeparatorIfFieldsBefore = periodFormatterBuilder.appendSeparatorIfFieldsBefore("org.joda.time.LocalDateTime");
      
      // Then the return value should be the same as the original object
      assertSame(periodFormatterBuilder, appendSeparatorIfFieldsBefore);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSeparatorTaking3ArgumentsThrowsIllegalArgumentException() throws Throwable  {
      // Given
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When
      try {
      periodFormatterBuilder.appendSeparator("rSTr45?%c8C4:03P)|", (String) null, (String[]) null);
      } catch(IllegalArgumentException e) {
      // Then
      assertEquals("Expecting exception: IllegalArgumentException", e.getMessage());
      throw e;}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSuffixTaking2ArgumentsThrowsIllegalArgumentException() throws Throwable  {
      // Given
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      try {
      // When
      periodFormatterBuilder.appendSuffix("n", (String) null);
      
      // Then
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // no message in exception (getMessage() returned null)
      verifyException("org.joda.time.format.PeriodFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSuffixTaking2ArgumentsThrowsIllegalStateException() throws Throwable  {
      // Given: A PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      try {
      // When: Appending a suffix to the formatter
      periodFormatterBuilder.appendSuffix("hours", "24 hours");
      
      // Then: An IllegalStateException is thrown because there is no field to apply the suffix to
      fail("Expecting exception: IllegalStateException");
      } catch (IllegalStateException e) {
      // Verify that the exception is thrown as expected
      verifyException("org.joda.time.format.PeriodFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSuffixTaking2ArgumentsWithNull() throws Throwable  {
      // Create a new PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // Try to append an invalid suffix (null) to the builder
      try {
      periodFormatterBuilder.appendSuffix(null, null);
      // Fail the test since an IllegalArgumentException is expected
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the exception was thrown with the correct message
      verifyException("org.joda.time.format.PeriodFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSuffixTakingStringThrowsIllegalArgumentException() throws Throwable  {
      // Arrange
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // Act and Assert
      try {
      periodFormatterBuilder.appendSuffix((String) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the correct exception is thrown
      assertEquals("The suffix cannot be null", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendPrefixTaking2Arguments() throws Throwable  {
      // rollbacked to evosuite
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      periodFormatterBuilder.appendPrefix("'xECuMh");
      PeriodFormatterBuilder appendPrefix = periodFormatterBuilder.appendPrefix("'xECuMh", "'xECuMh");
      assertSame(periodFormatterBuilder, appendPrefix);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendPrefixTaking2ArgumentsThrowsIllegalArgumentException() throws Throwable  {
      // Given: A PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When: Calling appendPrefix with a null message
      try {
      periodFormatterBuilder.appendPrefix("Quarterly Reporting Duration", (String) null);
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      // Then: A IllegalArgumentException should be thrown with a null message
      verifyException("org.joda.time.format.PeriodFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendPrefixTaking2ArgumentsWithNull() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      // Undeclared exception!
      try { 
        periodFormatterBuilder.appendPrefix((String) null, (String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.PeriodFormatterBuilder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendPrefixTakingStringThrowsIllegalArgumentException() throws Throwable  {
      // Test that an IllegalArgumentException is thrown when a null argument is passed to appendPrefix()
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      try {
      periodFormatterBuilder.appendPrefix((String) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the expected message is present in the exception
      assertTrue(e.getMessage().contains("Cannot append a prefix of null"));}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendLiteralThrowsIllegalArgumentException() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      // Undeclared exception!
      try { 
        periodFormatterBuilder.appendLiteral((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Literal must not be null
         //
         verifyException("org.joda.time.format.PeriodFormatterBuilder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTaking2ArgumentsThrowsIllegalArgumentException() throws Throwable  {
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // Test that a null printer or parser is not allowed
      try {
      periodFormatterBuilder.append((PeriodPrinter) null, (PeriodParser) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // No printer or parser supplied
      verifyException("org.joda.time.format.PeriodFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTakingPeriodFormatterThrowsIllegalArgumentException() throws Throwable  {
      // Given a PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When a null formatter is supplied
      try {
      periodFormatterBuilder.append((PeriodFormatter) null);
      
      // Then an IllegalArgumentException should be thrown
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the correct exception is thrown
      verifyException("org.joda.time.format.PeriodFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClear() throws Throwable  {
      // rollbacked to evosuite
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      periodFormatterBuilder.clear();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToParserReturningNull() throws Throwable  {
      // Create a new PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // Append an empty Literal to the builder
      PeriodFormatterBuilder.Literal arg0 = PeriodFormatterBuilder.Literal.EMPTY;
      periodFormatterBuilder.append((PeriodPrinter) arg0, (PeriodParser) null);
      
      // Build a PeriodParser from the builder
      PeriodParser parser = periodFormatterBuilder.toParser();
      
      // Assert that the parser is null
      assertNull(parser);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToPrinterReturningNull() throws Throwable  {
      // Given a PeriodFormatterBuilder and a Literal argument
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder.Literal arg1 = PeriodFormatterBuilder.Literal.EMPTY;
      
      // When the append method is called with null values for printer and parser arguments
      PeriodPrinter printer = periodFormatterBuilder.append((PeriodPrinter) null, (PeriodParser) arg1).toPrinter();
      
      // Then the result should be null
      assertNull(printer);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendLiteral() throws Throwable  {
      // Given the fact that we are testing the PeriodFormatterBuilder class
      // When we append a literal string to the builder
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder appendLiteral = periodFormatterBuilder.appendLiteral("Hello");
      
      // Then we expect the result to be the same as the original builder
      assertSame(appendLiteral, periodFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test5() throws Throwable  {
      // Given a period with months precision that is not precise (e.g. P292279001M292279001W1189DT3118H3118M292279001.085S)
      Period arg0 = new Period(0, 292279001, 292279001, 1189, 3118, 3118, 292279001, 85);
      // When trying to convert the period to a duration with months precision
      try {
      Days.standardDaysIn(arg0);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Then an exception is thrown indicating that the period cannot be converted to a duration with months precision
      verifyException("org.joda.time.base.BaseSingleFieldPeriod", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendMillis3Digit() throws Throwable  {
      // Given a PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When the appendMillis3Digit method is called on the builder
      PeriodFormatterBuilder appendMillis3Digit = periodFormatterBuilder.appendMillis3Digit();
      
      // Then the same instance should be returned
      assertSame(periodFormatterBuilder, appendMillis3Digit);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSeparatorTaking3Arguments() throws Throwable  {
      // Given a PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When appending a separator to the builder
      PeriodFormatterBuilder appendSeparator = periodFormatterBuilder.appendSeparator("#ZlF", "#ZlF", (String[]) null);
      
      // Then the same PeriodFormatterBuilder instance should be returned
      assertSame(periodFormatterBuilder, appendSeparator);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMinimumPrintedDigits() throws Throwable  {
      // rollbacked to evosuite
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder minimumPrintedDigits = periodFormatterBuilder.minimumPrintedDigits(10);
      assertSame(minimumPrintedDigits, periodFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSeparatorIfFieldsAfterWithEmptyString() throws Throwable  {
      // rollbacked to evosuite
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      periodFormatterBuilder.appendSeparatorIfFieldsAfter("");
      PeriodPrinter printer = periodFormatterBuilder.toPrinter();
      assertNotNull(printer);
      
      LocalTime arg1 = new LocalTime((-1121L));
      PeriodType arg2 = PeriodType.minutes();
      Period arg0 = new Period(arg1, arg1, arg2);
      int calculatePrintedLength = printer.calculatePrintedLength(arg0, (Locale) null);
      assertEquals(0, calculatePrintedLength);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSeparatorIfFieldsBeforeThrowsIllegalArgumentException() throws Throwable  {
      // Given: A PeriodFormatterBuilder instance with a null separator string
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When: The appendSeparatorIfFieldsBefore method is called with a null string
      try {
      periodFormatterBuilder.appendSeparatorIfFieldsBefore((String) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Then: An IllegalArgumentException is thrown with no message
      verifyException("org.joda.time.format.PeriodFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintZeroNever() throws Throwable  {
      // Given: a period with no duration
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      periodFormatterBuilder.printZeroNever();
      PeriodFormatterBuilder appendSecondsWithOptionalMillis = periodFormatterBuilder.appendSecondsWithOptionalMillis();
      PeriodPrinter printer = appendSecondsWithOptionalMillis.toPrinter();
      assertNotNull(printer);
      
      // When: the period is printed with printTo()
      StringBuffer output = new StringBuffer();
      Period emptyPeriod = new Period();
      Locale locale = Locale.US;
      printer.printTo(output, (ReadablePeriod) emptyPeriod, locale);
      
      // Then: no text is printed
      assertEquals(0, output.length());
      assertEquals("", output.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMaximumParsedDigits() throws Throwable  {
      // rollbacked to evosuite
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder maximumParsedDigits = periodFormatterBuilder.maximumParsedDigits(1024);
      assertSame(periodFormatterBuilder, maximumParsedDigits);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTaking2Arguments() throws Throwable  {
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder.Literal arg1 = (PeriodFormatterBuilder.Literal)periodFormatterBuilder.toPrinter();
      periodFormatterBuilder.append((PeriodPrinter) arg1, (PeriodParser) arg1);
      
      // Given a period formatter with a field to apply suffix to
      String fieldName = "hours";
      PeriodFormatterBuilder builder = new PeriodFormatterBuilder().appendSuffix(fieldName, "24 hours");
      
      // When attempting to append a suffix to the formatter with no field to apply it to
      try {
      periodFormatterBuilder.appendSuffix("hours", "24 hours");
      fail("Expecting exception: IllegalStateException");
      } catch(IllegalStateException e) {
      // Then an IllegalStateException is thrown with the correct message
      assertEquals("No field to apply suffix to.", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11And1AndPrintZeroRarelyFirst1() throws Throwable  {
      // Test that printZeroRarelyFirst() returns a non-null PeriodPrinter instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodPrinter printer = periodFormatterBuilder.printZeroRarelyFirst().toPrinter();
      assertNotNull(printer);
      
      // Test that the printer prints nothing for a zero-length period
      StringBuffer arg0 = new StringBuffer();
      Period arg1 = Period.years(0);
      Locale arg2 = Locale.CANADA_FRENCH;
      printer.printTo(arg0, (ReadablePeriod) arg1, arg2);
      assertEquals(0, arg0.length());
      assertEquals("", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintZeroIfSupported() throws Throwable  {
      // rollbacked to evosuite
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      PeriodFormatterBuilder printZeroIfSupported = periodFormatterBuilder.printZeroIfSupported();
      periodFormatterBuilder.appendSecondsWithMillis();
      PeriodPrinter printer = printZeroIfSupported.toPrinter();
      StringBuffer arg0 = new StringBuffer();
      Period arg1 = Period.ZERO;
      Locale arg2 = Locale.US;
      printer.printTo(arg0, (ReadablePeriod) arg1, arg2);
      assertEquals(5, arg0.length());
      assertEquals("0.000", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSeconds() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      periodFormatterBuilder.appendSeconds();
      PeriodPrinter arg0 = periodFormatterBuilder.toPrinter();
      PeriodFormatterBuilder.Literal arg1 = PeriodFormatterBuilder.Literal.EMPTY;
      periodFormatterBuilder.append(arg0, (PeriodParser) arg1);
      // Undeclared exception!
      try { 
        periodFormatterBuilder.appendSuffix("czw-s!$JZeLOSsHP/", "(57P<f4$5pA\"7");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No field to apply suffix to
         //
         verifyException("org.joda.time.format.PeriodFormatterBuilder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRejectSignedValues() throws Throwable  {
      // Given a PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When rejecting signed values
      PeriodFormatterBuilder rejectSignedValues = periodFormatterBuilder.rejectSignedValues(true);
      
      // Then the same builder instance is returned
      assertSame(periodFormatterBuilder, rejectSignedValues);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintZeroRarelyLast() throws Throwable  {
      // Given a PeriodFormatterBuilder instance
      PeriodFormatterBuilder periodFormatterBuilder = new PeriodFormatterBuilder();
      
      // When calling printZeroRarelyLast method on the builder
      PeriodFormatterBuilder printZeroRarelyLast = periodFormatterBuilder.printZeroRarelyLast();
      
      // Then the same builder instance should be returned
      assertSame(periodFormatterBuilder, printZeroRarelyLast);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesCompositeAffixTaking2ArgumentsAndCallsPrintToTaking1And1() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder.SimpleAffix arg1 = new PeriodFormatterBuilder.SimpleAffix((String) null);
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(arg1, arg1);
      // Undeclared exception!
      try { 
        periodFormatterBuilder_CompositeAffix.printTo((Writer) null, 3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.PeriodFormatterBuilder$SimpleAffix", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking1And1AndPrintToTaking1And1AndCreatesCompositeAffixTaking2Arguments() throws Throwable  {
      // Given: a PeriodFormatterBuilder.PluralAffix with an empty string for the singular and plural affixes
      PeriodFormatterBuilder.PluralAffix pluralAffix = new PeriodFormatterBuilder.PluralAffix("", "");
      
      // And: a CompositeAffix with the PluralAffix as its singular and plural affixes
      PeriodFormatterBuilder.CompositeAffix compositeAffix = new PeriodFormatterBuilder.CompositeAffix(pluralAffix, pluralAffix);
      
      // When: printing the CompositeAffix to a StringBuffer with a value of 0
      StringBuffer buffer = new StringBuffer("");
      compositeAffix.printTo(buffer, 0);
      
      // Then: the resulting string should be an empty string
      assertEquals("", buffer.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesCompositeAffixTaking2ArgumentsAndCallsCalculatePrintedLengthTakingInt() throws Throwable  {
      // No Comments were added
      PeriodFormatterBuilder.PluralAffix arg1 = new PeriodFormatterBuilder.PluralAffix((String) null, "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix");
      PeriodFormatterBuilder.CompositeAffix periodFormatterBuilder_CompositeAffix = new PeriodFormatterBuilder.CompositeAffix(arg1, arg1);
      int calculatePrintedLength = periodFormatterBuilder_CompositeAffix.calculatePrintedLength(2204);
      assertEquals(110, calculatePrintedLength);
  }
}
