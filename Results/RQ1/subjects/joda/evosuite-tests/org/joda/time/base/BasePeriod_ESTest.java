/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 09:37:37 GMT 2024
 */

package org.joda.time.base;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.Duration;
import org.joda.time.DurationFieldType;
import org.joda.time.Hours;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import org.joda.time.Minutes;
import org.joda.time.MonthDay;
import org.joda.time.MutableDateTime;
import org.joda.time.MutablePeriod;
import org.joda.time.Period;
import org.joda.time.PeriodType;
import org.joda.time.ReadableDuration;
import org.joda.time.ReadableInstant;
import org.joda.time.ReadablePartial;
import org.joda.time.ReadablePeriod;
import org.joda.time.chrono.BuddhistChronology;
import org.joda.time.chrono.EthiopicChronology;
import org.joda.time.chrono.ISOChronology;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class BasePeriod_ESTest extends BasePeriod_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToDurationToReturningDurationWhereGetMillisIsNegative() throws Throwable  {
      // Test that the toDurationTo() method returns a Duration with the correct milliseconds value
      ISOChronology arg1 = ISOChronology.getInstance((DateTimeZone) null);
      MutablePeriod mutablePeriod = new MutablePeriod((-2101L), (Chronology) arg1);
      MutableDateTime arg0 = new MutableDateTime((DateTimeZone) null);
      Duration durationTo = mutablePeriod.toDurationTo(arg0);
      assertEquals((-2101L), durationTo.getMillis());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToDurationFromReturningDurationWhereGetStandardSecondsIsZero() throws Throwable  {
      // Set up the test data
      DateTime currentDate = new DateTime();
      MutablePeriod mutablePeriod = new MutablePeriod();
      
      // Execute the method under test
      Duration durationFrom = mutablePeriod.toDurationFrom(currentDate);
      
      // Verify the results
      assertEquals(0L, durationFrom.getStandardSeconds());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetValueReturningZero() throws Throwable  {
      // Test to check that the Period.seconds method returns the correct value when called with a positive integer argument
      Period seconds = Period.seconds(4);
      int value = seconds.getValue(4);
      assertEquals(0, value); // Assert that the returned value is 0, as it should be a period of 4 seconds
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test0() throws Throwable  {
      // rollbacked to evosuite
      Period arg0 = Period.years(12);
      DateTime arg1 = new DateTime();
      PeriodType arg2 = PeriodType.seconds();
      MutablePeriod mutablePeriod = new MutablePeriod(arg1, arg1, arg2);
      // Undeclared exception!
      try { 
        mutablePeriod.add((ReadablePeriod) arg0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Period does not support field 'years'
         //
         verifyException("org.joda.time.base.BasePeriod", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test1() throws Throwable  {
      // Create a new instance of MutablePeriod
      MutablePeriod mutablePeriod = new MutablePeriod();
      
      // Attempt to add null as a ReadablePeriod to the MutablePeriod
      mutablePeriod.add((ReadablePeriod) null);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test2() throws Throwable  {
      // Given a mutable period object
      MutablePeriod mutablePeriod = new MutablePeriod();
      
      // When the mergePeriod method is called with a null argument
      mutablePeriod.mergePeriod(null);
      
      // Then an exception should be thrown
      assertThrows(NullPointerException.class, () -> {
      mutablePeriod.mergePeriod((ReadablePeriod) null);});
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test3() throws Throwable  {
      // rollbacked to evosuite
      Hours hours = Hours.THREE;
      PeriodType arg0 = hours.getPeriodType();
      MutablePeriod mutablePeriod = new MutablePeriod(arg0);
      mutablePeriod.addYears(0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test4() throws Throwable  {
      // Setup
      Hours hours = Hours.THREE;
      PeriodType arg0 = hours.getPeriodType();
      MutablePeriod mutablePeriod = new MutablePeriod(arg0);
      
      // Action
      try {
      mutablePeriod.add((DurationFieldType) null, 0);
      } catch (IllegalArgumentException e) {
      // Verify exception
      verifyException("org.joda.time.base.BasePeriod", e);
      throw e;}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test5() throws Throwable  {
      // rollbacked to evosuite
      Hours hours = Hours.THREE;
      PeriodType arg0 = hours.getPeriodType();
      MutablePeriod mutablePeriod = new MutablePeriod(arg0);
      mutablePeriod.setWeeks(0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test6() throws Throwable  {
      Minutes minutes = Minutes.MIN_VALUE;
      MutablePeriod mutablePeriod = minutes.toMutablePeriod();
      
      // Given the following values:
      DurationFieldType nullFieldType = null; // This is an invalid field type, as it does not exist in the Period class
      int zeroValue = 0;
      
      try {
      // When we attempt to set the period with the given field type and value
      mutablePeriod.set(nullFieldType, zeroValue);
      
      // Then an IllegalArgumentException should be thrown
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Verify that the expected exception is thrown
      verifyException("org.joda.time.base.BasePeriod", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test7() throws Throwable  {
      // Given: A PeriodType object representing the year-week-day-time format
      // and a BuddhistChronology object for UTC time zone
      PeriodType arg1 = PeriodType.yearWeekDayTime();
      BuddhistChronology arg2 = BuddhistChronology.getInstanceUTC();
      // When: A new MutablePeriod object is created with the given arguments
      MutablePeriod mutablePeriod = new MutablePeriod((Object) null, arg1, arg2);
      // And: The weeks field of the MutablePeriod object is set to 682
      mutablePeriod.setWeeks(682);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test8() throws Throwable  {
      // Arrange
      Period years = Period.years(12);
      PeriodType arg0 = PeriodType.dayTime();
      
      // Act and Assert
      try {
      years.withPeriodType(arg0);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Assert
      verifyException("org.joda.time.base.BasePeriod", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test9() throws Throwable  {
      // rollbacked to evosuite
      MutablePeriod mutablePeriod = new MutablePeriod();
      Period period = mutablePeriod.toPeriod();
      assertNotNull(period);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test10() throws Throwable  {
      // Given
      DateTime dateTime = new DateTime();
      LocalDateTime localDateTime = dateTime.toLocalDateTime();
      LocalTime localTime = LocalTime.now();
      PeriodType periodType = PeriodType.yearDayTime();
      
      // When
      try {
      Period period = new Period(localDateTime, localTime, periodType);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Then
      verifyException("org.joda.time.base.BasePeriod", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test11() throws Throwable  {
      // Given: A LocalTime object and a MonthDay object that do not have the same set of fields
      LocalTime arg0 = new LocalTime();
      MonthDay arg1 = new MonthDay();
      
      // When: Creating a Period object with these arguments
      Period period = null;
      try {
      period = new Period(arg0, arg1);
      } catch (IllegalArgumentException e) {
      // Then: Expecting an IllegalArgumentException to be thrown
      verifyException("org.joda.time.base.BasePeriod", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test12() throws Throwable  {
      // rollbacked to evosuite
      LocalDateTime arg1 = new LocalDateTime();
      Period period = new Period(arg1, arg1);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test13() throws Throwable  {
      // Given a MonthDay object representing the current date and time
      MonthDay arg0 = MonthDay.now();
      
      // When trying to create a new Period instance using the MonthDay object as the start date and with a null ReadablePartial object as the end date
      Period period = null;
      try {
      period = new Period(arg0, (ReadablePartial) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Then an IllegalArgumentException is thrown because ReadablePartial objects must not be null
      verifyException("org.joda.time.base.BasePeriod", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test14() throws Throwable  {
      // Given: a Period object with null ReadablePartial objects
      Period period = null;
      
      try {
      // When: the constructor is called with null ReadablePartial objects
      period = new Period((ReadablePartial) null, (ReadablePartial) null);
      
      // Then: an IllegalArgumentException is thrown
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      // Verify that the expected exception was thrown
      verifyException("org.joda.time.base.BasePeriod", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test15() throws Throwable  {
      // rollbacked to evosuite
      PeriodType arg2 = PeriodType.seconds();
      MutablePeriod mutablePeriod = new MutablePeriod((ReadableInstant) null, (ReadableInstant) null, arg2);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetValueReturningPositive() throws Throwable  {
      // Given a period of 4 milliseconds and a duration of 7 seconds
      Period millis = Period.millis(4);
      int value = millis.getValue(7);
      
      // When the value is retrieved from the period using the duration
      int result = value;
      
      // Then the result should be equal to 4, which is the number of milliseconds in 7 seconds
      assertEquals(4, result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test16() throws Throwable  {
      // rollbacked to evosuite
      MutablePeriod mutablePeriod = new MutablePeriod();
      mutablePeriod.setPeriod(123456789, 123456789, 123456789, 123456789, 123456789, 123456789, 123456789, 123456789);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test17() throws Throwable  {
      PeriodType arg0 = PeriodType.years();
      MutablePeriod mutablePeriod = new MutablePeriod(arg0);
      
      // Test that an IllegalArgumentException is thrown when adding a negative number of hours to the period
      try {
      mutablePeriod.addHours(-23);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Verify that the expected exception is thrown, and that it is an instance of IllegalArgumentException
      verifyException("org.joda.time.base.BasePeriod", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test18() throws Throwable  {
      // rollbacked to evosuite
      MutablePeriod mutablePeriod = new MutablePeriod(1985L, 1985L, (Chronology) null);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test19() throws Throwable  {
      // Test that setting weeks on a MutablePeriod throws an IllegalArgumentException if the Period does not support the field 'weeks'
      Hours hours = Hours.THREE;
      PeriodType arg0 = hours.getPeriodType();
      MutablePeriod mutablePeriod = new MutablePeriod(arg0);
      // Undeclared exception!
      try {
      mutablePeriod.setWeeks(10);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // This is the expected behavior since the Period does not support the field 'weeks'
      verifyException("org.joda.time.base.BasePeriod", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToDurationToReturningDurationWhereGetMillisIsZero() throws Throwable  {
      // rollbacked to evosuite
      EthiopicChronology arg0 = EthiopicChronology.getInstance();
      MonthDay arg1 = MonthDay.now((Chronology) arg0);
      PeriodType arg2 = PeriodType.minutes();
      Period period = new Period(arg1, arg1, arg2);
      Duration durationTo = period.toDurationTo((ReadableInstant) null);
      durationTo.toPeriod();
      assertEquals(0L, durationTo.getStandardMinutes());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test20() throws Throwable  {
      // Given: A null period
      Period period = new Period((ReadableDuration) null, (ReadableInstant) null);
      
      // When: Creating a new instance of the Period class with a null duration and instant
      try {
      new Period(period);
      } catch (Exception e) {
      // Then: An exception should be thrown indicating that the period cannot be null
      assertEquals("Period cannot be null", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test21() throws Throwable  {
      // Given a BuddhistChronology instance with the UTC time zone
      PeriodType arg1 = PeriodType.yearWeekDayTime();
      BuddhistChronology arg2 = BuddhistChronology.getInstanceUTC();
      
      // When a new MutablePeriod is created with the instance and period type
      MutablePeriod mutablePeriod = new MutablePeriod(null, arg1, arg2);
      
      // Then the value for the first field (year) should be set to 7
      assertEquals(7, mutablePeriod.getValue(1));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPeriodType() throws Throwable  {
      // Given: We have a MutablePeriod object with values (-1, -1, 4, 23) and a DateTime object representing the current time.
      MutablePeriod mutablePeriod = new MutablePeriod((-1), (-1), 4, 23);
      DateTime arg0 = DateTime.now();
      
      // When: We convert the MutablePeriod to a Duration from the given DateTime using the MutablePeriod's toDurationFrom() method.
      Duration durationFrom = mutablePeriod.toDurationFrom(arg0);
      
      // Then: The resulting Duration should have a millisecond value of -3655977 and a standard minute value of -60.
      assertEquals((-3655977L), durationFrom.getMillis());
      assertEquals((-60L), durationFrom.getStandardMinutes());
  }
}
