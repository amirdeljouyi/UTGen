/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 08:07:03 GMT 2024
 */

package org.joda.time;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Locale;
import java.util.Set;
import java.util.SimpleTimeZone;
import java.util.TimeZone;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.joda.time.DateTimeZone;
import org.joda.time.Instant;
import org.joda.time.LocalDateTime;
import org.joda.time.ReadableInstant;
import org.joda.time.chrono.GJChronology;
import org.joda.time.tz.CachedDateTimeZone;
import org.joda.time.tz.DefaultNameProvider;
import org.joda.time.tz.FixedDateTimeZone;
import org.joda.time.tz.NameProvider;
import org.joda.time.tz.Provider;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class DateTimeZone_ESTest extends DateTimeZone_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToTimeZoneReturningTimeZoneWhereGetRawOffsetIsPositive() throws Throwable  {
      // Given a DateTimeZone with an offset of 1 millisecond
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(1);
      
      // When we convert it to a TimeZone
      TimeZone timeZone = forOffsetMillis.toTimeZone();
      
      // Then we get the expected ID and string representation
      assertEquals("+00:00:00.001", forOffsetMillis.getID());
      assertEquals("java.util.SimpleTimeZone[id=+00:00:00.001,offset=1,dstSavings=3600000,useDaylight=false,startYear=0,startMode=0,startMonth=0,startDay=0,startDayOfWeek=0,startTime=0,startTimeMode=0,endMode=0,endMonth=0,endDay=0,endDayOfWeek=0,endTime=0,endTimeMode=0]", timeZone.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToTimeZoneReturningTimeZoneWhereGetRawOffsetIsNegative() throws Throwable  {
      // Given a DateTimeZone with an offset of -3315 milliseconds, we expect to get a TimeZone that represents the same time zone.
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis((-3315));
      TimeZone timeZone = forOffsetMillis.toTimeZone();
      
      // When we convert this DateTimeZone to a TimeZone using the toTimeZone() method, we should get a TimeZone object with the same ID as the original DateTimeZone.
      String expectedTimeZoneId = "java.util.SimpleTimeZone[id=-00:00:03.315,offset=-3315,dstSavings=3600000,useDaylight=false,startYear=0,startMode=0,startMonth=0,startDay=0,startDayOfWeek=0,startTime=0,startTimeMode=0,endMode=0,endMonth=0,endDay=0,endDayOfWeek=0,endTime=0,endTimeMode=0]";
      assertEquals(expectedTimeZoneId, timeZone.toString());
      
      // And we should also get the same offset as the original DateTimeZone.
      assertEquals("-00:00:03.315", forOffsetMillis.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPreviousTransitionReturningZero() throws Throwable  {
      // Given a DateTimeZone object with an offset of +01:59
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 59);
      
      // When we call previousTransition with a timestamp of 0L
      forOffsetHoursMinutes.previousTransition(0L);
      
      // Then the toString method should return "+01:59"
      assertEquals("+01:59", forOffsetHoursMinutes.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPreviousTransitionReturningPositive() throws Throwable  {
      // Given a FixedDateTimeZone with UTC as the time zone
      DateTimeZone fixedDateTimeZone = DateTimeZone.UTC;
      
      // When we call previousTransition(10800000L) on it
      long previousTransition = fixedDateTimeZone.previousTransition(10800000L);
      
      // Then the result should be 10800000L
      assertEquals(10800000L, previousTransition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPreviousTransitionReturningNegative() throws Throwable  {
      // Arrange
      Instant instant = new Instant();
      DateTimeZone zone = instant.getZone();
      long expectedPreviousTransition = -398L;
      
      // Act
      long actualPreviousTransition = zone.previousTransition(expectedPreviousTransition);
      
      // Assert
      assertEquals(expectedPreviousTransition, actualPreviousTransition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTransitionReturningZero() throws Throwable  {
      // This test verifies that the UTC timezone returns a valid next transition time when given a timestamp of 0L.
      FixedDateTimeZone fixedDateTimeZone = (FixedDateTimeZone)DateTimeZone.UTC;
      long nextTransition = fixedDateTimeZone.nextTransition(0L);
      assertEquals(0L, nextTransition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTransitionReturningPositive() throws Throwable  {
      // Given a DateTimeZone with an offset of +01:59
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 59);
      
      // When the next transition time is calculated for a given timestamp
      long nextTransitionTime = forOffsetHoursMinutes.nextTransition(576117000005L);
      
      // Then the expected next transition time should be returned
      assertEquals("+01:59", forOffsetHoursMinutes.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTransitionReturningNegative() throws Throwable  {
      // Given a DateTimeZone instance "forOffsetMillis" with an offset of 406 milliseconds
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(406);
      
      // When the method "nextTransition" is called with the argument "-3926L"
      forOffsetMillis.nextTransition((-3926L));
      
      // Then the resulting string representation of the time zone should be "+00:00:00.406"
      assertEquals("+00:00:00.406", forOffsetMillis.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsFixed() throws Throwable  {
      // Test that the time zone is not a fixed time zone
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      assertFalse(forTimeZone.isFixed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetStandardOffsetReturningPositive() throws Throwable  {
      // Given a DateTimeZone for an offset of 1 hour and 59 minutes
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 59);
      
      // When the standard offset is requested for epoch time zero
      int standardOffset = forOffsetHoursMinutes.getStandardOffset(0L);
      
      // Then the result should be the expected value of 7140000
      assertEquals("+01:59", forOffsetHoursMinutes.toString());
      assertEquals(7140000, standardOffset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetStandardOffsetReturningNegative() throws Throwable  {
      // Create a DateTimeZone object for an offset of -3336 milliseconds.
      DateTimeZone dateTimeZone = DateTimeZone.forOffsetMillis((-3336));
      
      // Get the standard offset of the DateTimeZone object.
      int standardOffset = dateTimeZone.getStandardOffset((-3336));
      
      // Assert that the ID of the DateTimeZone object is "-00:00:03.336".
      assertEquals("-00:00:03.336", dateTimeZone.getID());
      
      // Assert that the standard offset of the DateTimeZone object is -3336 milliseconds.
      assertEquals((-3336), standardOffset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetTakingReadableInstantReturningPositive() throws Throwable  {
      // Given a DateTimeZone for an offset of 1 hour and 59 minutes
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 59);
      
      // When the offset is obtained using the getOffset method
      int offset = forOffsetHoursMinutes.getOffset((ReadableInstant) null);
      
      // Then the offset should be equal to 7140000
      assertEquals("+01:59", forOffsetHoursMinutes.toString());
      assertEquals(7140000, offset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetTakingLongReturningZero() throws Throwable  {
      // Given a time instant and a time zone
      Instant instant = new Instant();
      DateTimeZone zone = instant.getZone();
      
      // When the offset for the time zone is calculated
      int offset = zone.getOffset((-398L));
      
      // Then the offset should be zero
      assertEquals(0, offset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetTakingLongReturningPositive() throws Throwable  {
      // Given a DateTimeZone instance for an offset of 1 hour
      DateTimeZone forOffsetHours = DateTimeZone.forOffsetHours(1);
      
      // When we get the offset for a time zone ID
      long offset = forOffsetHours.getOffset((-803L));
      
      // Then the offset should be equal to 3600000 milliseconds (1 hour)
      assertEquals(3600000, offset);
      
      // And the time zone ID should be "+01:00"
      assertEquals("+01:00", forOffsetHours.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetTakingLongReturningNegative() throws Throwable  {
      // Given a time zone offset of -14 hours
      DateTimeZone forOffsetHours = DateTimeZone.forOffsetHours(-14);
      
      // When the offset is converted to a string
      String offsetString = forOffsetHours.toString();
      
      // Then the resulting string should be "-14:00"
      assertEquals("-14:00", offsetString);
      
      // Given a time zone offset of -14 hours
      int offset = forOffsetHours.getOffset((long) (-14));
      
      // When the offset is converted to a long integer
      long offsetLong = (long) offset;
      
      // Then the resulting long integer should be -50400000
      assertEquals(-50400000, offsetLong);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNameKeyReturningNull() throws Throwable  {
      // Create a DateTimeZone for an offset of 406 milliseconds
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(406);
      
      // Get the name key for the DateTimeZone
      String nameKey = forOffsetMillis.getNameKey(406);
      
      // Assert that the name key is equal to "+00:00:00.406"
      assertEquals("+00:00:00.406", nameKey);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNameKeyReturningNonEmptyString() throws Throwable  {
      // No Comments were added
      SimpleTimeZone arg0 = new SimpleTimeZone(86399999, "NET");
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      String nameKey = forTimeZone.getNameKey(576117000005L);
      assertEquals("YERST", nameKey);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMillisKeepLocalReturningNegative() throws Throwable  {
      // Given a DateTimeZone for an offset of 1 hour and 1 minute
      DateTimeZone arg0 = DateTimeZone.forOffsetHoursMinutes(1, 1);
      
      // When the getMillisKeepLocal method is called with a negative timestamp (-2518L)
      long result = arg0.getMillisKeepLocal(arg0, (-2518L));
      
      // Then the expected ID "+01:01" should be returned
      assertEquals("+01:01", arg0.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetID() throws Throwable  {
      // Given a TimeZone object "PLT"
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      
      // When the DateTimeZone class is instantiated with the TimeZone object
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      
      // Then the ID of the corresponding DateTimeZone is "Asia/Karachi"
      String iD = forTimeZone.getID();
      assertEquals("Asia/Karachi", iD);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsReturningTrue() throws Throwable  {
      // Create a DateTimeZone object with an offset of 1 hour
      DateTimeZone arg0 = DateTimeZone.forOffsetHours(1);
      
      // Check that the object is equal to itself
      assertTrue(arg0.equals(arg0));
      
      // Convert the DateTimeZone object to a string and check that it matches the expected value
      assertEquals("+01:00", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsReturningFalse() throws Throwable  {
      // Given a DateTimeZone with an offset of 1573 milliseconds
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(1573);
      
      // When we call equals on this object with another object
      Object arg0 = new Object();
      boolean result = forOffsetMillis.equals(arg0);
      
      // Then the result should be false
      assertFalse(result);
      
      // And the ID of the DateTimeZone should be "+00:00:01.573"
      assertEquals("+00:00:01.573", forOffsetMillis.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertUTCToLocalReturningNegative() throws Throwable  {
      // Given a date and time in UTC
      Instant instant = new Instant();
      
      // When the UTC time is converted to the local time zone
      DateTimeZone zone = instant.getZone();
      long convertUTCToLocal = zone.convertUTCToLocal((-398L));
      
      // Then the result should be the same as the input
      assertEquals((-398L), convertUTCToLocal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertLocalToUTCTaking3ArgumentsReturningPositive() throws Throwable  {
      // Given a DateTimeZone with an offset of 44 milliseconds
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(44);
      
      // When converting a local time of 307 milliseconds to UTC
      long convertLocalToUTC = forOffsetMillis.convertLocalToUTC(307L, false, (-1L));
      
      // Then the result is 263 milliseconds in UTC
      assertEquals(263L, convertLocalToUTC);
      
      // And the ID of the DateTimeZone is "+00:00:00.044"
      assertEquals("+00:00:00.044", forOffsetMillis.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertLocalToUTCTaking2ArgumentsReturningZero() throws Throwable  {
      // Given a DateTimeZone with an offset of 59 milliseconds
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(59);
      
      // When the local time is converted to UTC
      long convertLocalToUTC = forOffsetMillis.convertLocalToUTC((long) 59, true);
      
      // Then the resulting UTC time should be zero
      assertEquals("+00:00:00.059", forOffsetMillis.toString());
      assertEquals(0L, convertLocalToUTC);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertLocalToUTCTaking2ArgumentsReturningNegative() throws Throwable  {
      // Given a DateTimeZone instance with an offset of 1 hour and 1 minute
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 1);
      
      // When converting the local time to UTC
      long convertLocalToUTC = forOffsetHoursMinutes.convertLocalToUTC((long) 1, false);
      
      // Then we expect the converted value to be -3659999 and the ID to be "+01:01"
      assertEquals((-3659999L), convertLocalToUTC);
      assertEquals("+01:01", forOffsetHoursMinutes.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetMillisAndGetShortNameTaking2Arguments() throws Throwable  {
      // Given a DateTimeZone with an offset of 59 milliseconds
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(59);
      
      // When we get the short name of the DateTimeZone with the specified offset and locale
      String shortName = forOffsetMillis.getShortName((long) (-271), (Locale) null);
      
      // Then we expect the short name to be "+00:00:00.059"
      assertEquals("+00:00:00.059", shortName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetShortNameTaking2Arguments() throws Throwable  {
      // Given a FixedDateTimeZone instance with the UTC time zone
      FixedDateTimeZone fixedDateTimeZone = (FixedDateTimeZone) DateTimeZone.UTC;
      
      // When we call getShortName with a negative offset and null locale
      String shortName = fixedDateTimeZone.getShortName(-2326L, null);
      
      // Then the result should be "+00:00"
      assertEquals("+00:00", shortName);
      
      // And the name should not be null
      assertNotNull(shortName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutes() throws Throwable  {
      // No Comments were added
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes((-19), (-19));
      assertEquals("-19:19", forOffsetHoursMinutes.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForIDThrowsIllegalArgumentException() throws Throwable  {
      // Undeclared exception!
      try {
      // Create a DateTimeZone object from the specified ID, which is expected to be in the format of "yyyy-MM-dd HH:mm:ss".
      DateTimeZone.forID("eG4A4u7NLA~v&zw");
      
      // Fail the test if an exception was not thrown.
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      //
      // The datetime zone id 'eG4A4u7NLA~v&zw' is not recognised
      //
      verifyException("org.joda.time.DateTimeZone", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAdjustOffsetAndForTimeZoneAndAdjustOffsetWithTrue0() throws Throwable  {
      // Given a time zone with a certain offset
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      
      // When the time is adjusted for that time zone
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      long adjustOffset = forTimeZone.adjustOffset(1257011999999L, true);
      
      // Then the adjusted time should be equal to a certain value
      assertEquals(1257015599999L, adjustOffset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAdjustOffsetAndForTimeZoneAndAdjustOffsetWithTrue1() throws Throwable  {
      // Given the time zone "PLT" is provided as a parameter to the method.
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      
      // When the method "DateTimeZone.forTimeZone(arg0)" is called with the given time zone.
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      
      // Then the method should return a date-time zone object that corresponds to the given time zone.
      assertNotNull(forTimeZone);
      
      // Given the argument "1257015599999L" is provided to the method "adjustOffset".
      long adjustOffset = forTimeZone.adjustOffset(1257015599999L, true);
      
      // Then the method should return the adjusted offset for the given time zone.
      assertEquals(1257015599999L, adjustOffset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAdjustOffsetAndForTimeZoneAndAdjustOffsetWithFalse0() throws Throwable  {
      // Given a time zone "PLT"
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      
      // When we get the DateTimeZone for the time zone
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      
      // And we adjust the offset of a given timestamp (1257015599999L) in the time zone
      long adjustOffset = forTimeZone.adjustOffset(1257015599999L, false);
      
      // Then the result should be the adjusted offset (1257011999999L)
      assertEquals(1257011999999L, adjustOffset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAdjustOffsetAndForTimeZoneAndAdjustOffsetWithTrue2() throws Throwable  {
      // Given: a TimeZone object representing a specific time zone
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      
      // When: we use the DateTimeZone class to create a DateTimeZone object for the given TimeZone
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      
      // Then: we assert that the adjustOffset method returns the correct offset for a given long value, in this case 9223372036854775807L
      assertEquals(9223372036854775807L, forTimeZone.adjustOffset(9223372036854775807L, true));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAdjustOffsetAndForTimeZoneAndAdjustOffsetWithFalse1() throws Throwable  {
      // Test that the adjustOffset method returns the correct offset for a given timestamp.
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      long actualOffset = forTimeZone.adjustOffset(1257011999999L, false);
      assertEquals(1257011999999L, actualOffset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAdjustOffsetReturningNegative() throws Throwable  {
      // Given a time zone with an offset of -9223372036854775788L
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      
      // When adjusting the offset with the "adjustOffset" method
      long adjustOffset = forTimeZone.adjustOffset((-9223372036854775788L), true);
      
      // Then the result should be -9223372036854775788L
      assertEquals((-9223372036854775788L), adjustOffset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsLocalDateTimeGap() throws Throwable  {
      // Arrange
      FixedDateTimeZone fixedDateTimeZone = (FixedDateTimeZone) DateTimeZone.UTC;
      LocalDateTime arg0 = new LocalDateTime((-1103L));
      
      // Act
      boolean localDateTimeGap = fixedDateTimeZone.isLocalDateTimeGap(arg0);
      
      // Assert
      assertFalse(localDateTimeGap);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMillisKeepLocalReturningPositive() throws Throwable  {
      // Set up a FixedDateTimeZone object to represent UTC time zone
      FixedDateTimeZone fixedDateTimeZone = (FixedDateTimeZone)DateTimeZone.UTC;
      
      // Get the milliseconds for a given date and time in UTC time zone,
      // taking into account the local time zone if any. The null value is used as the local time zone.
      long millisKeepLocal = fixedDateTimeZone.UTC.getMillisKeepLocal((DateTimeZone) null, 2792L);
      
      // Assert that the result of getMillisKeepLocal() is equal to the expected value (2792L)
      assertEquals(2792L, millisKeepLocal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertLocalToUTCTaking2ArgumentsThrowsArithmeticException0() throws Throwable  {
      TimeZone arg0 = TimeZone.getTimeZone("Pacific/Auckland");
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      
      try {
      forTimeZone.convertLocalToUTC(-9223372036854775808L, true); // This is the line that we want to test for overflow
      fail("Expecting exception: ArithmeticException");
      } catch (ArithmeticException e) {
      // Subtracting time zone offset caused overflow
      verifyException("org.joda.time.DateTimeZone", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertLocalToUTCTaking2ArgumentsThrowsArithmeticException1() throws Throwable  {
      // No Comments were added
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      // Undeclared exception!
      try { 
        forTimeZone.convertLocalToUTC((-9223372036854775808L), true);
        fail("Expecting exception: ArithmeticException");
      
      } catch(ArithmeticException e) {
         //
         // Subtracting time zone offset caused overflow
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertLocalToUTCTaking2ArgumentsWithFalse() throws Throwable  {
      // Given a time zone, PLT, represented by a TimeZone object
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      
      // When we convert a local date-time to UTC using the DateTimeZone class
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      try {
      // Then we expect an exception to be thrown because subtracting the time zone offset caused overflow
      forTimeZone.convertLocalToUTC((-9223372036854775808L), false);
      fail("Expecting exception: ArithmeticException");
      } catch(ArithmeticException e) {
      // Verify that the correct exception was thrown
      verifyException("org.joda.time.DateTimeZone", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertLocalToUTCTaking2ArgumentsThrowsIllegalArgumentException() throws Throwable  {
      // Create a TimeZone object for CET time zone
      TimeZone arg0 = TimeZone.getTimeZone("CET");
      
      // Convert the current date and time in CET to UTC using Joda-Time's DateTimeZone.forTimeZone() method
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      
      // Try to convert a local timestamp to UTC with an illegal value (-9223372036854775793L)
      try {
      forTimeZone.convertLocalToUTC((-9223372036854775793L), true);
      } catch (IllegalArgumentException e) {
      // Illegal instant due to time zone offset transition (daylight savings time 'gap'): -292275055-05-16T16:47:04.207 (CET)
      verifyException("org.joda.time.DateTimeZone", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertLocalToUTCTaking3ArgumentsReturningNegative() throws Throwable  {
      // Given a time zone "NET" with an offset of 86399999 milliseconds
      SimpleTimeZone arg0 = new SimpleTimeZone(86399999, "NET");
      
      // And a DateTimeZone object representing the same time zone
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      
      // When converting a local timestamp to UTC using the DateTimeZone object
      long convertLocalToUTC = forTimeZone.convertLocalToUTC(1L, false, 576117000005L);
      
      // Then the converted timestamp should be -14399999 milliseconds earlier than the original timestamp
      assertEquals(-14399999L, convertLocalToUTC);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertUTCToLocalThrowsArithmeticException() throws Throwable  {
      // No Comments were added
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      // Undeclared exception!
      try { 
        forTimeZone.convertUTCToLocal(9223372036854775807L);
        fail("Expecting exception: ArithmeticException");
      
      } catch(ArithmeticException e) {
         //
         // Adding time zone offset caused overflow
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertUTCToLocalReturningPositive() throws Throwable  {
      // Given a date time zone with an offset of +01:01
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 1);
      
      // When converting the UTC time -502 to local time using the above date time zone
      long convertUTCToLocal = forOffsetHoursMinutes.convertUTCToLocal((-502L));
      
      // Then the result should be a Unix timestamp in milliseconds (3659498)
      assertEquals(3659498L, convertUTCToLocal);
      
      // And the date time zone's toString() method should return "+01:01"
      assertEquals("+01:01", forOffsetHoursMinutes.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetFromLocalWithPositive() throws Throwable  {
      // Given a TimeZone instance representing "PLT"
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      
      // When we get the DateTimeZone for this TimeZone
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      
      // Then we expect the offset from local time to be equal to 18000000 (5 hours)
      assertEquals(18000000, forTimeZone.getOffsetFromLocal(1807L));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetFromLocalReturningNegative() throws Throwable  {
      // Set up a DateTimeZone object to represent the given offset (-1381)
      DateTimeZone arg0 = DateTimeZone.forOffsetMillis(-1381);
      
      // Create a CachedDateTimeZone object for the given DateTimeZone object
      CachedDateTimeZone forZone = CachedDateTimeZone.forZone(arg0);
      
      // Get the offset from local time of the given DateTimeZone object
      int offsetFromLocal = forZone.getOffsetFromLocal(-1381);
      
      // Assert that the expected offset (-1381) is equal to the actual offset returned by the getOffsetFromLocal method
      assertEquals(-1381, offsetFromLocal);
      
      // Assert that the string representation of the CachedDateTimeZone object matches the expected value "-00:00:01.381"
      assertEquals("-00:00:01.381", forZone.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForTimeZoneAndGetOffsetFromLocal0() throws Throwable  {
      // Given a time zone Pacific/Auckland
      TimeZone arg0 = TimeZone.getTimeZone("Pacific/Auckland");
      
      // When we get the DateTimeZone for this time zone
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      
      // Then the offset from local should be 43200000 (which is the offset for Pacific/Auckland)
      assertEquals(43200000, forTimeZone.getOffsetFromLocal((-9223372036854775808L)));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForTimeZoneAndGetOffsetFromLocal1() throws Throwable  {
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      // Get the offset from local time zone for a given timestamp
      int offsetFromLocal = forTimeZone.getOffsetFromLocal((-9223372036854775764L));
      assertEquals(16092000, offsetFromLocal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForTimeZoneAndGetOffsetFromLocal2() throws Throwable  {
      // This test case verifies that the offset from local time is calculated correctly for a given time zone.
      
      TimeZone arg0 = TimeZone.getTimeZone("Asia/Tokyo");
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      int offsetFromLocal = forTimeZone.getOffsetFromLocal((-9223372036854775808L));
      
      assertEquals(32400000, offsetFromLocal); // The expected offset is 32400000 milliseconds (or 1 hour).
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetFromLocalReturningZero() throws Throwable  {
      // Arrange
      String zoneId = "Etc/UTC";
      
      // Act
      DateTimeZone arg0 = DateTimeZone.forID(zoneId);
      CachedDateTimeZone forZone = CachedDateTimeZone.forZone(arg0);
      int offsetFromLocal = forZone.getOffsetFromLocal(-634L);
      
      // Assert
      assertEquals("Etc/UTC", forZone.toString());
      assertEquals(0, offsetFromLocal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsStandardOffsetReturningFalse() throws Throwable  {
      // Given a time zone object for "CET"
      TimeZone arg0 = TimeZone.getTimeZone("CET");
      
      // When we get the DateTimeZone object for the time zone using the forTimeZone method
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      
      // Then we expect the isStandardOffset method to return false
      assertFalse(forTimeZone.isStandardOffset(9223372036854775807L));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetTakingReadableInstantReturningNegative() throws Throwable  {
      // Given a date-time zone with an offset of -2442 milliseconds
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(-2442);
      
      // When we create a GJChronology instance with UTC as the time zone
      GJChronology instanceUTC = GJChronology.getInstanceUTC();
      
      // And we use the GJChronology instance to get the Gregorian cutover date
      Instant arg0 = instanceUTC.getGregorianCutover();
      
      // Then the offset for the given date-time zone should be -2442 milliseconds
      int offset = forOffsetMillis.getOffset((ReadableInstant) arg0);
      assertEquals(-2442, offset);
      
      // And the ID of the date-time zone with the offset should be "-00:00:02.442"
      assertEquals("-00:00:02.442", forOffsetMillis.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetName() throws Throwable  {
      // Given a DateTimeZone for offset hours and minutes
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 59);
      
      // When the name of the time zone is obtained using the specified parameters
      String name = forOffsetHoursMinutes.getName(18000000L, (Locale) null);
      
      // Then the name should be "+01:59"
      assertEquals("+01:59", name);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetMillis() throws Throwable  {
      // Test that the DateTimeZone can handle a negative offset of 1256000 milliseconds, which corresponds to -00:20:56.
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis((-1256000));
      assertEquals("-00:20:56", forOffsetMillis.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetNameProviderWithNonNull() throws Throwable  {
      // Given a DefaultNameProvider instance
      DefaultNameProvider nameProvider = new DefaultNameProvider();
      
      // When setting the name provider on DateTimeZone
      DateTimeZone.setNameProvider(nameProvider);
      
      // Then the name provider should be set correctly
      assertEquals(nameProvider, DateTimeZone.getNameProvider());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetNameProviderWithNull() throws Throwable  {
      // No Comments were added
      DateTimeZone.setNameProvider((NameProvider) null);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetProvider() throws Throwable  {
      // Given: The DateTimeZone class has a static method setProvider() that allows
      // setting the provider for all future DateTimeZone objects.
      
      // When: We call the setProvider() method with a null argument, indicating
      // that we want to use the default provider instead of any custom one.
      DateTimeZone.setProvider((Provider) null);
      
      // Then: The default provider should be used for all future DateTimeZone objects.
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetMillisWithZero() throws Throwable  {
      // Given a date and time in UTC, create a new DateTimeZone object with the same offset as UTC
      // When we call the forOffsetMillis method with an argument of 0 (UTC)
      DateTimeZone utcDateTimeZone = DateTimeZone.forOffsetMillis(0);
      
      // Then the resulting DateTimeZone object should have the same offset as UTC, which is 0 milliseconds
      assertEquals("UTC", utcDateTimeZone.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursWithNegative() throws Throwable  {
      // rollbacked to evosuite
      DateTimeZone forOffsetHours = DateTimeZone.forOffsetHours((-14));
      TimeZone arg0 = forOffsetHours.toTimeZone();
      DateTimeZone.forTimeZone(arg0);
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      assertSame(forTimeZone, forOffsetHours);
      assertEquals("-14:00", forOffsetHours.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursWithPositive() throws Throwable  {
      // Test that the DateTimeZone object is created correctly using the forOffsetHours method
      DateTimeZone forOffsetHours = DateTimeZone.forOffsetHours(1);
      assertNotNull(forOffsetHours);
      
      // Test that the toTimeZone method returns a valid TimeZone object
      TimeZone arg0 = forOffsetHours.toTimeZone();
      assertNotNull(arg0);
      
      // Test that the DateTimeZone object can be converted back to a TimeZone object and still represents the same time zone
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      assertEquals(forOffsetHours, forTimeZone);
      
      // Test that the ID of the TimeZone is correct
      assertEquals("+01:00", arg0.getID());
      
      // Test that the ID of the DateTimeZone is correct
      assertEquals("+01:00", forOffsetHours.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForTimeZoneThrowsIllegalArgumentException() throws Throwable  {
      SimpleTimeZone arg0 = new SimpleTimeZone(43, "UTC+01:00");
      try {
      DateTimeZone.forTimeZone(arg0);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // The datetime zone id 'UTC+01:00' is not recognised
      verifyException("org.joda.time.DateTimeZone", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToTimeZoneReturningTimeZoneWhereGetRawOffsetIsZero() throws Throwable  {
      // Given a FixedDateTimeZone instance and a TimeZone object
      FixedDateTimeZone fixedDateTimeZone = (FixedDateTimeZone)DateTimeZone.UTC;
      TimeZone arg0 = fixedDateTimeZone.toTimeZone();
      
      // When converting the TimeZone to a DateTimeZone using DateTimeZone.forTimeZone() method
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      
      // Then assert that the resulting DateTimeZone is equal to the original FixedDateTimeZone instance
      assertSame(fixedDateTimeZone, forTimeZone);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForTimeZoneWithNull() throws Throwable  {
      // Given a time zone object, construct a DateTimeZone using the forTimeZone method
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone((TimeZone) null);
      
      // When we call toString on the resulting DateTimeZone object
      String result = forTimeZone.toString();
      
      // Then the string representation should be "Etc/UTC"
      assertEquals("Etc/UTC", result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetMillisThrowsIllegalArgumentExceptionAndForOffsetMillisWithPositive() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateTimeZone.forOffsetMillis(123456789);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Millis out of range: 123456789
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetMillisThrowsIllegalArgumentExceptionAndForOffsetMillisWithNegative() throws Throwable  {
      // Given the Joda-Time DateTimeZone class and a test value of -2147483060 for offset milliseconds,
      // when the forOffsetMillis method is called with this value,
      // then an IllegalArgumentException should be thrown.
      try {
      // When
      DateTimeZone.forOffsetMillis((-2147483060));
      
      // Then
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify the expected exception message
      verifyException("org.joda.time.DateTimeZone", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesThrowsIllegalArgumentException0() throws Throwable  {
      // No Comments were added
      try { 
        DateTimeZone.forOffsetHoursMinutes((byte)14, (byte) (-59));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Positive hours must not have negative minutes: -59
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesWithZeroAndForOffsetHoursMinutesThrowsIllegalArgumentException() throws Throwable  {
      try {
      // Create a DateTimeZone instance for an offset of 0 hours and 1000 minutes
      DateTimeZone.forOffsetHoursMinutes(0, 1000);
      
      // Fail the test with IllegalArgumentException if it was not thrown
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Verify that the correct exception was thrown
      verifyException("org.joda.time.DateTimeZone", e);
      
      // Check the error message to ensure it matches the expected value
      assertEquals("Minutes out of range: 1000", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesThrowsIllegalArgumentException1() throws Throwable  {
      // No Comments were added
      try { 
        DateTimeZone.forOffsetHoursMinutes(3, (-2147483646));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Minutes out of range: -2147483646
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesWithPositive() throws Throwable  {
      // No Comments were added
      try { 
        DateTimeZone.forOffsetHoursMinutes(809, 1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Hours out of range: 809
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesWithNegative() throws Throwable  {
      try {
      // Try to create a DateTimeZone with hours and minutes that are out of range
      DateTimeZone.forOffsetHoursMinutes((-1381), (-1381));
      
      // If the above line does not throw an IllegalArgumentException, fail the test
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Verify that the thrown exception is of type IllegalArgumentException
      verifyException("org.joda.time.DateTimeZone", e);
      
      // Assert that the error message contains the expected information
      assertTrue(e.getMessage().contains("Hours out of range: -1381"));}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesWithZeroAndForOffsetHoursMinutes() throws Throwable  {
      // Creating a DateTimeZone with an offset of 0 hours and 0 minutes
      DateTimeZone dateTimeZone = DateTimeZone.forOffsetHoursMinutes(0, 0);
      
      // Asserting that the ID of the created DateTimeZone is "UTC"
      assertEquals("UTC", dateTimeZone.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForID0() throws Throwable  {
      // Given a DateTimeZone with an ID of "-22:00"
      DateTimeZone forID = DateTimeZone.forID("-22:00");
      
      // When the toString method is called on the DateTimeZone object
      String result = forID.toString();
      
      // Then the result should be the same as the ID passed in
      assertEquals("-22:00", result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForID1() throws Throwable  {
      // Test that a DateTimeZone with ID "UTC" is fixed
      DateTimeZone forID = DateTimeZone.forID("UTC");
      assertTrue(forID.isFixed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsStandardOffsetReturningTrue() throws Throwable  {
      // No Comments were added
      DateTimeZone forID = DateTimeZone.forID((String) null);
      boolean standardOffset = forID.UTC.isStandardOffset(1L);
      assertTrue(standardOffset);
      assertEquals("Etc/UTC", forID.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetDefault() throws Throwable  {
      // Set the default DateTimeZone to Etc/UTC
      DateTimeZone arg0 = DateTimeZone.forID("Etc/UTC");
      DateTimeZone.setDefault(arg0);
      
      // Assert that the default DateTimeZone is set correctly
      assertEquals("Etc/UTC", arg0.toString());
      assertEquals("Etc/UTC", arg0.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetDefaultThrowsIllegalArgumentException() throws Throwable  {
      // The datetime zone must not be null
      try {
      DateTimeZone.setDefault((DateTimeZone) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      verifyException("org.joda.time.DateTimeZone", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForID2() throws Throwable  {
      // Test that the "forID" method returns a DateTimeZone object with the expected ID.
      DateTimeZone testZone = DateTimeZone.forID("+00:00");
      assertEquals("UTC", testZone.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDefault() throws Throwable  {
      // Get the default DateTimeZone object
      DateTimeZone arg0 = DateTimeZone.getDefault();
      
      // Create a CachedDateTimeZone object from the default DateTimeZone
      CachedDateTimeZone forZone = CachedDateTimeZone.forZone(arg0);
      
      // Convert the CachedDateTimeZone to a TimeZone object
      TimeZone timeZone = forZone.toTimeZone();
      
      // Assert that the ID of the created TimeZone is "Etc/UTC"
      assertEquals("Etc/UTC", timeZone.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetProvider() throws Throwable  {
      // rollbacked to evosuite
      Provider provider = DateTimeZone.getProvider();
      assertNotNull(provider);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForID3() throws Throwable  {
      // Given a time zone with the ID "America/Los_Angeles"
      DateTimeZone forID = DateTimeZone.forID("America/Los_Angeles");
      
      // When the method forID is called with the argument "America/Los_Angeles"
      String result = forID.getID();
      
      // Then the ID of the time zone should be returned
      assertEquals("America/Los_Angeles", result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNameProvider() throws Throwable  {
      // No Comments were added
      NameProvider nameProvider = DateTimeZone.getNameProvider();
      assertNotNull(nameProvider);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetAvailableIDs() throws Throwable  {
      // Given: The system has a list of available time zones with IDs
      Set<String> availableIDs = DateTimeZone.getAvailableIDs();
      
      // When: We check if the list is empty
      boolean isEmpty = availableIDs.isEmpty();
      
      // Then: We assert that the list is not empty, indicating that there are available time zones
      assertFalse(isEmpty);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWriteReplace() throws Throwable  {
      // Given a FixedDateTimeZone object
      FixedDateTimeZone fixedDateTimeZone = (FixedDateTimeZone) DateTimeZone.UTC;
      
      // When the writeReplace method is called on the FixedDateTimeZone object
      Object writeReplace = ((DateTimeZone)fixedDateTimeZone).writeReplace();
      
      // Then we expect the writeReplace method to return a non-null value
      assertNotNull(writeReplace);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetShortNameTakingLong() throws Throwable  {
      // Given a DateTimeZone for an offset of -12 hours
      DateTimeZone forOffsetHours = DateTimeZone.forOffsetHours((-12));
      
      // When the short name is requested with the offset
      String shortName = forOffsetHours.getShortName((long) (-12));
      
      // Then the short name should be "-12:00"
      assertEquals("-12:00", shortName);
  }
}
