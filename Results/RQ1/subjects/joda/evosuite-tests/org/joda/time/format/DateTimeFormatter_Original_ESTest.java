/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 09:27:34 GMT 2024
 */

package org.joda.time.format;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.Writer;
import java.util.Locale;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeFieldType;
import org.joda.time.DateTimeZone;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import org.joda.time.MutableDateTime;
import org.joda.time.Partial;
import org.joda.time.ReadWritableInstant;
import org.joda.time.ReadableInstant;
import org.joda.time.ReadablePartial;
import org.joda.time.chrono.ISOChronology;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.DateTimeFormatterBuilder;
import org.joda.time.format.DateTimeParser;
import org.joda.time.format.DateTimePrinter;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class DateTimeFormatter_Original_ESTest extends DateTimeFormatter_Original_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneUTCReturningDateTimeFormatterWhereGetDefaultYearIsZero() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(0);
      DateTimeFormatter withZoneUTC = withDefaultYear.withZoneUTC();
      assertFalse(withDefaultYear.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(withZoneUTC.isOffsetParsed());
      assertNotSame(withZoneUTC, withDefaultYear);
      assertEquals(0, withZoneUTC.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneUTCReturningDateTimeFormatterWhereGetDefaultYearIsNegative() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.weekOfWeekyear();
      DateTimeFormatterBuilder.PaddedNumber arg1 = new DateTimeFormatterBuilder.PaddedNumber(arg0, (-2098), false, (-2098));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear((-2098));
      DateTimeFormatter withZoneUTC = withDefaultYear.withZoneUTC();
      assertEquals((-2098), withZoneUTC.getDefaultYear());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals((-2098), withDefaultYear.getDefaultYear());
      assertFalse(withZoneUTC.isOffsetParsed());
      assertNotSame(withZoneUTC, withDefaultYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      DateTimeZone arg0 = DateTimeZone.getDefault();
      DateTimeFormatter withZone = dateTimeFormatter.withZone(arg0);
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, withZone.getDefaultYear());
      assertFalse(withZone.isOffsetParsed());
      assertNotSame(withZone, dateTimeFormatter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneReturningDateTimeFormatterWhereIsOffsetParsedIsTrue() throws Throwable  {
      LocalTime arg0 = new LocalTime();
      Partial partial = new Partial(arg0);
      DateTimeFormatter formatter = partial.getFormatter();
      DateTimeFormatter withOffsetParsed = formatter.withOffsetParsed();
      DateTimeFormatter withZone = withOffsetParsed.withZone((DateTimeZone) null);
      assertEquals(2000, withZone.getDefaultYear());
      assertFalse(formatter.isOffsetParsed());
      assertTrue(withZone.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneReturningDateTimeFormatterWhereGetDefaultYearIsZero() throws Throwable  {
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('j');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(0);
      DateTimeZone arg0 = DateTimeZone.forOffsetHours(0);
      DateTimeFormatter withZone = withDefaultYear.withZone(arg0);
      assertFalse(withDefaultYear.isOffsetParsed());
      assertEquals(0, withZone.getDefaultYear());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertNotSame(withZone, withDefaultYear);
      assertFalse(withZone.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPivotYearTakingIntegerReturningDateTimeFormatterWhereIsOffsetParsedIsTrue() throws Throwable  {
      DateTimeFormat.StyleFormatter arg1 = new DateTimeFormat.StyleFormatter((-1308), 1, (-1308));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      Integer arg0 = new Integer(1);
      DateTimeFormatter withPivotYear = withOffsetParsed.withPivotYear(arg0);
      assertTrue(withOffsetParsed.isOffsetParsed());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertNotSame(withPivotYear, withOffsetParsed);
      assertEquals(2000, withPivotYear.getDefaultYear());
      assertEquals(2000, withOffsetParsed.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithDefaultYearAndWithPivotYearTakingInteger() throws Throwable  {
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('M');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear((-2029));
      DateTimeFormatter withPivotYear = withDefaultYear.withPivotYear((Integer) null);
      assertEquals((-2029), withPivotYear.getDefaultYear());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(withPivotYear.isOffsetParsed());
      assertSame(withPivotYear, withDefaultYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPivotYearTakingIntReturningDateTimeFormatterWhereIsOffsetParsedIsTrue() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Pricting no supported");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      DateTimeFormatter withPivotYear = withOffsetParsed.withPivotYear(0);
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertTrue(withOffsetParsed.isOffsetParsed());
      assertEquals(2000, withPivotYear.getDefaultYear());
      assertEquals(0, (int)withPivotYear.getPivotYear());
      assertNotSame(withPivotYear, withOffsetParsed);
      assertEquals(2000, withOffsetParsed.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPivotYearTakingIntReturningDateTimeFormatterWhereGetDefaultYearIsZero() throws Throwable  {
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('j');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(0);
      DateTimeFormatter withPivotYear = withDefaultYear.withPivotYear((-1164));
      assertEquals((-1164), (int)withPivotYear.getPivotYear());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(withDefaultYear.isOffsetParsed());
      assertNotSame(withPivotYear, withDefaultYear);
      assertEquals(0, withPivotYear.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithOffsetParsedReturningDateTimeFormatterWhereGetDefaultYearIsZero() throws Throwable  {
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('j');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(0);
      DateTimeFormatter withOffsetParsed = withDefaultYear.withOffsetParsed();
      assertEquals(0, withOffsetParsed.getDefaultYear());
      assertNotSame(withOffsetParsed, withDefaultYear);
      assertTrue(withOffsetParsed.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithLocaleReturningDateTimeFormatterWhereIsOffsetParsedIsTrue() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("org.joda.time.format.DateTimeFormatter");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      Locale arg0 = Locale.CHINESE;
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      DateTimeFormatter withLocale = withOffsetParsed.withLocale(arg0);
      assertTrue(withOffsetParsed.isOffsetParsed());
      assertEquals(2000, withLocale.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertNotSame(withLocale, withOffsetParsed);
      assertEquals(2000, withOffsetParsed.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithLocaleReturningDateTimeFormatterWhereGetDefaultYearIsZero() throws Throwable  {
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('j');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, arg1);
      Locale arg0 = Locale.CANADA_FRENCH;
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(0);
      DateTimeFormatter withLocale = withDefaultYear.withLocale(arg0);
      assertEquals(0, withLocale.getDefaultYear());
      assertFalse(withDefaultYear.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertNotSame(withLocale, withDefaultYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithLocaleReturningDateTimeFormatterWhereGetDefaultYearIsNegative() throws Throwable  {
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('M');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear((-2029));
      Locale arg0 = Locale.KOREAN;
      DateTimeFormatter withLocale = withDefaultYear.withLocale(arg0);
      assertEquals((-2029), withDefaultYear.getDefaultYear());
      assertNotSame(withLocale, withDefaultYear);
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertEquals((-2029), withLocale.getDefaultYear());
      assertFalse(withDefaultYear.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithDefaultYearReturningDateTimeFormatterWhereIsOffsetParsedIsTrue() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      DateTimeFormatter withDefaultYear = withOffsetParsed.withDefaultYear(0);
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, withOffsetParsed.getDefaultYear());
      assertEquals(0, withDefaultYear.getDefaultYear());
      assertTrue(withOffsetParsed.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithChronologyReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      DateTimeFormatter withChronology = dateTimeFormatter.withChronology((Chronology) null);
      assertSame(withChronology, dateTimeFormatter);
      assertEquals(2000, withChronology.getDefaultYear());
      assertFalse(withChronology.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithChronologyReturningDateTimeFormatterWhereIsOffsetParsedIsTrue() throws Throwable  {
      DateTimeFormat.StyleFormatter arg1 = new DateTimeFormat.StyleFormatter((-1308), 1, (-1308));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      DateTimeFormatter withChronology = withOffsetParsed.withChronology((Chronology) null);
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, withChronology.getDefaultYear());
      assertTrue(withChronology.isOffsetParsed());
      assertSame(withChronology, withOffsetParsed);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintTakingLongReturningEmptyString() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneName arg1 = new DateTimeFormatterBuilder.TimeZoneName(1946, (Map<String, DateTimeZone>) null);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.print((long) 2147198495);
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMutableDateTimeReturningMutableDateTimeWhereGetMillisIsPositive() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      MutableDateTime parseMutableDateTime = dateTimeFormatter.parseMutableDateTime("HST");
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(36000000L, parseMutableDateTime.getMillis());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZone() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("");
      DateTimeZone arg0 = DateTimeZone.forOffsetMillis(4);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withZone = dateTimeFormatter.withZone(arg0);
      MutableDateTime parseMutableDateTime = withZone.parseMutableDateTime("");
      assertEquals((-4L), parseMutableDateTime.getMillis());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertFalse(withZone.isOffsetParsed());
      assertEquals(2000, withZone.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMillisReturningPositive() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      long parseMillis = dateTimeFormatter.parseMillis("HST");
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(36000000L, parseMillis);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateTimeReturningDateTimeWhereGetMillisIsPositive() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTime parseDateTime = dateTimeFormatter.parseDateTime("HST");
      assertEquals(36000000L, parseDateTime.getMillis());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetZoneReturningNonNull() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.weekOfWeekyear();
      DateTimeFormatterBuilder.PaddedNumber arg1 = new DateTimeFormatterBuilder.PaddedNumber(arg0, (-2098), false, (-2098));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withZoneUTC = dateTimeFormatter.withZoneUTC();
      DateTimeZone zone = withZoneUTC.getZone();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertFalse(withZoneUTC.isOffsetParsed());
      assertNotNull(zone);
      assertEquals(2000, withZoneUTC.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPrinterReturningNull() throws Throwable  {
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      dateTimeFormatter.getPrinter();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPrinterReturningDateTimePrinterWhereEstimatePrintedLengthIsZero() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.hourOfDay();
      DateTimeFormatterBuilder.FixedNumber arg1 = new DateTimeFormatterBuilder.FixedNumber(arg0, 0, true);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getPrinter();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPrinterReturningDateTimePrinterWhereEstimatePrintedLengthIsPositive() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.weekOfWeekyear();
      DateTimeFormatterBuilder.FixedNumber arg1 = new DateTimeFormatterBuilder.FixedNumber(arg0, 23118750, false);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getPrinter();
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPrinterReturningDateTimePrinterWhereEstimatePrintedLengthIsNegative() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.millisOfDay();
      DateTimeFormatterBuilder.Fraction arg1 = new DateTimeFormatterBuilder.Fraction(arg0, (-36), (-36));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getPrinter();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPivotYearReturningPositive() throws Throwable  {
      DateTimeFormat.StyleFormatter arg1 = new DateTimeFormat.StyleFormatter((-1308), 1, (-1308));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      Integer arg0 = new Integer(1);
      DateTimeFormatter withPivotYear = dateTimeFormatter.withPivotYear(arg0);
      Integer pivotYear = withPivotYear.getPivotYear();
      assertFalse(withPivotYear.isOffsetParsed());
      assertEquals(2000, withPivotYear.getDefaultYear());
      assertNotNull(pivotYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetParserReturningNull() throws Throwable  {
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      dateTimeFormatter.getParser();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetParserReturningDateTimeParserWhereEstimateParsedLengthIsZero() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.hourOfDay();
      DateTimeFormatterBuilder.FixedNumber arg1 = new DateTimeFormatterBuilder.FixedNumber(arg0, 0, true);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getParser();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetParserReturningDateTimeParserWhereEstimateParsedLengthIsPositive() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getParser();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetParserReturningDateTimeParserWhereEstimateParsedLengthIsNegative() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.weekOfWeekyear();
      DateTimeFormatterBuilder.PaddedNumber arg1 = new DateTimeFormatterBuilder.PaddedNumber(arg0, (-2098), false, (-2098));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getParser();
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLocaleReturningNonNull() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("org.joda.time.format.DateTimeFormatter");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      Locale arg0 = Locale.CHINESE;
      DateTimeFormatter withLocale = dateTimeFormatter.withLocale(arg0);
      Locale locale = withLocale.getLocale();
      assertNotNull(locale);
      assertFalse(withLocale.isOffsetParsed());
      assertEquals(2000, withLocale.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDefaultYearReturningZero() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(0);
      int defaultYear = withDefaultYear.getDefaultYear();
      assertFalse(withDefaultYear.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertEquals(0, defaultYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDefaultYearReturningNegative() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.monthOfYear();
      DateTimeFormatterBuilder.PaddedNumber arg1 = new DateTimeFormatterBuilder.PaddedNumber(arg0, (-2098), false, (-2098));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear((-2098));
      int defaultYear = withDefaultYear.getDefaultYear();
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertEquals((-2098), defaultYear);
      assertFalse(withDefaultYear.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPivotYearTakingIntegerReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      Integer arg0 = Integer.valueOf((-1185));
      DateTimeFormatter withPivotYear = dateTimeFormatter.withPivotYear(arg0);
      assertEquals(2000, withPivotYear.getDefaultYear());
      assertNotSame(withPivotYear, dateTimeFormatter);
      assertFalse(withPivotYear.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintTakingLongReturningNonEmptyString() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.print((-554L));
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking1And1ThrowsNullPointerException() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.printTo((StringBuffer) null, (-1L));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder$StringLiteral", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintTakingReadablePartial() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Parsing not supportd");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      LocalDateTime arg0 = dateTimeFormatter.parseLocalDateTime("Parsing not supportd");
      dateTimeFormatter.print((ReadablePartial) arg0);
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLocaleReturningNull() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("org.joda.time.format.DateTimeFormatter");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getLocale();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesDateTimeFormatter() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg0 = new DateTimeFormatterBuilder.StringLiteral("org.joda.time.format.DateTimeFormatterBuilder$Fraction");
      DateTimeFormatter arg1 = new DateTimeFormatter(arg0, (DateTimeParser) null);
      // Undeclared exception!
      try { 
        LocalDateTime.parse("org.joda.time.format.DateTimeFormatterBuilder$Fraction", arg1);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Parsing not supported
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMutableDateTimeReturningMutableDateTimeWhereGetMillisIsZero() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("X/U}c+ERsKCC@Z%i");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      MutableDateTime parseMutableDateTime = withOffsetParsed.parseMutableDateTime("X/U}c+ERsKCC@Z%i");
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertTrue(withOffsetParsed.isOffsetParsed());
      assertEquals(2000, withOffsetParsed.getDefaultYear());
      assertEquals(0L, parseMutableDateTime.getMillis());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMutableDateTimeWithNonEmptyString() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.parseMutableDateTime("Pursing not+supzorted");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \"Pursing not+supzorted\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMutableDateTimeWithEmptyString() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.parseMutableDateTime("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \"\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneUTC() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral(")[o(7hxg^");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withZoneUTC = dateTimeFormatter.withZoneUTC();
      DateTime parseDateTime = withZoneUTC.parseDateTime(")[o(7hxg^");
      assertEquals(2000, withZoneUTC.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertNotSame(withZoneUTC, dateTimeFormatter);
      assertFalse(withZoneUTC.isOffsetParsed());
      assertEquals(0L, parseDateTime.getMillis());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateTimeAndWithOffsetParsed() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("X/U}c+ERM3sKCC@Z%i");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      DateTime parseDateTime = withOffsetParsed.parseDateTime("X/U}c+ERM3sKCC@Z%i");
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(0L, parseDateTime.getMillis());
      assertTrue(withOffsetParsed.isOffsetParsed());
      assertEquals(2000, withOffsetParsed.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateTimeReturningDateTimeWhereGetMillisIsNegative() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTime parseDateTime = dateTimeFormatter.parseDateTime("Africa/Harare");
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertEquals((-7200000L), parseDateTime.getMillis());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateTimeThrowsIllegalArgumentException() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.parseDateTime("~1:!]wsd9pJL9.52G");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \"~1:!]wsd9pJL9.52G\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseLocalDateTime() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg0 = new DateTimeFormatterBuilder.StringLiteral("Printing not supported");
      DateTimeFormatterBuilder.TimeZoneOffset arg1 = new DateTimeFormatterBuilder.TimeZoneOffset("Printing not supported", "Printing not supported", true, 2147450109, 2147450109);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg0, arg1);
      dateTimeFormatter.parseLocalDateTime("Printing not supported");
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseLocalDateTimeThrowsIllegalArgumentException() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.parseLocalDateTime(";)[ohxg");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \";)[ohxg\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test0() throws Throwable  {
      // Undeclared exception!
      try { 
        LocalDateTime.parse(")[o(hxg");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \")[o(hxg\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMillisReturningZero() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Instant must not be null");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      long parseMillis = dateTimeFormatter.parseMillis("Instant must not be null");
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertEquals(0L, parseMillis);
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMillisThrowsIllegalArgumentException() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.parseMillis("8Pe");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \"8Pe\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseIntoWithReadWritableInstantWhereGetMillisIsZero() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Printing not supported");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withZoneUTC = dateTimeFormatter.withZoneUTC();
      MutableDateTime arg0 = withZoneUTC.parseMutableDateTime("Printing not supported");
      int parseInto = withZoneUTC.parseInto(arg0, "Printing not supported", 0);
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertFalse(withZoneUTC.isOffsetParsed());
      assertEquals(22, parseInto);
      assertEquals(2000, withZoneUTC.getDefaultYear());
      assertEquals(0L, arg0.getMillis());
      assertNotSame(withZoneUTC, dateTimeFormatter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseInto() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Xg4!");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      MutableDateTime arg0 = MutableDateTime.now();
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      int parseInto = withOffsetParsed.parseInto(arg0, "Xg4!", 0);
      assertEquals(2000, withOffsetParsed.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(1392409281320L, arg0.getMillis());
      assertEquals(4, parseInto);
      assertTrue(withOffsetParsed.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseIntoThrowsIllegalArgumentException() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral(";tfuL&\u0002fg|6qJT\"c8");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.parseInto((ReadWritableInstant) null, ";tfuL&\u0002fg|6qJT\"c8", 1117);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Instant must not be null
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseIntoReturningNegative() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("xU}c[ERsKC@Zi");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      MutableDateTime arg0 = MutableDateTime.now();
      int parseInto = dateTimeFormatter.parseInto(arg0, "xU}c[ERsKC@Zi", 5);
      assertEquals((-6), parseInto);
      assertEquals(1392409281320L, arg0.getMillis());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test1() throws Throwable  {
      MutableDateTime mutableDateTime = null;
      try {
        mutableDateTime = new MutableDateTime(")[o(7hxg^");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \")[o(7hxg^\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithChronologyWithNonNull() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      ISOChronology arg0 = ISOChronology.getInstance();
      DateTimeFormatter withChronology = dateTimeFormatter.withChronology(arg0);
      MutableDateTime parseMutableDateTime = withChronology.parseMutableDateTime("");
      assertNotSame(withChronology, dateTimeFormatter);
      assertEquals(2000, withChronology.getDefaultYear());
      assertEquals(0L, parseMutableDateTime.getMillis());
      assertFalse(withChronology.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithOffsetParsedReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      assertEquals(2000, withOffsetParsed.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertTrue(withOffsetParsed.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithLocaleWithNull() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withLocale = dateTimeFormatter.withLocale((Locale) null);
      assertFalse(withLocale.isOffsetParsed());
      assertEquals(2000, withLocale.getDefaultYear());
      assertSame(withLocale, dateTimeFormatter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsParserReturningTrue() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.era();
      DateTimeFormatterBuilder.Fraction arg1 = new DateTimeFormatterBuilder.Fraction(arg0, (-8), (-8));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      boolean parser = dateTimeFormatter.isParser();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertTrue(parser);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsParserReturningFalse() throws Throwable  {
      DateTimeFormatterBuilder.Fraction arg0 = new DateTimeFormatterBuilder.Fraction((DateTimeFieldType) null, (-1941), 2421);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg0, (DateTimeParser) null);
      boolean parser = dateTimeFormatter.isParser();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertFalse(parser);
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsPrinterReturningTrue() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.millisOfDay();
      DateTimeFormatterBuilder.Fraction arg1 = new DateTimeFormatterBuilder.Fraction(arg0, (-8), (-8));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      boolean printer = dateTimeFormatter.isPrinter();
      assertTrue(printer);
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsPrinterReturningFalse() throws Throwable  {
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('j');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, arg1);
      boolean printer = dateTimeFormatter.isPrinter();
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertFalse(printer);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetZoneReturningNull() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.weekOfWeekyear();
      DateTimeFormatterBuilder.PaddedNumber arg1 = new DateTimeFormatterBuilder.PaddedNumber(arg0, (-2098), false, (-2098));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getZone();
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPivotYearReturningNull() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getPivotYear();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetChronolgy() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.hourOfHalfday();
      DateTimeFormatterBuilder.FixedNumber arg1 = new DateTimeFormatterBuilder.FixedNumber(arg0, 0, false);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getChronolgy();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneUTCReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      DateTimeFormatter withZoneUTC = dateTimeFormatter.withZoneUTC();
      assertFalse(withZoneUTC.isOffsetParsed());
      assertEquals(2000, withZoneUTC.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertNotSame(withZoneUTC, dateTimeFormatter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDefaultYearReturningPositive() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      int defaultYear = dateTimeFormatter.getDefaultYear();
      assertEquals(2000, defaultYear);
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsOffsetParsed() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.era();
      DateTimeFormatterBuilder.Fraction arg1 = new DateTimeFormatterBuilder.Fraction(arg0, (-8), (-8));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      boolean offsetParsed = dateTimeFormatter.isOffsetParsed();
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(offsetParsed);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintTakingReadableInstant() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneName arg1 = new DateTimeFormatterBuilder.TimeZoneName(1946, (Map<String, DateTimeZone>) null);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.print((ReadableInstant) null);
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPivotYearTakingIntReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      DateTimeFormatter withPivotYear = dateTimeFormatter.withPivotYear((-1185));
      assertFalse(withPivotYear.isOffsetParsed());
      assertEquals((-1185), (int)withPivotYear.getPivotYear());
      assertEquals(2000, withPivotYear.getDefaultYear());
      assertNotSame(withPivotYear, dateTimeFormatter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithLocaleReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      Locale arg0 = Locale.PRC;
      DateTimeFormatter withLocale = dateTimeFormatter.withLocale(arg0);
      assertFalse(withLocale.isOffsetParsed());
      assertNotSame(withLocale, dateTimeFormatter);
      assertEquals(2000, withLocale.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking1And1ThrowsUnsupportedOperationException() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.era();
      DateTimeFormatterBuilder.Fraction arg1 = new DateTimeFormatterBuilder.Fraction(arg0, (-518), (-518));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.printTo((Writer) null, (long) (-518));
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Printing not supported
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseLocalDate() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Xg4!");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.parseLocalDate("Xg4!");
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseLocalTime() throws Throwable  {
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Pricting no supported");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.parseLocalTime("Pricting no supported");
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetChronology() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.year();
      Partial partial = new Partial(arg0, 0, (Chronology) null);
      DateTimeFormatter formatter = partial.getFormatter();
      formatter.getChronology();
      assertEquals(2000, formatter.getDefaultYear());
      assertFalse(formatter.isOffsetParsed());
  }
}
