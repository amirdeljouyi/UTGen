/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 08:07:05 GMT 2024
 */

package org.joda.time;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Locale;
import java.util.Set;
import java.util.TimeZone;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.joda.time.DateTimeZone;
import org.joda.time.Instant;
import org.joda.time.LocalDateTime;
import org.joda.time.ReadableInstant;
import org.joda.time.chrono.EthiopicChronology;
import org.joda.time.chrono.GJChronology;
import org.joda.time.tz.CachedDateTimeZone;
import org.joda.time.tz.DefaultNameProvider;
import org.joda.time.tz.FixedDateTimeZone;
import org.joda.time.tz.NameProvider;
import org.joda.time.tz.Provider;
import org.joda.time.tz.UTCProvider;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class DateTimeZone_Original_ESTest extends DateTimeZone_Original_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPreviousTransitionReturningZero() throws Throwable  {
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 59);
      forOffsetHoursMinutes.previousTransition(0L);
      assertEquals("+01:59", forOffsetHoursMinutes.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPreviousTransitionReturningPositive() throws Throwable  {
      FixedDateTimeZone fixedDateTimeZone = (FixedDateTimeZone)DateTimeZone.UTC;
      long previousTransition = fixedDateTimeZone.previousTransition(10800000L);
      assertEquals(10800000L, previousTransition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPreviousTransitionReturningNegative() throws Throwable  {
      Instant instant = new Instant();
      DateTimeZone zone = instant.getZone();
      long previousTransition = zone.previousTransition((-398L));
      assertEquals((-398L), previousTransition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTransitionReturningZero() throws Throwable  {
      FixedDateTimeZone fixedDateTimeZone = (FixedDateTimeZone)DateTimeZone.UTC;
      long nextTransition = fixedDateTimeZone.nextTransition(0L);
      assertEquals(0L, nextTransition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTransitionReturningPositive() throws Throwable  {
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 59);
      forOffsetHoursMinutes.nextTransition(576117000005L);
      assertEquals("+01:59", forOffsetHoursMinutes.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTransitionReturningNegative() throws Throwable  {
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(406);
      forOffsetMillis.nextTransition((-3926L));
      assertEquals("+00:00:00.406", forOffsetMillis.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetStandardOffsetReturningZero() throws Throwable  {
      FixedDateTimeZone fixedDateTimeZone = (FixedDateTimeZone)DateTimeZone.UTC;
      int standardOffset = fixedDateTimeZone.UTC.getStandardOffset(7599840L);
      assertEquals(0, standardOffset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetStandardOffsetReturningNegative() throws Throwable  {
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis((-3336));
      int standardOffset = forOffsetMillis.getStandardOffset((-3336));
      assertEquals((-3336), standardOffset);
      assertEquals("-00:00:03.336", forOffsetMillis.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetTakingReadableInstantReturningPositive() throws Throwable  {
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 59);
      int offset = forOffsetHoursMinutes.getOffset((ReadableInstant) null);
      assertEquals("+01:59", forOffsetHoursMinutes.getID());
      assertEquals(7140000, offset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetTakingLongReturningZero() throws Throwable  {
      Instant instant = new Instant();
      DateTimeZone zone = instant.getZone();
      int offset = zone.getOffset((-398L));
      assertEquals(0, offset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetTakingLongReturningPositive() throws Throwable  {
      DateTimeZone forOffsetHours = DateTimeZone.forOffsetHours(1);
      int offset = forOffsetHours.getOffset((-803L));
      assertEquals(3600000, offset);
      assertEquals("+01:00", forOffsetHours.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetTakingLongReturningNegative() throws Throwable  {
      DateTimeZone forOffsetHours = DateTimeZone.forOffsetHours((-14));
      int offset = forOffsetHours.getOffset((long) (-14));
      assertEquals("-14:00", forOffsetHours.toString());
      assertEquals((-50400000), offset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNameKey() throws Throwable  {
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(406);
      forOffsetMillis.getNameKey(406);
      assertEquals("+00:00:00.406", forOffsetMillis.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEquals() throws Throwable  {
      DateTimeZone arg0 = DateTimeZone.forOffsetHours(1);
      arg0.equals(arg0);
      assertEquals("+01:00", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertUTCToLocalReturningNegative() throws Throwable  {
      FixedDateTimeZone fixedDateTimeZone = (FixedDateTimeZone)DateTimeZone.UTC;
      long convertUTCToLocal = fixedDateTimeZone.convertUTCToLocal((-1103L));
      assertEquals((-1103L), convertUTCToLocal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAdjustOffset() throws Throwable  {
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(14, 14);
      long adjustOffset = forOffsetHoursMinutes.adjustOffset(14, false);
      assertEquals("+14:14", forOffsetHoursMinutes.toString());
      assertEquals(14L, adjustOffset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertLocalToUTCTaking3Arguments() throws Throwable  {
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(44);
      long convertLocalToUTC = forOffsetMillis.convertLocalToUTC(307L, false, (-1L));
      assertEquals(263L, convertLocalToUTC);
      assertEquals("+00:00:00.044", forOffsetMillis.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetName() throws Throwable  {
      EthiopicChronology instance = EthiopicChronology.getInstance();
      DateTimeZone zone = instance.getZone();
      Locale arg1 = Locale.ITALY;
      String name = zone.getName(0L, arg1);
      assertEquals("+00:00", name);
      assertNotNull(name);
      assertEquals("Etc/UTC", zone.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNameWithPositiveAndNull() throws Throwable  {
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 59);
      String name = forOffsetHoursMinutes.getName(18000000L, (Locale) null);
      assertEquals("+01:59", name);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetShortNameTaking2Arguments() throws Throwable  {
      FixedDateTimeZone fixedDateTimeZone = (FixedDateTimeZone)DateTimeZone.UTC;
      String shortName = fixedDateTimeZone.getShortName((-2326L), (Locale) null);
      assertEquals("+00:00", shortName);
      assertNotNull(shortName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutes() throws Throwable  {
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes((-19), (-19));
      assertEquals("-19:19", forOffsetHoursMinutes.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsLocalDateTimeGapThrowsNullPointerException() throws Throwable  {
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      // Undeclared exception!
      try { 
        forTimeZone.isLocalDateTimeGap((LocalDateTime) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMillisKeepLocal() throws Throwable  {
      FixedDateTimeZone fixedDateTimeZone = (FixedDateTimeZone)DateTimeZone.UTC;
      long millisKeepLocal = fixedDateTimeZone.UTC.getMillisKeepLocal((DateTimeZone) null, 2792L);
      assertEquals(2792L, millisKeepLocal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertLocalToUTCTaking2ArgumentsReturningZero() throws Throwable  {
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(59);
      long convertLocalToUTC = forOffsetMillis.convertLocalToUTC((long) 59, true);
      assertEquals(0L, convertLocalToUTC);
      assertEquals("+00:00:00.059", forOffsetMillis.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertLocalToUTCTaking2ArgumentsReturningNegative() throws Throwable  {
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 1);
      long convertLocalToUTC = forOffsetHoursMinutes.convertLocalToUTC((long) 1, false);
      assertEquals("+01:01", forOffsetHoursMinutes.toString());
      assertEquals((-3659999L), convertLocalToUTC);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConvertUTCToLocalReturningPositive() throws Throwable  {
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(1, 1);
      long convertUTCToLocal = forOffsetHoursMinutes.convertUTCToLocal((-502L));
      assertEquals(3659498L, convertUTCToLocal);
      assertEquals("+01:01", forOffsetHoursMinutes.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetFromLocalReturningNegative() throws Throwable  {
      DateTimeZone arg0 = DateTimeZone.forOffsetMillis((-1381));
      CachedDateTimeZone forZone = CachedDateTimeZone.forZone(arg0);
      int offsetFromLocal = forZone.getOffsetFromLocal((-1381));
      assertEquals((-1381), offsetFromLocal);
      assertEquals("-00:00:01.381", forZone.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetFromLocalReturningZero() throws Throwable  {
      DateTimeZone arg0 = DateTimeZone.getDefault();
      CachedDateTimeZone forZone = CachedDateTimeZone.forZone(arg0);
      int offsetFromLocal = forZone.getOffsetFromLocal(2100L);
      assertEquals(0, offsetFromLocal);
      assertEquals("Etc/UTC", forZone.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOffsetTakingReadableInstantReturningNegative() throws Throwable  {
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis((-2442));
      GJChronology instanceUTC = GJChronology.getInstanceUTC();
      Instant arg0 = instanceUTC.getGregorianCutover();
      int offset = forOffsetMillis.getOffset((ReadableInstant) arg0);
      assertEquals((-2442), offset);
      assertEquals("-00:00:02.442", forOffsetMillis.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesAndGetName() throws Throwable  {
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(0, 59);
      Locale arg1 = Locale.ROOT;
      String name = forOffsetHoursMinutes.getName((long) 0, arg1);
      assertEquals("+00:59", name);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToTimeZoneReturningTimeZoneWhereUseDaylightTimeIsFalse() throws Throwable  {
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis((-3315));
      TimeZone timeZone = forOffsetMillis.toTimeZone();
      assertEquals("java.util.SimpleTimeZone[id=-00:00:03.315,offset=-3315,dstSavings=3600000,useDaylight=false,startYear=0,startMode=0,startMonth=0,startDay=0,startDayOfWeek=0,startTime=0,startTimeMode=0,endMode=0,endMonth=0,endDay=0,endDayOfWeek=0,endTime=0,endTimeMode=0]", timeZone.toString());
      assertEquals("-00:00:03.315", forOffsetMillis.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetMillis() throws Throwable  {
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis((-1256000));
      assertEquals("-00:20:56", forOffsetMillis.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetNameProviderWithNonNull() throws Throwable  {
      DefaultNameProvider arg0 = new DefaultNameProvider();
      DateTimeZone.setNameProvider(arg0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetNameProviderWithNull() throws Throwable  {
      DateTimeZone.setNameProvider((NameProvider) null);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetProviderWithNonNull() throws Throwable  {
      UTCProvider arg0 = new UTCProvider();
      DateTimeZone.setProvider(arg0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetProviderWithNull() throws Throwable  {
      DateTimeZone.setProvider((Provider) null);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetMillisWithZero() throws Throwable  {
      DateTimeZone forOffsetMillis = DateTimeZone.forOffsetMillis(0);
      assertEquals("UTC", forOffsetMillis.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursWithNegative() throws Throwable  {
      DateTimeZone forOffsetHours = DateTimeZone.forOffsetHours((-14));
      TimeZone arg0 = forOffsetHours.toTimeZone();
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      assertEquals("-14:00", forOffsetHours.getID());
      assertSame(forTimeZone, forOffsetHours);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsStandardOffset() throws Throwable  {
      TimeZone arg0 = TimeZone.getTimeZone("PLT");
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      boolean standardOffset = forTimeZone.isStandardOffset(788L);
      assertTrue(standardOffset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetMillisWithPositive() throws Throwable  {
      // Undeclared exception!
      try { 
        DateTimeZone.forOffsetMillis(2147483351);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Millis out of range: 2147483351
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetMillisThrowsIllegalArgumentException() throws Throwable  {
      // Undeclared exception!
      try { 
        DateTimeZone.forOffsetMillis((-2147483060));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Millis out of range: -2147483060
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursWithPositive() throws Throwable  {
      DateTimeZone forOffsetHours = DateTimeZone.forOffsetHours(1);
      TimeZone arg0 = forOffsetHours.toTimeZone();
      DateTimeZone forTimeZone = DateTimeZone.forTimeZone(arg0);
      assertEquals("+01:00", forOffsetHours.toString());
      assertSame(forTimeZone, forOffsetHours);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesThrowsIllegalArgumentException0() throws Throwable  {
      try { 
        DateTimeZone.forOffsetHoursMinutes((byte)14, (byte) (-59));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Positive hours must not have negative minutes: -59
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesThrowsIllegalArgumentException1() throws Throwable  {
      try { 
        DateTimeZone.forOffsetHoursMinutes(3, (-2147483646));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Minutes out of range: -2147483646
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesThrowsIllegalArgumentExceptionAndForOffsetHoursMinutesWithPositive() throws Throwable  {
      try { 
        DateTimeZone.forOffsetHoursMinutes(809, 1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Hours out of range: 809
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesThrowsIllegalArgumentExceptionAndForOffsetHoursMinutesWithNegative() throws Throwable  {
      try { 
        DateTimeZone.forOffsetHoursMinutes((-1381), (-1381));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Hours out of range: -1381
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesThrowsIllegalArgumentExceptionAndForOffsetHoursMinutesWithZero() throws Throwable  {
      try { 
        DateTimeZone.forOffsetHoursMinutes(0, 1000);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Minutes out of range: 1000
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForOffsetHoursMinutesWithZero() throws Throwable  {
      DateTimeZone forOffsetHoursMinutes = DateTimeZone.forOffsetHoursMinutes(0, 0);
      assertEquals("UTC", forOffsetHoursMinutes.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForID0() throws Throwable  {
      DateTimeZone forID = DateTimeZone.forID("-22:00");
      assertEquals("-22:00", forID.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForID1() throws Throwable  {
      DateTimeZone forID = DateTimeZone.forID("UTC");
      assertTrue(forID.isFixed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForIDWithNull() throws Throwable  {
      DateTimeZone forID = DateTimeZone.forID((String) null);
      assertEquals("Etc/UTC", forID.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetDefault() throws Throwable  {
      DateTimeZone arg0 = DateTimeZone.getDefault();
      DateTimeZone.setDefault(arg0);
      assertEquals("Etc/UTC", arg0.toString());
      assertEquals("Etc/UTC", arg0.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetDefaultThrowsIllegalArgumentException() throws Throwable  {
      // Undeclared exception!
      try { 
        DateTimeZone.setDefault((DateTimeZone) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The datetime zone must not be null
         //
         verifyException("org.joda.time.DateTimeZone", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForID2() throws Throwable  {
      DateTimeZone forID = DateTimeZone.forID("+00:00");
      assertEquals("UTC", forID.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetProvider() throws Throwable  {
      Provider provider = DateTimeZone.getProvider();
      assertNotNull(provider);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForID3() throws Throwable  {
      DateTimeZone forID = DateTimeZone.forID("America/Los_Angeles");
      assertEquals("America/Los_Angeles", forID.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNameProvider() throws Throwable  {
      NameProvider nameProvider = DateTimeZone.getNameProvider();
      assertNotNull(nameProvider);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetAvailableIDs() throws Throwable  {
      Set<String> availableIDs = DateTimeZone.getAvailableIDs();
      assertEquals(578, availableIDs.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetShortNameTakingLong() throws Throwable  {
      DateTimeZone forOffsetHours = DateTimeZone.forOffsetHours((-12));
      String shortName = forOffsetHours.getShortName((long) (-12));
      assertEquals("-12:00", shortName);
  }
}
