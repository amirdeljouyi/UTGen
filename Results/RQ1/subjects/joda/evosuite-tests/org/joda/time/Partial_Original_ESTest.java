/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 08:40:48 GMT 2024
 */

package org.joda.time;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Locale;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.joda.time.Chronology;
import org.joda.time.DateTimeField;
import org.joda.time.DateTimeFieldType;
import org.joda.time.LocalDate;
import org.joda.time.MonthDay;
import org.joda.time.Partial;
import org.joda.time.ReadablePartial;
import org.joda.time.ReadablePeriod;
import org.joda.time.Seconds;
import org.joda.time.Weeks;
import org.joda.time.chrono.BuddhistChronology;
import org.joda.time.chrono.CopticChronology;
import org.joda.time.chrono.EthiopicChronology;
import org.joda.time.chrono.GJChronology;
import org.joda.time.chrono.GregorianChronology;
import org.joda.time.format.DateTimeFormatter;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class Partial_Original_ESTest extends Partial_Original_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetCopyTaking2Arguments() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.year();
      GJChronology arg2 = GJChronology.getInstanceUTC();
      Partial partial = new Partial(arg0, 1631, arg2);
      Partial.Property property = partial.property(arg0);
      Locale arg1 = Locale.SIMPLIFIED_CHINESE;
      Partial setCopy = property.setCopy("1", arg1);
      assertFalse(setCopy.equals((Object)partial));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSizeReturningPositive() throws Throwable  {
      GJChronology arg2 = GJChronology.getInstanceUTC();
      DateTimeFieldType arg0 = DateTimeFieldType.centuryOfEra();
      Partial partial = new Partial(arg0, 50, arg2);
      int size = partial.size();
      assertEquals(1, size);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetValueReturningNegative() throws Throwable  {
      GregorianChronology arg0 = GregorianChronology.getInstance();
      DateTimeFieldType[] arg1 = new DateTimeFieldType[4];
      int[] arg2 = new int[7];
      arg2[1] = (-595);
      Partial partial = new Partial(arg0, arg1, arg2);
      int value = partial.getValue(1);
      assertEquals((-595), value);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetField() throws Throwable  {
      CopticChronology arg1 = CopticChronology.getInstanceUTC();
      LocalDate arg0 = LocalDate.now((Chronology) arg1);
      Partial partial = new Partial(arg0);
      DateTimeField field = partial.getField(1, (Chronology) arg1);
      assertNotNull(field);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetChronologyReturningNull() throws Throwable  {
      DateTimeFieldType[] arg1 = new DateTimeFieldType[7];
      int[] arg2 = new int[6];
      Partial partial = new Partial((Chronology) null, arg1, arg2);
      Chronology chronology = partial.getChronology();
      assertNull(chronology);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFormatterReturningDateTimeFormatterWhereIsPrinterIsTrue() throws Throwable  {
      DateTimeFieldType year = DateTimeFieldType.year();
      EthiopicChronology arg0 = EthiopicChronology.getInstanceUTC();
      DateTimeFieldType[] arg1 = new DateTimeFieldType[4];
      arg1[0] = year;
      arg1[1] = year;
      arg1[2] = year;
      arg1[3] = year;
      int[] arg2 = new int[1];
      Partial partial = new Partial(arg0, arg1, arg2);
      DateTimeFormatter formatter = partial.getFormatter();
      assertTrue(formatter.isPrinter());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPeriodAddedReturningPartialWhereSizeIsPositive() throws Throwable  {
      DateTimeFieldType[] arg1 = new DateTimeFieldType[6];
      int[] arg2 = new int[7];
      Partial partial = new Partial((Chronology) null, arg1, arg2);
      Partial withPeriodAdded = partial.withPeriodAdded((ReadablePeriod) null, 1969);
      assertEquals(6, withPeriodAdded.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSizeReturningZero() throws Throwable  {
      Partial partial = new Partial();
      int size = partial.size();
      assertEquals(0, size);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetValueReturningPositive() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.year();
      GJChronology arg2 = GJChronology.getInstanceUTC();
      Partial partial = new Partial(arg0, 1631, arg2);
      int value = partial.getValue(0);
      assertEquals(1631, value);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetValues() throws Throwable  {
      Partial partial = new Partial();
      int[] values = partial.getValues();
      assertEquals(0, values.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToStringTaking2ArgumentsReturningNonEmptyString() throws Throwable  {
      Partial partial = new Partial();
      Locale arg1 = Locale.CANADA;
      String string = partial.toString((String) null, arg1);
      assertEquals("[]", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToStringTaking2ArgumentsReturningEmptyString() throws Throwable  {
      Partial partial = new Partial();
      Locale arg1 = Locale.ROOT;
      String string = partial.toString("Z", arg1);
      assertEquals("", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToStringTakingStringReturningEmptyString() throws Throwable  {
      Partial partial = new Partial();
      String string = partial.toString("Z");
      assertEquals("", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToStringTakingNoArguments() throws Throwable  {
      Partial partial = new Partial();
      String string = partial.toString();
      assertEquals("[]", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToStringTakingStringReturningNonEmptyString() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.yearOfCentury();
      Partial partial = new Partial(arg0, 11);
      partial.getFormatter();
      String string = partial.toString((String) null);
      assertEquals("[yearOfCentury=11]", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPartialTakingChronology() throws Throwable  {
      Partial partial = new Partial((Chronology) null);
      DateTimeFormatter formatter = partial.getFormatter();
      assertNull(formatter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFormatter() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.yearOfEra();
      Partial partial = new Partial(arg0, 1321);
      partial.getFormatter();
      DateTimeFormatter formatter = partial.getFormatter();
      assertNull(formatter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsMatch() throws Throwable  {
      MonthDay arg0 = MonthDay.now();
      Partial partial = new Partial(arg0);
      boolean match = partial.isMatch((ReadablePartial) arg0);
      assertTrue(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPeriodAddedReturningPartialWhereSizeIsZero() throws Throwable  {
      Partial partial = new Partial();
      Weeks arg0 = Weeks.ONE;
      Partial withPeriodAdded = partial.withPeriodAdded(arg0, 0);
      assertSame(withPeriodAdded, partial);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPartialTaking2ArgumentsAndCallsWithField0() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.year();
      Partial partial = new Partial(arg0, 61);
      Partial withField = partial.withField(arg0, 61);
      assertSame(withField, partial);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithout() throws Throwable  {
      Partial partial = new Partial();
      DateTimeFieldType arg0 = DateTimeFieldType.dayOfYear();
      Partial without = partial.without(arg0);
      assertEquals(0, without.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithThrowsIllegalArgumentExceptionAndWithWithNonNullAndWithWithNegative() throws Throwable  {
      Partial partial = new Partial();
      DateTimeFieldType arg0 = DateTimeFieldType.era();
      // Undeclared exception!
      try { 
        partial.with(arg0, (-1139));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Value -1139 for era must not be smaller than 0
         //
         verifyException("org.joda.time.chrono.BaseChronology", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithThrowsIllegalArgumentExceptionAndWithWithNullAndWithWithPositive() throws Throwable  {
      Partial partial = new Partial();
      // Undeclared exception!
      try { 
        partial.with((DateTimeFieldType) null, 26);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The field type must not be null
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetChronologyReturningNonNull() throws Throwable  {
      Partial partial = new Partial();
      Chronology arg0 = partial.getChronology();
      Partial withChronologyRetainFields = partial.withChronologyRetainFields(arg0);
      assertSame(withChronologyRetainFields, partial);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPartialTakingNoArgumentsAndCallsWithChronologyRetainFields() throws Throwable  {
      Partial partial = new Partial();
      BuddhistChronology arg0 = BuddhistChronology.getInstance();
      Partial withChronologyRetainFields = partial.withChronologyRetainFields(arg0);
      assertNotSame(withChronologyRetainFields, partial);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreatePartialTakingReadablePartialThrowsIllegalArgumentException() throws Throwable  {
      Partial partial = null;
      try {
        partial = new Partial((ReadablePartial) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The partial must not be null
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToStringList() throws Throwable  {
      LocalDate arg0 = new LocalDate();
      Partial partial = new Partial(arg0);
      String stringList = partial.toStringList();
      assertEquals("[year=2014, monthOfYear=2, dayOfMonth=14]", stringList);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreatePartialTaking2ArgumentsThrowsIllegalArgumentException0() throws Throwable  {
      DateTimeFieldType secondOfMinute = DateTimeFieldType.secondOfMinute();
      DateTimeFieldType secondOfDay = DateTimeFieldType.secondOfDay();
      DateTimeFieldType[] arg0 = new DateTimeFieldType[3];
      arg0[0] = secondOfDay;
      arg0[1] = secondOfMinute;
      arg0[2] = secondOfDay;
      int[] arg1 = new int[3];
      Partial partial = null;
      try {
        partial = new Partial(arg0, arg1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Types array must be in order largest-smallest: secondOfMinute < secondOfDay
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreatePartialTaking2ArgumentsThrowsIllegalArgumentException1() throws Throwable  {
      DateTimeFieldType weekyear = DateTimeFieldType.weekyear();
      DateTimeFieldType weekyearOfCentury = DateTimeFieldType.weekyearOfCentury();
      DateTimeFieldType[] arg0 = new DateTimeFieldType[3];
      arg0[0] = weekyearOfCentury;
      DateTimeFieldType year = DateTimeFieldType.year();
      arg0[1] = year;
      arg0[2] = weekyear;
      int[] arg1 = new int[3];
      Partial partial = null;
      try {
        partial = new Partial(arg0, arg1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Types array must be in order largest-smallest: weekyearOfCentury < year
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreatePartialTaking2ArgumentsThrowsIllegalArgumentException2() throws Throwable  {
      DateTimeFieldType[] arg0 = new DateTimeFieldType[3];
      DateTimeFieldType dayOfMonth = DateTimeFieldType.dayOfMonth();
      arg0[0] = dayOfMonth;
      DateTimeFieldType hourOfHalfday = DateTimeFieldType.hourOfHalfday();
      arg0[1] = hourOfHalfday;
      DateTimeFieldType era = DateTimeFieldType.era();
      arg0[2] = era;
      int[] arg1 = new int[3];
      Partial partial = null;
      try {
        partial = new Partial(arg0, arg1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Types array must be in order largest-smallest: hourOfHalfday < era
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreatePartialTaking2ArgumentsThrowsIllegalArgumentException3() throws Throwable  {
      DateTimeFieldType[] arg0 = new DateTimeFieldType[3];
      DateTimeFieldType dayOfMonth = DateTimeFieldType.dayOfMonth();
      arg0[0] = dayOfMonth;
      DateTimeFieldType hourOfHalfday = DateTimeFieldType.hourOfHalfday();
      arg0[1] = hourOfHalfday;
      arg0[2] = hourOfHalfday;
      int[] arg1 = new int[3];
      Partial partial = null;
      try {
        partial = new Partial(arg0, arg1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Types array must not contain duplicate: hourOfHalfday
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreatePartialTaking2ArgumentsThrowsIllegalArgumentException4() throws Throwable  {
      DateTimeFieldType[] arg0 = new DateTimeFieldType[2];
      DateTimeFieldType secondOfDay = DateTimeFieldType.secondOfDay();
      arg0[0] = secondOfDay;
      DateTimeFieldType year = DateTimeFieldType.year();
      arg0[1] = year;
      int[] arg1 = new int[2];
      Partial partial = null;
      try {
        partial = new Partial(arg0, arg1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Types array must be in order largest-smallest: secondOfDay < year
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPartialTaking2Arguments0() throws Throwable  {
      DateTimeFieldType era = DateTimeFieldType.era();
      DateTimeFieldType[] arg0 = new DateTimeFieldType[2];
      arg0[0] = era;
      DateTimeFieldType minuteOfHour = DateTimeFieldType.minuteOfHour();
      arg0[1] = minuteOfHour;
      int[] arg1 = new int[2];
      Partial partial = new Partial(arg0, arg1);
      assertEquals(2, partial.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreatePartialTaking2ArgumentsThrowsIllegalArgumentException5() throws Throwable  {
      DateTimeFieldType era = DateTimeFieldType.era();
      DateTimeFieldType[] arg0 = new DateTimeFieldType[2];
      arg0[0] = era;
      arg0[1] = era;
      int[] arg1 = new int[2];
      Partial partial = null;
      try {
        partial = new Partial(arg0, arg1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Types array must not contain duplicate: era
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreatePartialTaking2ArgumentsThrowsIllegalArgumentException6() throws Throwable  {
      DateTimeFieldType[] arg0 = new DateTimeFieldType[5];
      int[] arg1 = new int[5];
      Partial partial = null;
      try {
        partial = new Partial(arg0, arg1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Types array must not contain null: index 0
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreatePartialTaking3ArgumentsThrowsIllegalArgumentException() throws Throwable  {
      DateTimeFieldType[] arg0 = new DateTimeFieldType[5];
      int[] arg1 = new int[3];
      Partial partial = null;
      try {
        partial = new Partial(arg0, arg1, (Chronology) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Values array must be the same length as the types array
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPartialTaking2Arguments1() throws Throwable  {
      DateTimeFieldType[] arg0 = new DateTimeFieldType[0];
      int[] arg1 = new int[0];
      Partial partial = new Partial(arg0, arg1);
      assertEquals(0, partial.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreatePartialTaking2ArgumentsThrowsIllegalArgumentException7() throws Throwable  {
      DateTimeFieldType[] arg0 = new DateTimeFieldType[6];
      Partial partial = null;
      try {
        partial = new Partial(arg0, (int[]) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Values array must not be null
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreatePartialTaking2ArgumentsThrowsIllegalArgumentException8() throws Throwable  {
      Partial partial = null;
      try {
        partial = new Partial((DateTimeFieldType) null, 32);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The field type must not be null
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPropertyTaking2ArgumentsAndCallsWithMinimumValue() throws Throwable  {
      Partial arg0 = new Partial();
      Partial.Property partial_Property = new Partial.Property(arg0, (-106));
      // Undeclared exception!
      try { 
        partial_Property.withMinimumValue();
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddToCopy() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.year();
      GJChronology arg2 = GJChronology.getInstanceUTC();
      Partial partial = new Partial(arg0, 1631, arg2);
      Partial.Property property = partial.property(arg0);
      Partial addToCopy = property.addToCopy(1631);
      assertEquals(1, addToCopy.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddWrapFieldToCopy() throws Throwable  {
      GJChronology arg2 = GJChronology.getInstanceUTC();
      DateTimeFieldType arg0 = DateTimeFieldType.centuryOfEra();
      Partial partial = new Partial(arg0, 50, arg2);
      Partial.Property property = partial.property(arg0);
      Partial addWrapFieldToCopy = property.addWrapFieldToCopy((-822));
      assertNotSame(partial, addWrapFieldToCopy);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetCopyTakingString() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.year();
      GJChronology arg2 = GJChronology.getInstanceUTC();
      Partial partial = new Partial(arg0, 1631, arg2);
      Partial.Property property = partial.property(arg0);
      // Undeclared exception!
      try { 
        property.setCopy("org.joda.time.Partial");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Value \"org.joda.time.Partial\" for year is not supported
         //
         verifyException("org.joda.time.field.BaseDateTimeField", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFieldTypes() throws Throwable  {
      Partial partial = new Partial();
      DateTimeFieldType[] fieldTypes = partial.getFieldTypes();
      assertEquals(0, fieldTypes.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMinus() throws Throwable  {
      Partial partial = new Partial();
      assertEquals(0, partial.size());
      
      Seconds arg0 = Seconds.MIN_VALUE;
      Partial minus = partial.minus(arg0);
      assertNotSame(minus, partial);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPlus() throws Throwable  {
      Partial partial = new Partial();
      Partial plus = partial.plus((ReadablePeriod) null);
      assertEquals(0, plus.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesPartialTaking2ArgumentsAndCallsWithField1() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.year();
      Partial partial = new Partial(arg0, 1724);
      Partial withField = partial.withField(arg0, 1926);
      assertNotSame(withField, partial);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWith() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.secondOfMinute();
      Partial partial = new Partial(arg0, 44);
      Partial with = partial.with(arg0, 44);
      assertEquals(1, with.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsMatchThrowsIllegalArgumentException() throws Throwable  {
      Partial partial = new Partial((Chronology) null);
      // Undeclared exception!
      try { 
        partial.isMatch((ReadablePartial) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The partial must not be null
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreatePartialTaking2ArgumentsThrowsIllegalArgumentException9() throws Throwable  {
      Partial partial = null;
      try {
        partial = new Partial((DateTimeFieldType[]) null, (int[]) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Types array must not be null
         //
         verifyException("org.joda.time.Partial", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPropertyReturningPartial$PropertyWhereGetIsNegative() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.year();
      Partial partial = new Partial(arg0, (-2093));
      Partial.Property property = partial.property(arg0);
      assertEquals((-2093), property.get());
  }
}
