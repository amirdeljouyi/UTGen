/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 06:25:08 GMT 2024
 */

package org.joda.time.tz;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.File;
import java.io.IOException;
import java.util.Map;
import java.util.StringTokenizer;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.joda.time.Chronology;
import org.joda.time.DateTimeZone;
import org.joda.time.tz.DateTimeZoneBuilder;
import org.joda.time.tz.ZoneInfoCompiler;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class ZoneInfoCompiler_ESTest extends ZoneInfoCompiler_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseOptionalReturningNonEmptyString() throws Throwable  {
      // No Comments were added
      String parseOptional = ZoneInfoCompiler.parseOptional("-verbose -Djava.util.logging.config.file=C:\templogging.properties");
      assertEquals("-verbose -Djava.util.logging.config.file=C:\templogging.properties", parseOptional);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCompileThrowsNullPointerException() throws Throwable  {
      // Arrange
      ZoneInfoCompiler zoneInfoCompiler = new ZoneInfoCompiler();
      File arg0 = MockFile.createTempFile("n(C{V%E", "ReadablePartial objects must not be null");
      File[] arg1 = new File[6];
      
      // Act and Assert
      try {
      zoneInfoCompiler.compile(arg0, arg1);
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      // Verify that the thrown exception is an instance of MockFileInputStream
      verifyException("org.evosuite.runtime.mock.java.io.MockFileInputStream", e);
      
      // Verify that no message was provided in the exception
      assertNull(e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesDateTimeOfYearTakingStringTokenizer() throws Throwable  {
      // Given: A StringTokenizer object that contains a string with an invalid month of year value
      StringTokenizer arg0 = new StringTokenizer("c5m1zrd7k,", "");
      
      // When: The StringTokenizer is used to create a DateTimeOfYear object
      ZoneInfoCompiler.DateTimeOfYear zoneInfoCompiler_DateTimeOfYear = null;
      try {
      zoneInfoCompiler_DateTimeOfYear = new ZoneInfoCompiler.DateTimeOfYear(arg0);
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      // Then: A IllegalArgumentException is thrown with a message indicating that the value for month of year is not supported
      verifyException("org.joda.time.chrono.GJLocaleSymbols", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesDateTimeOfYearTakingStringTokenizerAndCreatesDateTimeOfYearTakingStringTokenizer() throws Throwable  {
      // Given: The StringTokenizer arg0 is created with the string "e*e6#&8HT+~" and the delimiter of "e*e6#&8HT+~"
      StringTokenizer arg0 = new StringTokenizer("e*e6#&8HT+~", "e*e6#&8HT+~");
      
      // When: A new ZoneInfoCompiler.DateTimeOfYear object is created with the StringTokenizer as an argument
      ZoneInfoCompiler.DateTimeOfYear zoneInfoCompiler_DateTimeOfYear = new ZoneInfoCompiler.DateTimeOfYear(arg0);
      
      // Then: The ZoneInfoCompiler.DateTimeOfYear object should be created successfully
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCompileWithNullAndEmptyArray() throws Throwable  {
      // Arrange
      ZoneInfoCompiler zoneInfoCompiler = new ZoneInfoCompiler();
      File[] emptyFileArray = new File[0];
      
      // Act
      Map<String, DateTimeZone> compiledZones = zoneInfoCompiler.compile(null, emptyFileArray);
      
      // Assert
      assertTrue(compiledZones.isEmpty());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTest0() throws Throwable  {
      // Given a string representation of a date and time zone
      String input = "cdo}2V.>vi@W";
      DateTimeZone arg1 = DateTimeZone.getDefault();
      
      // When the ZoneInfoCompiler is called with the string and date time zone
      boolean test = ZoneInfoCompiler.test(input, arg1);
      
      // Then the method should return true if the input string can be parsed as a valid date-time in the given time zone
      assertTrue(test);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTest1() throws Throwable  {
      // Given: A DateTimeZoneBuilder is created and a DateTimeZone is built for the time zone "America/New_York".
      DateTimeZoneBuilder dateTimeZoneBuilder = new DateTimeZoneBuilder();
      DateTimeZone newYorkZone = dateTimeZoneBuilder.toDateTimeZone("America/New_York", false);
      
      // When: The ZoneInfoCompiler is used to test whether the built DateTimeZone matches the expected time zone "America/New_York".
      boolean test = ZoneInfoCompiler.test("America/New_York", newYorkZone);
      
      // Then: Assert that the test passes, meaning that the built DateTimeZone matches the expected time zone.
      assertTrue(test);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseZoneCharAndParseZoneCharWithAlphabeticChar0() throws Throwable  {
      // Test that the method returns the correct value for a valid zone char
      char actual = ZoneInfoCompiler.parseZoneChar('z');
      assertEquals('u', actual);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseZoneChar0() throws Throwable  {
      // Test that the parseZoneChar method returns the correct character for a given string
      char parseZoneChar = ZoneInfoCompiler.parseZoneChar('w');
      assertEquals('w', parseZoneChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseZoneChar1() throws Throwable  {
      // Test that the parseZoneChar method correctly parses a 'u' character
      char parseZoneChar = ZoneInfoCompiler.parseZoneChar('u');
      assertEquals('u', parseZoneChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseZoneChar2() throws Throwable  {
      // Test that the "parseZoneChar" method correctly parses a single character string representing a zone offset.
      char parseZoneChar = ZoneInfoCompiler.parseZoneChar('s');
      assertEquals('s', parseZoneChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseZoneChar3() throws Throwable  {
      // No Comments were added
      char parseZoneChar = ZoneInfoCompiler.parseZoneChar('g');
      assertEquals('u', parseZoneChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseZoneCharAndParseZoneCharWithAlphabeticChar1() throws Throwable  {
      // Parse the zone character 'Z' and assert that it returns the expected value 'u'.
      char parseZoneChar = ZoneInfoCompiler.parseZoneChar('Z');
      assertEquals('u', parseZoneChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseZoneChar4() throws Throwable  {
      // Test that the method parses a single character correctly
      char parseZoneChar = ZoneInfoCompiler.parseZoneChar('W');
      assertEquals('w', parseZoneChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseZoneChar5() throws Throwable  {
      // Parse the character 'U' and assert that it is parsed as the character 'u'.
      char parseZoneChar = ZoneInfoCompiler.parseZoneChar('U');
      assertEquals('u', parseZoneChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseZoneChar6() throws Throwable  {
      // Test that parsing a valid zone character returns the expected result.
      char parseZoneChar = ZoneInfoCompiler.parseZoneChar('S');
      assertEquals('s', parseZoneChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseZoneCharAndParseZoneCharWithAlphabeticChar2() throws Throwable  {
      // Parse a zone char and assert that it is converted correctly
      char parseZoneChar = ZoneInfoCompiler.parseZoneChar('A');
      assertEquals('w', parseZoneChar);
      
      // This test verifies that the "parseZoneChar" method of the "ZoneInfoCompiler" class converts a given character to its corresponding zone char. In this case, the input character is 'A' and the expected output is 'w'.
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseZoneChar7() throws Throwable  {
      // This test ensures that the "G" time zone ID is properly parsed and returned as a "u" character.
      char parseZoneChar = ZoneInfoCompiler.parseZoneChar('G');
      assertEquals('u', parseZoneChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseTimeThrowsIllegalArgumentException() throws Throwable  {
      try {
      ZoneInfoCompiler.parseTime("+05:30");
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      // +05:30
      verifyException("org.joda.time.tz.ZoneInfoCompiler", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseTimeReturningNegative() throws Throwable  {
      // Test that the method can handle negative values for hours and minutes
      int parseTime = ZoneInfoCompiler.parseTime("-12:59");
      assertEquals((-46740000), parseTime);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseOptionalReturningNull() throws Throwable  {
      // Tests that the "ZoneInfoCompiler.parseOptional" method returns null when passed an empty string.
      String parseOptional = ZoneInfoCompiler.parseOptional("-");
      assertNull(parseOptional);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseOptionalReturningEmptyString() throws Throwable  {
      // No Comments were added
      String parseOptional = ZoneInfoCompiler.parseOptional("");
      assertEquals("", parseOptional);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseYearAndParseYearReturningNegativeAndParseYearWithNegative() throws Throwable  {
      // No Comments were added
      int parseYear = ZoneInfoCompiler.parseYear("only", (-74185799));
      assertEquals((-74185799), parseYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseYearAndParseYearReturningPositiveAndParseYearWithNegative() throws Throwable  {
      // No Comments were added
      int parseYear = ZoneInfoCompiler.parseYear("max", (-3891));
      assertEquals(Integer.MAX_VALUE, parseYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseYearAndParseYearReturningPositive0() throws Throwable  {
      // No Comments were added
      int parseYear = ZoneInfoCompiler.parseYear("2023", 2023);
      assertEquals(2023, parseYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseYearAndParseYearReturningNegativeAndParseYearWithPositive() throws Throwable  {
      // Parse a year string "min" representing the minimum value for an int
      int parseYear = ZoneInfoCompiler.parseYear("min", 2150);
      
      // Assert that the parsed year is equal to Integer.MIN_VALUE
      assertEquals(Integer.MIN_VALUE, parseYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseYearAndParseYearReturningPositive1() throws Throwable  {
      // This test is checking that the "maximum" string can be parsed as an integer representing the maximum value of an int (i.e., 2147483647)
      int expectedMaxYear = 2049;
      int parseYear = ZoneInfoCompiler.parseYear("maximum", 2049);
      assertEquals(expectedMaxYear, parseYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCompileWithNullAndFileWhereLengthIsZero() throws Throwable  {
      // Setup
      MockFile arg0 = new MockFile(",/", ")R3");
      
      // Action
      ZoneInfoCompiler zoneInfoCompiler = new ZoneInfoCompiler();
      Map<String, DateTimeZone> compile = zoneInfoCompiler.compile(arg0, (File[]) null);
      
      // Assertion
      assertTrue(compile.isEmpty());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLenientISOChronology() throws Throwable  {
      // Given a specific date-time string in ISO format (e.g., "2022-01-01T00:00:00Z")
      String inputDateTime = "2022-01-01T00:00:00Z";
      
      // When the date-time string is parsed using the lenient ISO chronology
      ZoneInfoCompiler.parseTime(inputDateTime);
      Chronology lenientISOChronology = ZoneInfoCompiler.getLenientISOChronology();
      assertNotNull(lenientISOChronology);
      
      // Then the resulting chronology should be non-null and match the input date-time string
      assertNotNull(lenientISOChronology);
      assertEquals(inputDateTime, lenientISOChronology.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMainThrowsNullPointerException() throws Throwable  {
      // This test verifies that ZoneInfoCompiler throws a NullPointerException when no arguments are provided.
      String[] arg0 = new String[9];
      arg0[0] = "-src";
      arg0[1] = "-src";
      try {
      ZoneInfoCompiler.main(arg0);
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // This is the expected behavior, as the method does not accept null arguments.
      verifyException("org.evosuite.runtime.mock.java.io.MockFile", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMain0() throws Throwable  {
      // No Comments were added
      String[] arg0 = new String[5];
      arg0[0] = "-?";
      ZoneInfoCompiler.main(arg0);
      assertEquals(5, arg0.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMain1() throws Throwable  {
      // Given a command line argument "-verbose" is passed to the ZoneInfoCompiler main method
      String[] args = new String[1];
      args[0] = "-verbose";
      
      // When the ZoneInfoCompiler main method is invoked with the given arguments
      ZoneInfoCompiler.main(args);
      
      // Then the argument array length should be 1
      assertEquals(1, args.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDayOfWeek() throws Throwable  {
      // Parse a day of the week from a string and assert that it is equal to the expected value.
      int parseDayOfWeek = ZoneInfoCompiler.parseDayOfWeek("Monday");
      assertEquals(1, parseDayOfWeek);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMonthThrowsIllegalArgumentException() throws Throwable  {
      // Test that an exception is thrown when trying to parse a string that contains unsupported values for monthOfYear
      try {
      ZoneInfoCompiler.parseMonth("MonthOfYear: 6\nDayOfMonth: 15\nDayOfWeek: 4\nAdvanceDayOfWeek: true\nMillisOfDay: 0\nZoneChar: w\n");
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Value "MonthOfYear: 6 DayOfMonth: 15 DayOfWeek: 4 AdvanceDayOfWeek: true MillisOfDay: 0 ZoneChar: w" for monthOfYear is not supported
      verifyException("org.joda.time.chrono.GJLocaleSymbols", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testVerbose() throws Throwable  {
      // No Comments were added
      boolean verbose = ZoneInfoCompiler.verbose();
      assertFalse(verbose);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCompileThrowsIOException() throws Throwable  {
      // No Comments were added
      ZoneInfoCompiler zoneInfoCompiler = new ZoneInfoCompiler();
      File arg0 = MockFile.createTempFile("my-test-file", "txt");
      File[] arg1 = new File[0];
      try { 
        zoneInfoCompiler.compile(arg0, arg1);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Destination is not a directory: /tmp/my-test-file0txt
         //
         verifyException("org.joda.time.tz.ZoneInfoCompiler", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMainWithEmptyArray() throws Throwable  {
      // Given a command line argument array with no arguments
      String[] args = new String[0];
      
      // When the main method is called with these arguments
      ZoneInfoCompiler.main(args);
      
      // Then the length of the argument array should be 0
      assertEquals(0, args.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToString() throws Throwable  {
      // rollbacked to evosuite
      ZoneInfoCompiler.DateTimeOfYear zoneInfoCompiler_DateTimeOfYear = new ZoneInfoCompiler.DateTimeOfYear();
      String string = zoneInfoCompiler_DateTimeOfYear.toString();
      assertEquals("MonthOfYear: 1\nDayOfMonth: 1\nDayOfWeek: 0\nAdvanceDayOfWeek: false\nMillisOfDay: 0\nZoneChar: w\n", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddRecurring() throws Throwable  {
      // rollbacked to evosuite
      ZoneInfoCompiler.DateTimeOfYear zoneInfoCompiler_DateTimeOfYear = new ZoneInfoCompiler.DateTimeOfYear();
      DateTimeZoneBuilder arg0 = new DateTimeZoneBuilder();
      zoneInfoCompiler_DateTimeOfYear.addRecurring(arg0, "c5m1yRD7K,", (-3365), 52, 2001);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddCutover() throws Throwable  {
      // No Comments were added
      ZoneInfoCompiler.DateTimeOfYear zoneInfoCompiler_DateTimeOfYear = new ZoneInfoCompiler.DateTimeOfYear();
      DateTimeZoneBuilder arg0 = new DateTimeZoneBuilder();
      zoneInfoCompiler_DateTimeOfYear.addCutover(arg0, (-1112639283));
  }
}
