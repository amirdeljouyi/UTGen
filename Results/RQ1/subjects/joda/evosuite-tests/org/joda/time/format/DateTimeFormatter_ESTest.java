/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 09:27:30 GMT 2024
 */

package org.joda.time.format;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.Writer;
import java.util.Locale;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeFieldType;
import org.joda.time.DateTimeZone;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import org.joda.time.MutableDateTime;
import org.joda.time.Partial;
import org.joda.time.ReadWritableInstant;
import org.joda.time.ReadableInstant;
import org.joda.time.ReadablePartial;
import org.joda.time.chrono.ISOChronology;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.DateTimeFormatterBuilder;
import org.joda.time.format.DateTimeParser;
import org.joda.time.format.DateTimePrinter;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class DateTimeFormatter_ESTest extends DateTimeFormatter_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneUTCReturningDateTimeFormatterWhereGetDefaultYearIsZero() throws Throwable  {
      // Given
      DateTimeFormatterBuilder.TimeZoneId timeZoneId = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      
      // When
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(timeZoneId, timeZoneId);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(0);
      DateTimeFormatter withZoneUTC = withDefaultYear.withZoneUTC();
      
      // Then
      assertFalse(withDefaultYear.isOffsetParsed());
      assertFalse(withZoneUTC.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertNotSame(withZoneUTC, withDefaultYear);
      assertEquals(0, withZoneUTC.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneUTCReturningDateTimeFormatterWhereGetDefaultYearIsNegative() throws Throwable  {
      // No Comments were added
      DateTimeFieldType arg0 = DateTimeFieldType.weekOfWeekyear();
      DateTimeFormatterBuilder.PaddedNumber arg1 = new DateTimeFormatterBuilder.PaddedNumber(arg0, (-2098), false, (-2098));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear((-2098));
      DateTimeFormatter withZoneUTC = withDefaultYear.withZoneUTC();
      assertFalse(withZoneUTC.isOffsetParsed());
      assertEquals((-2098), withDefaultYear.getDefaultYear());
      assertEquals((-2098), withZoneUTC.getDefaultYear());
      assertNotSame(withZoneUTC, withDefaultYear);
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      // Given a DateTimeFormatter with default zone
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      DateTimeZone arg0 = DateTimeZone.getDefault();
      
      // When the "withZone" method is called with the default zone
      DateTimeFormatter withZone = dateTimeFormatter.withZone(arg0);
      
      // Then the resulting formatter should have the same default year as the original formatter
      assertEquals(2000, withZone.getDefaultYear());
      
      // And the resulting formatter should not be the same instance as the original formatter
      assertNotSame(withZone, dateTimeFormatter);
      
      // And the resulting formatter should not parse offsets
      assertFalse(withZone.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneReturningDateTimeFormatterWhereIsOffsetParsedIsTrue() throws Throwable  {
      // Create a new LocalTime object and a Partial object with it.
      LocalTime arg0 = new LocalTime();
      Partial partial = new Partial(arg0);
      
      // Get the formatter for the partial object.
      DateTimeFormatter formatter = partial.getFormatter();
      
      // Create a new formatter that is offset parsed and has no time zone specified.
      DateTimeFormatter withOffsetParsed = formatter.withOffsetParsed();
      DateTimeFormatter withZone = withOffsetParsed.withZone((DateTimeZone) null);
      
      // Assert that the default year of the new formatter is 2000.
      assertEquals(2000, withZone.getDefaultYear());
      
      // Assert that the original formatter does not have offset parsing enabled.
      assertFalse(formatter.isOffsetParsed());
      
      // Assert that the new formatter has offset parsing enabled.
      assertTrue(withZone.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneReturningDateTimeFormatterWhereGetDefaultYearIsZero() throws Throwable  {
      // Given a character literal for the format pattern
      DateTimeFormatterBuilder.CharacterLiteral letter = new DateTimeFormatterBuilder.CharacterLiteral('j');
      
      // When we build a date time formatter with the default year
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, letter);
      
      // Then the resulting formatter should have the correct default year
      assertEquals(0, dateTimeFormatter.getDefaultYear());
      
      // And when we add a zone to the formatter
      DateTimeZone zone = DateTimeZone.forOffsetHours(0);
      DateTimeFormatter withZone = dateTimeFormatter.withZone(zone);
      
      // Then the resulting formatter should have the correct default year
      assertEquals(0, withZone.getDefaultYear());
      
      // And the resulting formatter should not be the same as the original formatter
      assertNotSame(withZone, dateTimeFormatter);
      
      // And the resulting formatter should not parse offsets
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertFalse(withZone.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPivotYearTakingIntegerReturningDateTimeFormatterWhereGetDefaultYearIsZero() throws Throwable  {
      // Create a DateTimeFormatter with a character literal for the day of the week (e.g., "j")
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('j');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, arg1);
      
      // Create a clone of the DateTimeFormatter with the default year set to 0
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(0);
      
      // Create a clone of the DateTimeFormatter with the pivot year set to 2000
      DateTimeFormatter withPivotYear = withDefaultYear.withPivotYear((Integer) 1);
      
      // Assert that the two clones are not equal (i.e., they have different default years)
      assertNotSame(withPivotYear, withDefaultYear);
      
      // Assert that the clone with the pivot year has a default year of 0
      assertEquals(0, withPivotYear.getDefaultYear());
      
      // Assert that the DateTimeFormatter with the default year set to 2000 has a default year of 2000
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      
      // Assert that the clone with the offset parsed flag is not equal to the original DateTimeFormatter (i.e., it has been modified)
      assertFalse(withDefaultYear.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPivotYearTakingIntegerReturningDateTimeFormatterWhereGetDefaultYearIsNegative() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('M');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear((-2029));
      DateTimeFormatter withPivotYear = withDefaultYear.withPivotYear((Integer) null);
      assertEquals((-2029), withPivotYear.getDefaultYear());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(withPivotYear.isOffsetParsed());
      assertSame(withPivotYear, withDefaultYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPivotYearTakingIntReturningDateTimeFormatterWhereIsOffsetParsedIsTrue() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Pricting no supported");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      DateTimeFormatter withPivotYear = withOffsetParsed.withPivotYear(0);
      assertNotSame(withPivotYear, withOffsetParsed);
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(0, (int)withPivotYear.getPivotYear());
      assertTrue(withOffsetParsed.isOffsetParsed());
      assertEquals(2000, withPivotYear.getDefaultYear());
      assertEquals(2000, withOffsetParsed.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPivotYearTakingIntReturningDateTimeFormatterWhereGetDefaultYearIsZero() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('j');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(0);
      DateTimeFormatter withPivotYear = withDefaultYear.withPivotYear((-1164));
      assertNotSame(withPivotYear, withDefaultYear);
      assertEquals(0, withPivotYear.getDefaultYear());
      assertEquals((-1164), (int)withPivotYear.getPivotYear());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(withDefaultYear.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPivotYearTakingIntReturningDateTimeFormatterWhereGetDefaultYearIsNegative() throws Throwable  {
      // Given a DateTimeFormatter and a default year of -2029,
      DateTimeFormatterBuilder.CharacterLiteral characterLiteral = new DateTimeFormatterBuilder.CharacterLiteral('M');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(characterLiteral, characterLiteral);
      int defaultYear = -2029;
      
      // When we create a new DateTimeFormatter with the default year of -2029 and pivot year of -2029,
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(defaultYear);
      DateTimeFormatter withPivotYear = withDefaultYear.withPivotYear(defaultYear);
      
      // Then we expect the resulting DateTimeFormatter to have the default year of -2029 and pivot year of -2029,
      assertEquals(defaultYear, withPivotYear.getDefaultYear());
      assertEquals(defaultYear, dateTimeFormatter.getDefaultYear());
      
      // And we expect the resulting DateTimeFormatter to not be the same as the original DateTimeFormatter,
      assertNotSame(withPivotYear, withDefaultYear);
      
      // And we expect the resulting DateTimeFormatter to have offset parsing disabled,
      assertFalse(withDefaultYear.isOffsetParsed());
      
      // And we expect the resulting DateTimeFormatter to have the pivot year of -2029,
      assertEquals((-2029), (int) withPivotYear.getPivotYear());
      
      // And we expect the original DateTimeFormatter to still have the default year of 2000 and offset parsing enabled,
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertTrue(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithOffsetParsedReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      // Given a DateTimeFormatter with no offset parsed
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      
      // When the withOffsetParsed method is called
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      
      // Then the offset parsing should be enabled
      assertTrue(withOffsetParsed.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithOffsetParsedReturningDateTimeFormatterWhereGetDefaultYearIsZero() throws Throwable  {
      // Create a new DateTimeFormatterBuilder.CharacterLiteral instance
      DateTimeFormatterBuilder.CharacterLiteral characterLiteral = new DateTimeFormatterBuilder.CharacterLiteral('j');
      
      // Create a new DateTimeFormatter using the CharacterLiteral instance
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(null, characterLiteral);
      
      // Use the withDefaultYear method to set the default year to 0
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(0);
      
      // Use the withOffsetParsed method to enable offset parsing
      DateTimeFormatter withOffsetParsed = withDefaultYear.withOffsetParsed();
      
      // Verify that the default year is set correctly
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      
      // Verify that offset parsing is enabled
      assertTrue(withOffsetParsed.isOffsetParsed());
      
      // Verify that the two formatters are not the same instance
      assertNotSame(withOffsetParsed, withDefaultYear);
      
      // Verify that the default year is set correctly on the offset-parsed formatter
      assertEquals(0, withOffsetParsed.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithLocaleReturningDateTimeFormatterWhereIsOffsetParsedIsTrue() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("org.joda.time.format.DateTimeFormatter");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      Locale arg0 = Locale.CHINESE;
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      DateTimeFormatter withLocale = withOffsetParsed.withLocale(arg0);
      assertNotSame(withLocale, withOffsetParsed);
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, withOffsetParsed.getDefaultYear());
      assertTrue(withOffsetParsed.isOffsetParsed());
      assertEquals(2000, withLocale.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithLocaleReturningDateTimeFormatterWhereGetDefaultYearIsZero() throws Throwable  {
      // Test that the withLocale method sets the locale correctly
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('j');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, arg1);
      Locale arg0 = Locale.CANADA_FRENCH;
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(0);
      DateTimeFormatter withLocale = withDefaultYear.withLocale(arg0);
      assertEquals(arg0, withLocale.getLocale()); // Check that the locale is set correctly
      assertNotSame(withLocale, withDefaultYear); // Check that the object is not the same as the original DateTimeFormatter
      assertFalse(withDefaultYear.isOffsetParsed()); // Check that the offset parsing is disabled
      assertEquals(2000, dateTimeFormatter.getDefaultYear()); // Check that the default year is still set correctly
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithLocaleReturningDateTimeFormatterWhereGetDefaultYearIsNegative() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('M');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear((-2029));
      Locale arg0 = Locale.KOREAN;
      DateTimeFormatter withLocale = withDefaultYear.withLocale(arg0);
      assertEquals((-2029), withDefaultYear.getDefaultYear());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertNotSame(withLocale, withDefaultYear);
      assertEquals((-2029), withLocale.getDefaultYear());
      assertFalse(withDefaultYear.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithDefaultYearReturningDateTimeFormatterWhereIsOffsetParsedIsTrue() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      DateTimeFormatter withDefaultYear = withOffsetParsed.withDefaultYear(0);
      assertEquals(2000, withOffsetParsed.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(0, withDefaultYear.getDefaultYear());
      assertTrue(withOffsetParsed.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithChronologyReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      DateTimeFormatter withChronology = dateTimeFormatter.withChronology((Chronology) null);
      assertSame(withChronology, dateTimeFormatter);
      assertFalse(withChronology.isOffsetParsed());
      assertEquals(2000, withChronology.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithChronologyReturningDateTimeFormatterWhereIsOffsetParsedIsTrue() throws Throwable  {
      // No Comments were added
      DateTimeFormat.StyleFormatter arg1 = new DateTimeFormat.StyleFormatter((-1308), 1, (-1308));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      DateTimeFormatter withChronology = withOffsetParsed.withChronology((Chronology) null);
      Integer arg0 = new Integer(1);
      DateTimeFormatter withPivotYear = withChronology.withPivotYear(arg0);
      assertEquals(2000, withPivotYear.getDefaultYear());
      assertSame(withChronology, withOffsetParsed);
      assertTrue(withChronology.isOffsetParsed());
      assertEquals(2000, withChronology.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertNotSame(withPivotYear, withChronology);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintTakingLongReturningEmptyString() throws Throwable  {
      // Create a DateTimeFormatter with a TimeZoneName argument
      DateTimeFormatterBuilder.TimeZoneName timeZoneName = new DateTimeFormatterBuilder.TimeZoneName(1946, (Map<String, DateTimeZone>) null);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(timeZoneName, timeZoneName);
      
      // Print a long value using the DateTimeFormatter
      long value = 2147198495L;
      String result = dateTimeFormatter.print(value);
      assertEquals("2000", result);
      
      // Assert that the default year is set correctly
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      
      // Assert that the offset is not parsed
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMutableDateTimeReturningMutableDateTimeWhereGetMillisIsPositive() throws Throwable  {
      // Given a DateTimeFormatter object
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      
      // When parsing a string "HST"
      MutableDateTime parseMutableDateTime = dateTimeFormatter.parseMutableDateTime("HST");
      
      // Then the milliseconds should be 36000000L
      assertEquals(36000000L, parseMutableDateTime.getMillis());
      
      // And offset parsing should be disabled
      assertFalse(dateTimeFormatter.isOffsetParsed());
      
      // And the default year should be 2000
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZone() throws Throwable  {
      // Given a DateTimeFormatterBuilder.StringLiteral instance representing an empty string and a DateTimeZone instance representing the UTC+4 time zone
      DateTimeFormatterBuilder.StringLiteral stringLiteral = new DateTimeFormatterBuilder.StringLiteral("");
      DateTimeZone utcPlus4 = DateTimeZone.forOffsetMillis(4);
      
      // When creating a DateTimeFormatter instance using the StringLiteral and DateTimeZone instances
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(stringLiteral, stringLiteral);
      
      // Then the resulting DateTimeFormatter instance should have the default year set to 2000 and the offset parsed flag set to false
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      
      // When creating a new DateTimeFormatter instance using the resulting DateTimeFormatter instance and the UTC+4 time zone
      DateTimeFormatter withZone = dateTimeFormatter.withZone(utcPlus4);
      
      // Then the resulting DateTimeFormatter instance should have the offset parsed flag set to false and the default year set to 2000
      assertFalse(withZone.isOffsetParsed());
      assertEquals(2000, withZone.getDefaultYear());
      
      // When parsing an empty string using the resulting DateTimeFormatter instance
      MutableDateTime parseMutableDateTime = withZone.parseMutableDateTime("");
      
      // Then the parsed MutableDateTime instance should have a milliseconds value of -4L
      assertEquals((-4L), parseMutableDateTime.getMillis());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMillisReturningZero() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Instant must not be null");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      long parseMillis = dateTimeFormatter.parseMillis("Instant must not be null");
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(0L, parseMillis);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMillisReturningPositive() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      long parseMillis = dateTimeFormatter.parseMillis("America/New_York");
      assertEquals(18000000L, parseMillis);
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateTimeReturningDateTimeWhereGetMillisIsPositive() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTime parseDateTime = dateTimeFormatter.parseDateTime("HST");
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertEquals(36000000L, parseDateTime.getMillis());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetZoneReturningNonNull() throws Throwable  {
      // Given
      DateTimeFieldType weekOfWeekyear = DateTimeFieldType.weekOfWeekyear();
      DateTimeFormatterBuilder.PaddedNumber paddedNumber = new DateTimeFormatterBuilder.PaddedNumber(weekOfWeekyear, -2098, false, -2098);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(paddedNumber, paddedNumber);
      
      // When
      DateTimeFormatter withZoneUTC = dateTimeFormatter.withZoneUTC();
      DateTimeZone zone = withZoneUTC.getZone();
      
      // Then
      assertFalse(withZoneUTC.isOffsetParsed());
      assertEquals(2000, withZoneUTC.getDefaultYear());
      assertNotNull(zone);
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPrinterReturningNull() throws Throwable  {
      // Given a DateTimeFormatter object with no printer or parser configured
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      
      // When the getPrinter method is called on the formatter
      dateTimeFormatter.getPrinter();
      
      // Then a NullPointerException should be thrown as the formatter does not have a printer configured
      assertThrows(NullPointerException.class, () -> dateTimeFormatter.getPrinter());
      
      // And the isOffsetParsed method should return false
      assertFalse(dateTimeFormatter.isOffsetParsed());
      
      // And the default year should be 2000
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPrinterReturningDateTimePrinterWhereEstimatePrintedLengthIsZero() throws Throwable  {
      // Create a DateTimeFieldType object representing an hour of day
      DateTimeFieldType arg0 = DateTimeFieldType.hourOfDay();
      
      // Create a DateTimeFormatterBuilder object with the hour of day as its fixed number
      DateTimeFormatterBuilder.FixedNumber arg1 = new DateTimeFormatterBuilder.FixedNumber(arg0, 0, true);
      
      // Create a DateTimeFormatter object using the DateTimeFormatterBuilder and the same FixedNumber
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      
      // Test that the default year is 2000
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      
      // Test that the offset is not parsed by the DateTimeFormatter
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPrinterReturningDateTimePrinterWhereEstimatePrintedLengthIsPositive() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFieldType arg0 = DateTimeFieldType.weekOfWeekyear();
      DateTimeFormatterBuilder.FixedNumber arg1 = new DateTimeFormatterBuilder.FixedNumber(arg0, 23118750, false);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getPrinter();
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPrinterReturningDateTimePrinterWhereEstimatePrintedLengthIsNegative() throws Throwable  {
      // Create a DateTimeFieldType object for milliseconds in day
      DateTimeFieldType arg0 = DateTimeFieldType.millisOfDay();
      
      // Create a new DateTimeFormatterBuilder.Fraction instance using the millisecond field type and a negative offset of 36 milliseconds
      DateTimeFormatterBuilder.Fraction arg1 = new DateTimeFormatterBuilder.Fraction(arg0, (-36), (-36));
      
      // Create a new DateTimeFormatter instance using the fraction object and the same fraction object for both the printer and parser
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      
      // Assert that the formatter does not parse an offset
      assertFalse(dateTimeFormatter.isOffsetParsed());
      
      // Assert that the default year is 2000
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPivotYearReturningPositive() throws Throwable  {
      // Given a DateTimeFormat.StyleFormatter object with a negative pivot year
      DateTimeFormat.StyleFormatter arg1 = new DateTimeFormat.StyleFormatter(-1308, 1, -1308);
      
      // When creating a new DateTimeFormatter object with the pivot year set to 1
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      
      // Then the default year should be set to 2000
      Integer arg0 = new Integer(1);
      DateTimeFormatter withPivotYear = dateTimeFormatter.withPivotYear(arg0);
      assertNotNull(withPivotYear.getDefaultYear());
      assertEquals(2000, withPivotYear.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetParserReturningNull() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      dateTimeFormatter.getParser();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetParserReturningDateTimeParserWhereEstimateParsedLengthIsZero() throws Throwable  {
      // Given a DateTimeFormatter object with a fixed number of hours in a day
      DateTimeFieldType hourOfDay = DateTimeFieldType.hourOfDay();
      DateTimeFormatterBuilder.FixedNumber fixedNumber = new DateTimeFormatterBuilder.FixedNumber(hourOfDay, 0, true);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(fixedNumber, fixedNumber);
      
      // When the parser is requested for this formatter
      dateTimeFormatter.getParser();
      
      // Then it should not parse an offset and have a default year of 2000
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetParserReturningDateTimeParserWhereEstimateParsedLengthIsPositive() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getParser();
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetParserReturningDateTimeParserWhereEstimateParsedLengthIsNegative() throws Throwable  {
      // No Comments were added
      DateTimeFieldType arg0 = DateTimeFieldType.weekOfWeekyear();
      DateTimeFormatterBuilder.PaddedNumber arg1 = new DateTimeFormatterBuilder.PaddedNumber(arg0, (-2098), false, (-2098));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getParser();
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLocaleReturningNonNull() throws Throwable  {
      // Given a DateTimeFormatterBuilder.StringLiteral argument representing a date time formatter
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("org.joda.time.format.DateTimeFormatter");
      
      // When a new DateTimeFormatter is created with the StringLiteral argument and a Locale argument
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      Locale arg0 = Locale.CHINESE;
      DateTimeFormatter withLocale = dateTimeFormatter.withLocale(arg0);
      
      // Then the resulting DateTimeFormatter should have a different locale and default year than the original formatter
      assertFalse(withLocale.isOffsetParsed());
      assertEquals(2000, withLocale.getDefaultYear());
      assertNotNull(withLocale.getLocale());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDefaultYearReturningZero() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear(0);
      int defaultYear = withDefaultYear.getDefaultYear();
      assertEquals(0, defaultYear);
      assertFalse(withDefaultYear.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDefaultYearReturningNegative() throws Throwable  {
      // Test that the DateTimeFormatterBuilder can create a PaddedNumber field type with the correct padding and default values
      DateTimeFieldType arg0 = DateTimeFieldType.monthOfYear();
      DateTimeFormatterBuilder.PaddedNumber arg1 = new DateTimeFormatterBuilder.PaddedNumber(arg0, (-2098), false, (-2098));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      
      // Test that the withDefaultYear method returns a DateTimeFormatter with the correct default year
      DateTimeFormatter withDefaultYear = dateTimeFormatter.withDefaultYear((-2098));
      int defaultYear = withDefaultYear.getDefaultYear();
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertEquals((-2098), defaultYear);
      
      // Test that the returned DateTimeFormatter has the correct default year and does not parse offsets
      assertFalse(withDefaultYear.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPivotYearTakingIntegerReturningDateTimeFormatterWhereGetDefaultYearIsPositive() throws Throwable  {
      // Given a DateTimeFormatter instance with pivot year set to -1185
      DateTimeFormatter formatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      int pivotYear = -1185;
      
      // When the withPivotYear method is called on the formatter with parameter pivotYear
      DateTimeFormatter withPivotYear = formatter.withPivotYear(pivotYear);
      
      // Then the default year should be 2000 and offset parsing should not be enabled
      assertEquals(2000, withPivotYear.getDefaultYear());
      assertFalse(withPivotYear.isOffsetParsed());
      
      // And a new instance of DateTimeFormatter should be returned
      assertNotSame(withPivotYear, formatter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintTakingLongReturningNonEmptyString() throws Throwable  {
      // Given
      DateTimeFormatterBuilder.TimeZoneId timeZoneId = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(timeZoneId, timeZoneId);
      
      // When
      dateTimeFormatter.print(-554L);
      
      // Then
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking1And1ThrowsNullPointerException() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.printTo((StringBuffer) null, (-1L));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder$StringLiteral", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintTakingReadablePartial() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Parsing not supportd");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      LocalDateTime arg0 = dateTimeFormatter.parseLocalDateTime("Parsing not supportd");
      dateTimeFormatter.print((ReadablePartial) arg0);
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLocaleReturningNull() throws Throwable  {
      // Given a DateTimeFormatter instance with a default locale of "en_US"
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("org.joda.time.format.DateTimeFormatter");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      assertEquals("en_US", dateTimeFormatter.getLocale());
      
      // When the isOffsetParsed method is called on the DateTimeFormatter instance
      boolean offsetParsed = dateTimeFormatter.isOffsetParsed();
      
      // Then the method returns false, indicating that offsets are not parsed by default
      assertFalse(offsetParsed);
      
      // And when the getDefaultYear method is called on the DateTimeFormatter instance
      int defaultYear = dateTimeFormatter.getDefaultYear();
      
      // Then the method returns 2000, indicating that the default year is set to 2000
      assertEquals(2000, defaultYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesDateTimeFormatter() throws Throwable  {
      // Given: A DateTimeFormatter instance is created using the constructor that takes a StringLiteral as an argument
      DateTimeFormatterBuilder.StringLiteral arg0 = new DateTimeFormatterBuilder.StringLiteral("org.joda.time.format.DateTimeFormatterBuilder$Fraction");
      DateTimeFormatter arg1 = new DateTimeFormatter(arg0, (DateTimeParser) null);
      // When: The LocalDateTime.parse() method is called with a string that matches the format of the DateTimeFormatter instance
      LocalDateTime dateTime = LocalDateTime.parse("org.joda.time.format.DateTimeFormatterBuilder$Fraction", arg1);
      // Then: An UnsupportedOperationException should be thrown, as parsing not supported
      throw new UnsupportedOperationException();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMutableDateTimeReturningMutableDateTimeWhereGetMillisIsZero() throws Throwable  {
      // Create a DateTimeFormatterBuilder with a StringLiteral argument
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("X/U}c+ERsKCC@Z%i");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      
      // Use the withOffsetParsed method to create a new DateTimeFormatter with offset parsing enabled
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      
      // Parse a date-time string using the withOffsetParsed formatter
      MutableDateTime parseMutableDateTime = withOffsetParsed.parseMutableDateTime("X/U}c+ERsKCC@Z%i");
      
      // Assert that the parsed date-time is in the default year and milliseconds are 0
      assertTrue(withOffsetParsed.isOffsetParsed());
      assertEquals(0L, parseMutableDateTime.getMillis());
      
      // Assert that the original DateTimeFormatter does not have offset parsing enabled
      assertFalse(dateTimeFormatter.isOffsetParsed());
      
      // Assert that the withOffsetParsed formatter has a default year of 2000
      assertEquals(2000, withOffsetParsed.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMutableDateTimeThrowsIllegalArgumentException0() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.parseMutableDateTime("Pursing not+supzorted");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \"Pursing not+supzorted\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMutableDateTimeThrowsIllegalArgumentException1() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.parseMutableDateTime("Hawaii Standard Time");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \"Hawaii Standard Time\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneUTC() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral(")[o(7hxg^");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withZoneUTC = dateTimeFormatter.withZoneUTC();
      DateTime parseDateTime = withZoneUTC.parseDateTime(")[o(7hxg^");
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(0L, parseDateTime.getMillis());
      assertNotSame(withZoneUTC, dateTimeFormatter);
      assertFalse(withZoneUTC.isOffsetParsed());
      assertEquals(2000, withZoneUTC.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateTimeAndWithOffsetParsed() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("X/U}c+ERM3sKCC@Z%i");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      DateTime parseDateTime = withOffsetParsed.parseDateTime("X/U}c+ERM3sKCC@Z%i");
      assertEquals(2000, withOffsetParsed.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertTrue(withOffsetParsed.isOffsetParsed());
      assertEquals(0L, parseDateTime.getMillis());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateTimeThrowsIllegalArgumentException() throws Throwable  {
      // Given a DateTimeFormatter that is using a custom format string, "~1:!]wsd9pJL9.52G"
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("~1:!]wsd9pJL9.52G");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // When attempting to parse a string that does not match the expected format
      try {
      // Then an IllegalArgumentException is thrown with a message indicating the invalid format
      dateTimeFormatter.parseDateTime("~1:!]wsd9pJL9.52G");
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      // Then the exception is caught and verified to be an IllegalArgumentException
      // with a message indicating the invalid format
      verifyException("org.joda.time.format.DateTimeFormatter", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateTimeReturningDateTimeWhereGetMillisIsNegative() throws Throwable  {
      // Tests the parsing of a time zone ID with a offset
      DateTimeFormatterBuilder.TimeZoneId timeZoneId = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(timeZoneId, timeZoneId);
      DateTime parseDateTime = dateTimeFormatter.parseDateTime("Africa/Johannesburg");
      assertEquals((-7200000L), parseDateTime.getMillis()); // Checks that the parsed date is equal to the expected value with an offset of -7200000 milliseconds
      assertEquals(2000, dateTimeFormatter.getDefaultYear()); // Checks that the default year of the formatter is set to 2000 as expected
      assertFalse(dateTimeFormatter.isOffsetParsed()); // Checks that the offset parsing is disabled as expected
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseLocalDateTime() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.StringLiteral arg0 = new DateTimeFormatterBuilder.StringLiteral("Printing not supported");
      DateTimeFormatterBuilder.TimeZoneOffset arg1 = new DateTimeFormatterBuilder.TimeZoneOffset("Printing not supported", "Printing not supported", true, 2147450109, 2147450109);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg0, arg1);
      dateTimeFormatter.parseLocalDateTime("Printing not supported");
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseLocalDateTimeThrowsIllegalArgumentException() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.parseLocalDateTime(";)[ohxg");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \";)[ohxg\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test0() throws Throwable  {
      // Test that an exception is thrown when trying to parse a string with an invalid format
      try {
      LocalDateTime.parse(")[o(hxg");
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Verify that the exception is of the correct type and has the expected message
      verifyException("org.joda.time.format.DateTimeFormatter", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseMillisThrowsIllegalArgumentException() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.parseMillis("8Pe");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \"8Pe\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test1() throws Throwable  {
      MutableDateTime mutableDateTime = null;
      try {
      // Create a new MutableDateTime with an invalid format
      mutableDateTime = new MutableDateTime(")[o(7hxg^");
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the correct exception was thrown
      verifyException("org.joda.time.format.DateTimeFormatter", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseIntoWithReadWritableInstantWhereGetMillisIsZero() throws Throwable  {
      // Given the need to test the parsing of a DateTime string with a custom DateTimeFormatter
      DateTimeFormatterBuilder.StringLiteral customFormatter = new DateTimeFormatterBuilder.StringLiteral("Printing not supported");
      
      // When the DateTimeFormatter is created with the custom formatter and zone UTC
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(customFormatter, customFormatter);
      DateTimeFormatter withZoneUTC = dateTimeFormatter.withZoneUTC();
      
      // Then the resulting DateTimeFormatter should have a default year of 2000 and not be offset parsed
      assertEquals(2000, withZoneUTC.getDefaultYear());
      assertFalse(withZoneUTC.isOffsetParsed());
      
      // When the string "Printing not supported" is parsed into the DateTimeFormatter with zone UTC
      MutableDateTime arg0 = withZoneUTC.parseMutableDateTime("Printing not supported");
      int parseInto = withZoneUTC.parseInto(arg0, "Printing not supported", 0);
      
      // Then the resulting DateTime should have a millisecond value of 0 and a year of 2000
      assertEquals(0L, arg0.getMillis());
      assertEquals(2000, withZoneUTC.getDefaultYear());
      
      // And the parseInto method should return a value of 22
      assertEquals(22, parseInto);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseInto() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Xg4!");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      MutableDateTime arg0 = MutableDateTime.now();
      DateTimeFormatter withOffsetParsed = dateTimeFormatter.withOffsetParsed();
      int parseInto = withOffsetParsed.parseInto(arg0, "Xg4!", 0);
      assertEquals(4, parseInto);
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, withOffsetParsed.getDefaultYear());
      assertTrue(withOffsetParsed.isOffsetParsed());
      assertEquals(1392409281320L, arg0.getMillis());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseIntoThrowsIllegalArgumentException() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral(";tfuL&\u0002fg|6qJT\"c8");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Undeclared exception!
      try { 
        dateTimeFormatter.parseInto((ReadWritableInstant) null, ";tfuL&\u0002fg|6qJT\"c8", 1117);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Instant must not be null
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseIntoReturningNegative() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("xU}c[ERsKC@Zi");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      MutableDateTime arg0 = MutableDateTime.now();
      int parseInto = dateTimeFormatter.parseInto(arg0, "xU}c[ERsKC@Zi", 5);
      assertEquals((-6), parseInto);
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertEquals(1392409281320L, arg0.getMillis());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithChronologyWithNonNull() throws Throwable  {
      // Create a new DateTimeFormatterBuilder.StringLiteral instance with an empty string as the literal value
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("");
      
      // Create a new DateTimeFormatter instance using the StringLiteral instance and itself as arguments
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      
      // Get an ISOChronology instance
      ISOChronology arg0 = ISOChronology.getInstance();
      
      // Create a new DateTimeFormatter instance with the ISOChronology instance and itself as arguments
      DateTimeFormatter withChronology = dateTimeFormatter.withChronology(arg0);
      
      // Parse an empty string using the DateTimeFormatter instance with the chronology
      MutableDateTime parseMutableDateTime = withChronology.parseMutableDateTime("");
      
      // Assert that the default year is 2000
      assertEquals(2000, withChronology.getDefaultYear());
      
      // Assert that the milliseconds are equal to 0L
      assertEquals(0L, parseMutableDateTime.getMillis());
      
      // Assert that the chronology is parsed as an offset
      assertFalse(withChronology.isOffsetParsed());
      
      // Assert that the DateTimeFormatter instance with the chronology is not the same as the original DateTimeFormatter instance
      assertNotSame(withChronology, dateTimeFormatter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithLocaleReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      // Create a new DateTimeFormatter with the specified locale
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(null, null);
      Locale arg0 = Locale.PRC;
      DateTimeFormatter withLocale = dateTimeFormatter.withLocale(arg0);
      
      // Verify that the default year is set correctly
      assertEquals(2000, withLocale.getDefaultYear());
      
      // Verify that the offset is not parsed
      assertFalse(withLocale.isOffsetParsed());
      
      // Verify that the returned object is not the same as the original DateTimeFormatter
      assertNotSame(withLocale, dateTimeFormatter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsParserReturningTrue() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFieldType arg0 = DateTimeFieldType.era();
      DateTimeFormatterBuilder.Fraction arg1 = new DateTimeFormatterBuilder.Fraction(arg0, (-8), (-8));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      boolean parser = dateTimeFormatter.isParser();
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertTrue(parser);
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsParserReturningFalse() throws Throwable  {
      // Create a new DateTimeFormatterBuilder.Fraction instance with the given parameters
      DateTimeFormatterBuilder.Fraction fraction = new DateTimeFormatterBuilder.Fraction(null, -1941, 2421);
      
      // Create a new DateTimeFormatter instance using the Fraction instance as its argument
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(fraction, null);
      
      // Test if the DateTimeFormatter is a parser or not
      boolean parser = dateTimeFormatter.isParser();
      
      // Test if the DateTimeFormatter has offset parsed or not
      assertFalse(dateTimeFormatter.isOffsetParsed());
      
      // Test the default year of the DateTimeFormatter
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      
      // Test if the parser is false or not
      assertFalse(parser);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsPrinterReturningTrue() throws Throwable  {
      // Given a DateTimeFormatter with milliseconds precision
      DateTimeFieldType arg0 = DateTimeFieldType.millisOfDay();
      DateTimeFormatterBuilder.Fraction arg1 = new DateTimeFormatterBuilder.Fraction(arg0, (-8), (-8));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      
      // When the formatter is used to print a value
      boolean printer = dateTimeFormatter.isPrinter();
      
      // Then the formatter prints the milliseconds part of the value
      assertTrue(printer);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsPrinterReturningFalse() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.CharacterLiteral arg1 = new DateTimeFormatterBuilder.CharacterLiteral('j');
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, arg1);
      boolean printer = dateTimeFormatter.isPrinter();
      assertFalse(printer);
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetZoneReturningNull() throws Throwable  {
      // No Comments were added
      DateTimeFieldType arg0 = DateTimeFieldType.weekOfWeekyear();
      DateTimeFormatterBuilder.PaddedNumber arg1 = new DateTimeFormatterBuilder.PaddedNumber(arg0, (-2098), false, (-2098));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.getZone();
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPivotYearReturningNull() throws Throwable  {
      // Given a DateTimeFormatter instance with a specific TimeZoneId
      DateTimeFormatterBuilder.TimeZoneId timeZoneId = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(timeZoneId, timeZoneId);
      
      // When the pivot year is requested
      int pivotYear = dateTimeFormatter.getPivotYear();
      
      // Then the default year should be returned
      assertEquals(2000, pivotYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetChronolgy() throws Throwable  {
      // Given a DateTimeFieldType hourOfHalfday and a DateTimeFormatterBuilder.FixedNumber with 0 as the minimum value and false for whether to allow decimals
      DateTimeFieldType arg0 = DateTimeFieldType.hourOfHalfday();
      DateTimeFormatterBuilder.FixedNumber arg1 = new DateTimeFormatterBuilder.FixedNumber(arg0, 0, false);
      
      // When a new DateTimeFormatter is created with the FixedNumber and itself as the chronology
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      
      // Then the chronology should be set to 2000 and the offset should not be parsed
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithZoneUTCReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      // Given a DateTimeFormatter instance created without any offset parsing
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      
      // When we call the withZoneUTC() method on this formatter
      DateTimeFormatter withZoneUTC = dateTimeFormatter.withZoneUTC();
      
      // Then the result is a new DateTimeFormatter instance that has the same settings as the original one
      assertNotSame(withZoneUTC, dateTimeFormatter);
      
      // And the new formatter does not parse any offset information
      assertFalse(withZoneUTC.isOffsetParsed());
      
      // And the default year is set to 2000 for both formatters
      assertEquals(2000, withZoneUTC.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDefaultYearReturningPositive() throws Throwable  {
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      int defaultYear = dateTimeFormatter.getDefaultYear(); //Get the default year for the specified time zone and format
      assertEquals(2000, defaultYear); //Check that the default year is 2000
      assertFalse(dateTimeFormatter.isOffsetParsed()); //Check that the offset is not parsed
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsOffsetParsed() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFieldType arg0 = DateTimeFieldType.era();
      DateTimeFormatterBuilder.Fraction arg1 = new DateTimeFormatterBuilder.Fraction(arg0, (-8), (-8));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      boolean offsetParsed = dateTimeFormatter.isOffsetParsed();
      assertFalse(offsetParsed);
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintTakingReadableInstant() throws Throwable  {
      // Test that the DateTimeFormatterBuilder can create a DateTimeFormatter with the expected behavior for TimeZoneName.
      DateTimeFormatterBuilder.TimeZoneName arg1 = new DateTimeFormatterBuilder.TimeZoneName(1946, (Map<String, DateTimeZone>) null);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      assertEquals(2000, dateTimeFormatter.getDefaultYear()); // Assert that the default year is set correctly.
      assertFalse(dateTimeFormatter.isOffsetParsed()); // Assert that offset parsing is not enabled.
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithPivotYearTakingIntReturningDateTimeFormatterWhereIsParserIsFalse() throws Throwable  {
      // Given a DateTimeFormatter with no pivot year set
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, (DateTimeParser) null);
      
      // When the withPivotYear method is called with the value 2022
      DateTimeFormatter withPivotYear = dateTimeFormatter.withPivotYear(2022);
      
      // Then the resulting formatter should have a pivot year of 2022 and offset parsing disabled
      assertFalse(withPivotYear.isOffsetParsed());
      
      // And the formatter should be a new instance, not equal to the original formatter
      assertNotSame(withPivotYear, dateTimeFormatter);
      
      // And the default year of the resulting formatter should be 2000
      assertEquals(2000, withPivotYear.getDefaultYear());
      
      // And the pivot year of the resulting formatter should be 2022
      assertEquals(2022, (int) withPivotYear.getPivotYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithLocaleWithNull() throws Throwable  {
      // Given a DateTimeFormatter with default locale
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(DateTimeFormatterBuilder.TimeZoneId.INSTANCE, null);
      
      // When calling withLocale method
      DateTimeFormatter withLocale = dateTimeFormatter.withLocale((Locale) null);
      
      // Then the result should be a new instance of DateTimeFormatter with the given locale
      assertNotSame(dateTimeFormatter, withLocale);
      assertEquals(2000, withLocale.getDefaultYear());
      assertFalse(withLocale.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking1And1ThrowsUnsupportedOperationException() throws Throwable  {
      // Setup
      DateTimeFieldType arg0 = DateTimeFieldType.era();
      DateTimeFormatterBuilder.Fraction arg1 = new DateTimeFormatterBuilder.Fraction(arg0, (-518), (-518));
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter((DateTimePrinter) null, arg1);
      
      // Test
      try {
      dateTimeFormatter.printTo((Writer) null, (long) (-518));
      fail("Expecting exception: UnsupportedOperationException");
      } catch(UnsupportedOperationException e) {
      // Printing not supported
      verifyException("org.joda.time.format.DateTimeFormatter", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseLocalDate() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Xg4!");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.parseLocalDate("Xg4!");
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
      assertFalse(dateTimeFormatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseLocalTime() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.StringLiteral arg1 = new DateTimeFormatterBuilder.StringLiteral("Pricting no supported");
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.parseLocalTime("Pricting no supported");
      assertFalse(dateTimeFormatter.isOffsetParsed());
      assertEquals(2000, dateTimeFormatter.getDefaultYear());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetChronology() throws Throwable  {
      // Create a new Partial object with a year field
      DateTimeFieldType arg0 = DateTimeFieldType.year();
      Partial partial = new Partial(arg0, 0, (Chronology) null);
      
      // Get the formatter for the partial date
      DateTimeFormatter formatter = partial.getFormatter();
      
      // Test that the default year is set correctly
      assertEquals(2000, formatter.getDefaultYear());
      
      // Test that the offset is not parsed by the formatter
      assertFalse(formatter.isOffsetParsed());
  }
}
