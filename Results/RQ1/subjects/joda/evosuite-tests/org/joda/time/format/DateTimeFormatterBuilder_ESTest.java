/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 07:45:28 GMT 2024
 */

package org.joda.time.format;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.CharArrayWriter;
import java.io.IOException;
import java.io.PipedWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Locale;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFileWriter;
import org.evosuite.runtime.mock.java.io.MockPrintWriter;
import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeFieldType;
import org.joda.time.DateTimeZone;
import org.joda.time.Instant;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import org.joda.time.MonthDay;
import org.joda.time.Partial;
import org.joda.time.ReadablePartial;
import org.joda.time.YearMonth;
import org.joda.time.chrono.BuddhistChronology;
import org.joda.time.chrono.CopticChronology;
import org.joda.time.chrono.EthiopicChronology;
import org.joda.time.chrono.GJChronology;
import org.joda.time.chrono.GregorianChronology;
import org.joda.time.chrono.ISOChronology;
import org.joda.time.chrono.IslamicChronology;
import org.joda.time.chrono.JulianChronology;
import org.joda.time.chrono.StrictChronology;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.DateTimeFormatterBuilder;
import org.joda.time.format.DateTimeParser;
import org.joda.time.format.DateTimeParserBucket;
import org.joda.time.format.DateTimePrinter;
import org.joda.time.tz.FixedDateTimeZone;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class DateTimeFormatterBuilder_ESTest extends DateTimeFormatterBuilder_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesMatchingParserTakingDateTimeParserArrayAndCallsParseInto() throws Throwable  {
      // Given a DateTimeParser[] arg0 and a DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser instance
      DateTimeParser[] arg0 = new DateTimeParser[2];
      DateTimeFormatterBuilder.MatchingParser dateTimeFormatterBuilder_MatchingParser = new DateTimeFormatterBuilder.MatchingParser(arg0);
      
      // When parsing the input string "utJ<OnJ" with the MatchingParser and an invalid bucket (null)
      try {
      dateTimeFormatterBuilder_MatchingParser.parseInto((DateTimeParserBucket) null, "utJ<OnJ", 2819);
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Then an exception is thrown with a message indicating the invalid bucket (null) was passed in
      verifyException("org.joda.time.format.DateTimeFormatterBuilder$MatchingParser", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesCompositeTakingListAndCallsEstimatePrintedLength() throws Throwable  {
      // Given: A new instance of DateTimeFormatterBuilder.Composite is created with an empty list of objects as argument.
      LinkedList<Object> arg0 = new LinkedList<>();
      DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite = new DateTimeFormatterBuilder.Composite(arg0);
      
      // When: The estimatePrintedLength method is called on the Composite instance.
      int estimatePrintedLength = dateTimeFormatterBuilder_Composite.estimatePrintedLength();
      
      // Then: The returned value should be 0, as there are no components in the list of objects.
      assertEquals(0, estimatePrintedLength);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11And1AndPrintToTaking11And1AndCreatesCharacterLiteralTakingChar0() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral = new DateTimeFormatterBuilder.CharacterLiteral('B');
      StringWriter stringWriter = new StringWriter(5);
      StringBuffer arg0 = stringWriter.getBuffer();
      YearMonth arg1 = YearMonth.now();
      Locale arg2 = Locale.GERMAN;
      dateTimeFormatterBuilder_CharacterLiteral.printTo(arg0, (ReadablePartial) arg1, arg2);
      assertEquals("B", arg0.toString());
      assertEquals("B", stringWriter.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesCharacterLiteralTakingCharAndCallsEstimatePrintedLength() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral = new DateTimeFormatterBuilder.CharacterLiteral(')');
      int estimatePrintedLength = dateTimeFormatterBuilder_CharacterLiteral.estimatePrintedLength();
      assertEquals(1, estimatePrintedLength);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendDayOfYearAndAppendTimeZoneShortName() throws Throwable  {
      // Given a DateTimeFormatterBuilder and a DateTimeFormatter,
      // we want to ensure that the formatter is not a parser.
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatter formatter = dateTimeFormatterBuilder.toFormatter();
      assertFalse(formatter.isParser());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendMonthOfYear() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the appendMonthOfYear method is called with an integer argument of 12
      DateTimeFormatterBuilder appendMonthOfYear = dateTimeFormatterBuilder.appendMonthOfYear(12);
      
      // Then the same DateTimeFormatterBuilder object should be returned
      assertSame(dateTimeFormatterBuilder, appendMonthOfYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendLiteralTakingChar() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the appendLiteral method is called with a character literal
      DateTimeFormatterBuilder appendLiteral = dateTimeFormatterBuilder.appendLiteral('2');
      
      // Then the return value should be the same as the DateTimeFormatterBuilder instance
      assertSame(appendLiteral, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFractionOfHour() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When we appendFractionOfHour method is called with 1 and 0 parameters
      DateTimeFormatterBuilder appendFractionOfHour = dateTimeFormatterBuilder.appendFractionOfHour(1, 0);
      
      // Then the return value should be the same as the original DateTimeFormatterBuilder object
      assertSame(appendFractionOfHour, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendDayOfMonth() throws Throwable  {
      // Given a DateTimeFormatterBuilder object named "dateTimeFormatterBuilder"
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When we append the day of month (28th) to the formatter builder
      DateTimeFormatterBuilder appendDayOfMonth = dateTimeFormatterBuilder.appendDayOfMonth(28);
      
      // Then the returned object should be the same as the original formatter builder, which is "dateTimeFormatterBuilder"
      assertSame(appendDayOfMonth, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTaking1And1() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormat.StyleFormatter arg1 = new DateTimeFormat.StyleFormatter((-2546), (-466), 9);
      DateTimeFormatterBuilder append = dateTimeFormatterBuilder.append((DateTimePrinter) arg1, (DateTimeParser) arg1);
      assertSame(append, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToFormatter() throws Throwable  {
      // Create a new instance of the DateTimeFormatterBuilder class
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // Set the day of week field with a minimum width of 57 and maximum width of 115
      DateTimeFieldType arg0 = DateTimeFieldType.dayOfWeek();
      DateTimeFormatterBuilder appendSignedDecimal = dateTimeFormatterBuilder.appendSignedDecimal(arg0, 57, 115);
      
      // Build the formatter from the builder
      DateTimeFormatter formatter = appendSignedDecimal.toFormatter();
      
      // Assert that the formatter is a printer
      assertTrue(formatter.isPrinter());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFractionWithZeroAndZero() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFieldType arg0 = DateTimeFieldType.clockhourOfHalfday();
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder.appendFraction(arg0, 0, 0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFraction() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance and a DateTimeFieldType argument
      DateTimeFormatterBuilder dtfb = new DateTimeFormatterBuilder();
      DateTimeFieldType dtft = DateTimeFieldType.secondOfMinute();
      
      // When a fraction is appended to the formatter builder with the field type and precision values
      DateTimeFormatterBuilder appendFraction = dtfb.appendFraction(dtft, 2054, (-1989));
      
      // Then the returned builder should be the same as the original instance
      assertSame(appendFraction, dtfb);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendShortText() throws Throwable  {
      // Given a DateTimeFieldType "era" and a DateTimeFormatterBuilder instance
      DateTimeFieldType era = DateTimeFieldType.era();
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the appendShortText method is called with the field type as argument
      DateTimeFormatterBuilder appendShortText = dateTimeFormatterBuilder.appendShortText(era);
      
      // Then the same instance of the DateTimeFormatterBuilder should be returned
      assertSame(appendShortText, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendText() throws Throwable  {
      // Given a DateTimeFormatterBuilder and a DateTimeFieldType
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFieldType arg0 = DateTimeFieldType.clockhourOfDay();
      
      // When the appendText method is called with the DateTimeFieldType
      DateTimeFormatterBuilder appendText = dateTimeFormatterBuilder.appendText(arg0);
      
      // Then the same DateTimeFormatterBuilder instance should be returned
      assertSame(dateTimeFormatterBuilder, appendText);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSignedDecimalWithNegativeAndAppendSignedDecimal() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When a signed decimal field is appended to the builder
      DateTimeFieldType hourOfHalfday = DateTimeFieldType.hourOfHalfday();
      DateTimeFormatterBuilder appendSignedDecimal = dateTimeFormatterBuilder.appendSignedDecimal(hourOfHalfday, 1, (-455));
      
      // Then the resulting formatter should be the same as the original builder
      assertSame(dateTimeFormatterBuilder, appendSignedDecimal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSignedDecimalWithNegativeAndAppendSignedDecimalThrowsIllegalArgumentException() throws Throwable  {
      // Test that an exception is thrown when the arguments are invalid
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFieldType arg0 = DateTimeFieldType.dayOfWeek();
      try {
      dateTimeFormatterBuilder.appendSignedDecimal(arg0, -5, 115);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // no message in exception (getMessage() returned null)
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendDecimalWithPositive() throws Throwable  {
      // Given a DateTimeFieldType representing the second of minute field
      DateTimeFieldType arg0 = DateTimeFieldType.secondOfMinute();
      
      // When creating a new DateTimeFormatterBuilder with a decimal precision of 30 and a maximum value of 120
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatterBuilder appendDecimal = dateTimeFormatterBuilder.appendDecimal(arg0, 30, 120);
      
      // Then the returned DateTimeFormatterBuilder should be the same as the original one
      assertSame(appendDecimal, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendDecimalWithZeroAndAppendDecimal() throws Throwable  {
      // Given a DateTimeFieldType object representing seconds in a minute,
      DateTimeFieldType arg0 = DateTimeFieldType.secondOfMinute();
      
      // And a DateTimeFormatterBuilder instance with an empty format string,
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the appendDecimal method is called with the given field type and a precision of 1 decimal place,
      DateTimeFormatterBuilder appendDecimal = dateTimeFormatterBuilder.appendDecimal(arg0, 1, 0);
      
      // Then the same instance of DateTimeFormatterBuilder should be returned, indicating that the format string has been updated successfully.
      assertSame(dateTimeFormatterBuilder, appendDecimal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendYear() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When appending a year with a specific length
      DateTimeFormatterBuilder appendYear = dateTimeFormatterBuilder.appendYear(2023, 4);
      
      // Then the same DateTimeFormatterBuilder object is returned
      assertSame(dateTimeFormatterBuilder, appendYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTwoDigitYearTaking2Arguments() throws Throwable  {
      // Create a new DateTimeFormatterBuilder and append a two-digit year format
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatterBuilder appendTwoDigitYear = dateTimeFormatterBuilder.appendTwoDigitYear(10, true);
      
      // Assert that the returned value is the same as the input parameter
      assertSame(appendTwoDigitYear, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesCompositeTakingListAndCallsParseInto() throws Throwable  {
      // Test that a DateTimeParserBucket is required for parsing into a Composite date time formatter
      LinkedList<Object> arg0 = new LinkedList<Object>();
      DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite = new DateTimeFormatterBuilder.Composite(arg0);
      // Try to parse "en" with an invalid parser bucket (null) and expect an UnsupportedOperationException
      try {
      dateTimeFormatterBuilder_Composite.parseInto((DateTimeParserBucket) null, "en", 11);
      fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
      // Verify that the expected exception was thrown
      verifyException("org.joda.time.format.DateTimeFormatterBuilder$Composite", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesCompositeTakingListAndCallsPrintToTaking11And1() throws Throwable  {
      Locale arg2 = Locale.CHINESE;
      LinkedList<Object> arg0 = new LinkedList<Object>();
      DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite = new DateTimeFormatterBuilder.Composite(arg0);
      
      // Test that an exception is thrown when attempting to print a composite formatter with null arguments.
      try {
      // Print the formatter using a null writer and null partial object, expecting an UnsupportedOperationException.
      dateTimeFormatterBuilder_Composite.printTo((Writer) null, (ReadablePartial) null, arg2);
      } catch(UnsupportedOperationException e) {
      // Verify that the exception is thrown as expected.
      verifyException("org.joda.time.format.DateTimeFormatterBuilder$Composite", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesCompositeTakingListAndCallsPrintToTaking11111And10() throws Throwable  {
      // No Comments were added
      LinkedList<Object> arg0 = new LinkedList<Object>();
      DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite = new DateTimeFormatterBuilder.Composite(arg0);
      JulianChronology arg2 = JulianChronology.getInstanceUTC();
      FixedDateTimeZone arg4 = (FixedDateTimeZone)DateTimeZone.UTC;
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder_Composite.printTo((Writer) null, (-3604L), (Chronology) arg2, 3, (DateTimeZone) arg4, (Locale) null);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder$Composite", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesCompositeTakingListAndCallsPrintToTaking11111And11() throws Throwable  {
      // rollbacked to evosuite
      EthiopicChronology arg2 = EthiopicChronology.getInstanceUTC();
      LinkedList<Object> arg0 = new LinkedList<Object>();
      DateTimeFormatterBuilder.Composite dateTimeFormatterBuilder_Composite = new DateTimeFormatterBuilder.Composite(arg0);
      FixedDateTimeZone arg4 = (FixedDateTimeZone)DateTimeZone.UTC;
      Locale arg5 = Locale.ITALIAN;
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder_Composite.printTo((StringBuffer) null, (long) 1, (Chronology) arg2, 1, (DateTimeZone) arg4, arg5);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder$Composite", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11111And1AndPrintToTaking11111And10() throws Throwable  {
      CharArrayWriter writer = new CharArrayWriter(3021);
      Locale locale = Locale.FRENCH;
      CopticChronology chrono = CopticChronology.getInstanceUTC();
      DateTimeParserBucket bucket = new DateTimeParserBucket(1293L, chrono, locale, (Integer) 0, 3021);
      DateTimeZone zone = bucket.getZone();
      DateTimeFormatterBuilder.TimeZoneId timeZoneId = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      timeZoneId.printTo((Writer) writer, (-2009L), chrono, 93, zone, locale);
      assertEquals(3, writer.size());
      assertEquals("UTC", writer.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11111And1() throws Throwable  {
      // This test is meant to verify that a null writer throws a NullPointerException
      // when passed to the printTo method of a DateTimeFormatterBuilder$TimeZoneId instance
      
      EthiopicChronology arg0 = EthiopicChronology.getInstance();
      StrictChronology arg2 = StrictChronology.getInstance(arg0);
      DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      
      try {
      // This line is expected to throw a NullPointerException
      dateTimeFormatterBuilder_TimeZoneId.printTo((Writer) null, 10000000000000000L, (Chronology) arg2, 3136, (DateTimeZone) null, (Locale) null);
      
      // If the exception is not thrown, fail the test with a message
      fail("Expecting NullPointerException");
      } catch(NullPointerException e) {
      // If the exception is thrown, verify that it is an instance of NullPointerException
      verifyException("org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId", e);
      
      // If the exception is thrown, but there's no message in it (getMessage() returned null),
      // fail the test with a custom message
      if(e.getMessage() == null) {
      fail("NullPointerException was thrown without a message");}}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test0() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.TimeZoneId arg1 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      dateTimeFormatter.print(1319L);
      assertEquals(32, arg1.estimatePrintedLength());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11111And1AndPrintToTaking11111And11() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      StringBuffer arg0 = new StringBuffer("CDTUShMountain");
      ISOChronology arg2 = ISOChronology.getInstance((DateTimeZone) null);
      Locale arg5 = Locale.ENGLISH;
      dateTimeFormatterBuilder_TimeZoneId.printTo(arg0, 3413L, (Chronology) arg2, (-292269337), (DateTimeZone) null, arg5);
      assertEquals("eng", arg5.getISO3Language());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneNameTaking2Arguments0() throws Throwable  {
      // Create a DateTimeFormatterBuilder with a TimeZoneName argument.
      DateTimeFormatterBuilder.TimeZoneName arg1 = new DateTimeFormatterBuilder.TimeZoneName(3600, (Map<String, DateTimeZone>) null);
      // Create a DateTimeFormatter using the TimeZoneName argument.
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      // Print the number of hours in a day (3600) with the formatter.
      String printedString = dateTimeFormatter.print((long) 3600);
      // Assert that the estimated printed length is equal to 20.
      assertEquals(20, arg1.estimatePrintedLength());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsParseInto() throws Throwable  {
      // Create a DateTimeFormatterBuilder.TimeZoneOffset object with the timezone "PDT" and a custom format string
      DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("PDT", "hB/", false, 1687, 1687);
      
      // Parse the input string "PDT" with the custom format string and the provided timezone offset
      int parseInto = dateTimeFormatterBuilder_TimeZoneOffset.parseInto((DateTimeParserBucket) null, "PDT", 1687);
      
      // Assert that the parsed value is equal to the expected offset
      assertEquals((-1688), parseInto);
      
      // Assert that the estimated length of the parsed value is equal to the expected length
      assertEquals(10, dateTimeFormatterBuilder_TimeZoneOffset.estimateParsedLength());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test1() throws Throwable  {
      // Parse an instant from a string representation
      Instant parse = Instant.parse("2018-06-30T12:34:56Z");
      
      // Verify that the parsed instant has the expected millisecond value
      assertEquals(1530362096000L, parse.getMillis());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And10() throws Throwable  {
      // Given a DateTimeParserBucket with a valid datetime zone
      BuddhistChronology chronology = BuddhistChronology.getInstance();
      Locale locale = Locale.CHINESE;
      DateTimeParserBucket bucket = new DateTimeParserBucket(24L, chronology, locale, (Integer) 1, 1);
      DateTimeZone zone = bucket.getZone();
      
      // When the method printTo is called with a writer and the correct parameters
      CharArrayWriter writer = new CharArrayWriter();
      DateTimeFormatterBuilder.TimeZoneOffset timeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("PDTUS/Pacific-New", "The datetime zone must not be null", false, 3, 3);
      timeZoneOffset.printTo((Writer) writer, (long) 1, (Chronology) chronology, 1, zone, locale);
      
      // Then the output should be "+000000" and the size of the char array writer should be 7
      assertEquals("+000000", writer.toString());
      assertEquals(7, writer.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And11() throws Throwable  {
      // Given
      EthiopicChronology chronology = EthiopicChronology.getInstance();
      DateTimeZone zone = chronology.getZone();
      Locale locale = Locale.GERMANY;
      
      // When
      CharArrayWriter writer = new CharArrayWriter();
      DateTimeFormatterBuilder.TimeZoneOffset timeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("Singapore", "Singapore", false, 3, 50);
      timeZoneOffset.printTo(writer, (long) 50, chronology, 50, zone, locale);
      
      // Then
      assertEquals("+000000050", writer.toString());
      assertEquals(10, writer.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And12() throws Throwable  {
      // No Comments were added
      StringWriter arg0 = new StringWriter();
      Locale arg5 = Locale.CHINESE;
      CopticChronology arg1 = CopticChronology.getInstanceUTC();
      DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(1, arg1, arg5, (Integer) 1, 4);
      DateTimeZone arg4 = dateTimeParserBucket.getZone();
      GregorianChronology arg2 = GregorianChronology.getInstance();
      DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("m&\"`h", "hIh*Ip;", true, 1, 4);
      dateTimeFormatterBuilder_TimeZoneOffset.printTo((Writer) arg0, (long) 4, (Chronology) arg2, 3600000, arg4, arg5);
      assertEquals("+01", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And13() throws Throwable  {
      // This test case verifies that the TimeZoneOffset formatter prints the correct offset for a given date and time zone
      EthiopicChronology ethiopicChronology = EthiopicChronology.getInstance();
      DateTimeZone dateTimeZone = ethiopicChronology.getZone();
      Locale locale = Locale.GERMANY;
      DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("US/Pacific", ".:`</.$b7g.PP", true, 1, 1);
      CharArrayWriter charArrayWriter = new CharArrayWriter(1);
      dateTimeFormatterBuilder_TimeZoneOffset.printTo((Writer) charArrayWriter, 10L, (Chronology) ethiopicChronology, 1, dateTimeZone, locale);
      assertEquals(3, charArrayWriter.size());
      assertEquals("+00", charArrayWriter.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And14() throws Throwable  {
      // Create a new DateTimeFormatterBuilder.TimeZoneOffset with the specified parameters
      DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("m<)>7", "m<)>7", true, 4233, 4233);
      
      // Get an instance of the IslamicChronology using UTC as the base chronology
      Chronology arg2 = IslamicChronology.getInstanceUTC();
      
      // Create a new FixedDateTimeZone with the specified parameters
      DateTimeZone arg4 = (FixedDateTimeZone)DateTimeZone.UTC;
      
      // Create a new Locale using the specified parameters
      Locale arg5 = Locale.UK;
      
      // Create a new CharArrayWriter to print the date and time to
      CharArrayWriter arg0 = new CharArrayWriter();
      
      // Print the date and time to the CharArrayWriter using the DateTimeFormatterBuilder.TimeZoneOffset
      dateTimeFormatterBuilder_TimeZoneOffset.printTo((Writer) arg0, (long) 3, (Chronology) arg2, (-1415), (DateTimeZone) arg4, arg5);
      
      // Assert that the size of the CharArrayWriter is equal to the estimated printed length of the DateTimeFormatterBuilder.TimeZoneOffset
      assertEquals(dateTimeFormatterBuilder_TimeZoneOffset.estimatePrintedLength(), arg0.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And15() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("PDTUS/Pacific-New", "org.joda.time.field.BaseDateTimeField", false, 2, 2);
      CharArrayWriter arg0 = new CharArrayWriter();
      EthiopicChronology arg2 = EthiopicChronology.getInstanceUTC();
      dateTimeFormatterBuilder_TimeZoneOffset.printTo((Writer) arg0, 72L, (Chronology) arg2, 1, (DateTimeZone) null, (Locale) null);
      assertEquals(0, arg0.size());
      assertEquals("", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And16() throws Throwable  {
      // Given a DateTimeFormatterBuilder.TimeZoneOffset instance with a specific pattern and time zone offset
      DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("-PJTh^7zWF0N*97-{w", "-PJTh^7zWF0N*97-{w", true, 3, 3);
      
      // And a character array writer to store the printed output
      CharArrayWriter arg0 = new CharArrayWriter();
      
      // When the printTo method is called with a specific date and time zone offset
      dateTimeFormatterBuilder_TimeZoneOffset.printTo((Writer) arg0, (-3944L), BuddhistChronology.getInstance(), 0, DateTimeZone.getDefault(), (Locale) null);
      
      // Then the method should return the expected output
      assertEquals(18, arg0.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And17() throws Throwable  {
      BuddhistChronology chronology = BuddhistChronology.getInstance();
      Locale locale = Locale.CHINESE;
      DateTimeParserBucket bucket = new DateTimeParserBucket(24L, chronology, locale, 1, 1);
      StringBuffer buffer = new StringBuffer("The datetime zone must not be null");
      CopticChronology copticChronology = CopticChronology.getInstanceUTC();
      DateTimeZone zone = bucket.getZone();
      
      // Given: we have a DateTimeParserBucket object with a specified chronology and locale
      // And: we have a StringBuffer to hold the output of the printTo method
      // When: we call the printTo method on the DateTimeFormatterBuilder.TimeZoneOffset object
      // Then: we expect the buffer to contain the expected string, which is "The datetime zone must not be null-000000"
      DateTimeFormatterBuilder.TimeZoneOffset timeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("PDTUS/Pacific-New", "The datetime zone must not be null", false, 3, 3);
      timeZoneOffset.printTo(buffer, 1L, copticChronology, -882, zone, locale);
      assertEquals("The datetime zone must not be null-000000", buffer.toString());
      assertEquals(41, buffer.length());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And18() throws Throwable  {
      // Given a DateTimeFormatterBuilder.TimeZoneOffset instance with a fixed offset of 3600000 milliseconds
      DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("US/Hawaii", "US/Hawaii", false, 3600000, 3600000);
      
      // And a StringBuffer to hold the formatted output
      StringBuffer arg0 = new StringBuffer();
      
      // And a Chronology instance representing the Islamic calendar system
      IslamicChronology arg2 = IslamicChronology.getInstance();
      
      // And a DateTimeZone instance representing the UTC time zone
      FixedDateTimeZone arg4 = (FixedDateTimeZone)DateTimeZone.UTC;
      
      // And a Locale instance representing the US locale
      Locale arg5 = Locale.US;
      
      // When we call printTo() with the following arguments:
      dateTimeFormatterBuilder_TimeZoneOffset.printTo(arg0, (long) 1, (Chronology) arg2, 3600000, (DateTimeZone) arg4, arg5);
      
      // Then the output is formatted as a time zone offset with a fixed offset of 3600000 milliseconds
      assertEquals(19, arg0.length());
      assertEquals("US/Hawaii+010000000", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And19() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("Singapore", "*k`'W5_6*#pu,47ui", false, 2, 2);
      StringBuffer arg0 = new StringBuffer("6|LK_/VIs");
      IslamicChronology arg2 = IslamicChronology.getInstance();
      FixedDateTimeZone arg4 = (FixedDateTimeZone)DateTimeZone.UTC;
      Locale arg5 = Locale.FRANCE;
      dateTimeFormatterBuilder_TimeZoneOffset.printTo(arg0, (long) 2, (Chronology) arg2, 1, (DateTimeZone) arg4, arg5);
      assertEquals(14, arg0.length());
      assertEquals("6|LK_/VIs+0000", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5Arguments0() throws Throwable  {
      // Create a new DateTimeFormatterBuilder.TimeZoneOffset with null values for the time zone id and display name
      DateTimeFormatterBuilder.TimeZoneOffset offset = new DateTimeFormatterBuilder.TimeZoneOffset(null, null, true, 43, 48);
      
      // Create a new DateTimeFormatter using the TimeZoneOffset
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(offset, offset);
      
      // Print a long value (in this case 828) using the DateTimeFormatter
      String printedValue = dateTimeFormatter.print((long) 828);
      
      // Assert that the printed value is "+00:00:00.000"
      assertEquals("+00:00:00.000", printedValue);
      
      // Assert that the estimated length of the printed value is 13 characters
      assertEquals(13, offset.estimatePrintedLength());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And110() throws Throwable  {
      // Get an instance of the EthiopicChronology class
      EthiopicChronology arg2 = EthiopicChronology.getInstance();
      
      // Get the time zone associated with the Ethiopic chronology
      DateTimeZone arg4 = arg2.getZone();
      
      // Create a new instance of the DateTimeFormatterBuilder.TimeZoneOffset class with the appropriate parameters
      DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("", "", false, 1, 1);
      
      // Get the current locale
      Locale arg5 = Locale.FRANCE;
      
      // Create a new string buffer to hold the formatted time zone offset
      StringBuffer arg0 = new StringBuffer();
      
      // Print the time zone offset to the string buffer using the specified chronology, date/time and locale
      dateTimeFormatterBuilder_TimeZoneOffset.printTo(arg0, (long) 1, (Chronology) arg2, 1, arg4, arg5);
      
      // Assert that the length of the formatted time zone offset is 3 characters long
      assertEquals(3, arg0.length());
      
      // Assert that the formatted time zone offset is "+00"
      assertEquals("+00", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And111() throws Throwable  {
      // Create a new instance of DateTimeFormatterBuilder.TimeZoneOffset with the default locale and time zone.
      DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("*r\u0002+$@?=wy9psJUnl'", "*r\u0002+$@?=wy9psJUnl'", true, 3600000, 3600000);
      
      // Create a new StringBuffer with a capacity of 3600000.
      StringBuffer arg0 = new StringBuffer(3600000);
      
      // Get an instance of the IslamicChronology class with the UTC time zone.
      IslamicChronology arg2 = IslamicChronology.getInstanceUTC();
      
      // Get a fixed date time zone object from the DateTimeZone class.
      FixedDateTimeZone arg4 = (FixedDateTimeZone)DateTimeZone.UTC;
      
      // Set the locale to French.
      Locale arg5 = Locale.FRANCE;
      
      // Print the formatted string representation of the given instant, chronology, and time zone to the StringBuffer arg0.
      dateTimeFormatterBuilder_TimeZoneOffset.printTo(arg0, (long) 3600000, (Chronology) arg2, (-1), (DateTimeZone) arg4, arg5);
      
      // Assert that the formatted string is equal to "-00:00:00.001".
      assertEquals("-00:00:00.001", arg0.toString());
      
      // Assert that the length of the StringBuffer is 13.
      assertEquals(13, arg0.length());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11111And112() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("US/Hawaii", "US/Hawaii", true, 3600000, 3600000);
      StringBuffer arg0 = new StringBuffer(3600000);
      IslamicChronology arg2 = IslamicChronology.getInstanceUTC();
      Locale arg5 = Locale.FRANCE;
      dateTimeFormatterBuilder_TimeZoneOffset.printTo(arg0, 238L, (Chronology) arg2, 1, (DateTimeZone) null, arg5);
      assertEquals(0, arg0.length());
      assertEquals(13, dateTimeFormatterBuilder_TimeZoneOffset.estimateParsedLength());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendHalfdayOfDayText() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When appending halfday of day text
      DateTimeFormatterBuilder appendHalfdayOfDayText = dateTimeFormatterBuilder.appendHalfdayOfDayText();
      
      // And appending time zone offset
      DateTimeFormatterBuilder appendTimeZoneOffset = appendHalfdayOfDayText.appendTimeZoneOffset("org.joda.time.format.DateTimeFormatterBuilder$Fraction", "GJChronology", false, 3600000, 3600000);
      
      // Then the printer should have an estimated parsed length of 74 characters and printed length of 74 characters
      DateTimeFormatterBuilder.Composite printer = (DateTimeFormatterBuilder.Composite)appendTimeZoneOffset.toPrinter();
      assertEquals(74, printer.estimateParsedLength());
      assertEquals(74, printer.estimatePrintedLength());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5Arguments1() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.TimeZoneOffset arg1 = new DateTimeFormatterBuilder.TimeZoneOffset((String) null, "US/MichiganUS/Pacific-New", false, 1, 3366);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      String print = dateTimeFormatter.print((-2356L));
      assertEquals(4, arg1.estimateParsedLength());
      assertEquals("+00", print);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTimeZoneOffsetTaking4ArgumentsThrowsIllegalArgumentException() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder.appendTimeZoneOffset("YearWeekDayTime", false, 43, 1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTimeZoneOffsetTaking5ArgumentsThrowsIllegalArgumentException() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When we attempt to append a time zone offset using an invalid pattern
      try {
      // Undeclared exception!
      dateTimeFormatterBuilder.appendTimeZoneOffset("M}c&RW^n", "M}c&RW^n", true, (-1119), (-1119));
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Then an IllegalArgumentException is thrown with a null message
      verifyException("org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFractionTaking3ArgumentsAndCallsPrintToTaking11And10() throws Throwable  {
      // Arrange
      DateTimeFieldType arg0 = DateTimeFieldType.minuteOfHour();
      Locale arg2 = Locale.ROOT;
      DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction = new DateTimeFormatterBuilder.Fraction(arg0, 2, 2);
      LocalDateTime arg1 = LocalDateTime.now();
      
      // Act and Assert
      try {
      dateTimeFormatterBuilder_Fraction.printTo((StringBuffer) null, (ReadablePartial) arg1, arg2);
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      verifyException("org.joda.time.format.DateTimeFormatterBuilder$Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFractionTaking3ArgumentsAndCallsPrintToTaking11And11() throws Throwable  {
      // No Comments were added
      DateTimeFieldType arg0 = DateTimeFieldType.yearOfEra();
      DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction = new DateTimeFormatterBuilder.Fraction(arg0, 2845, 84);
      Partial arg1 = new Partial(arg0, 2845, (Chronology) null);
      Locale arg2 = new Locale("org.joda.time.format.DateTimeFormatterBuilder$Fraction");
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder_Fraction.printTo((StringBuffer) null, (ReadablePartial) arg1, arg2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder$Fraction", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11And1AndCreatesFractionTaking3ArgumentsAndPrintToTaking11And1() throws Throwable  {
      // Given a DateTimeFieldType object that represents the second of minute, and a YearMonth object with the value -3780
      DateTimeFieldType arg0 = DateTimeFieldType.secondOfMinute();
      YearMonth arg1 = new YearMonth((long) (-3780));
      
      // When the fractional date time formatter is created with this field type and a locale of Locale.CHINA
      DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction = new DateTimeFormatterBuilder.Fraction(arg0, (-3780), 348);
      
      // And the parsed length is estimated
      int estimateParsedLength = dateTimeFormatterBuilder_Fraction.estimateParsedLength();
      
      // Then the estimated parsed length should be equal to 18
      assertEquals(18, estimateParsedLength);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFractionTaking3ArgumentsAndCallsPrintToTaking11111And10() throws Throwable  {
      // No Comments were added
      EthiopicChronology arg2 = EthiopicChronology.getInstance();
      DateTimeZone arg4 = arg2.getZone();
      Locale arg5 = Locale.ENGLISH;
      DateTimeFieldType arg0 = DateTimeFieldType.era();
      DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction = new DateTimeFormatterBuilder.Fraction(arg0, 1, 1);
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder_Fraction.printTo((StringBuffer) null, (long) 1, (Chronology) arg2, 3600000, arg4, arg5);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendDayOfWeekShortText() throws Throwable  {
      // Test that the DateTimeFormatterBuilder can build a parser for era text
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatterBuilder appendEraText = dateTimeFormatterBuilder.appendEraText();
      boolean canBuildParser = appendEraText.canBuildParser();
      assertTrue(canBuildParser);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTwoDigitYearTaking3ArgumentsAndCallsPrintToTaking11And1() throws Throwable  {
      LocalTime localTime = LocalTime.MIDNIGHT;
      DateTimeFieldType dateTimeFieldType = DateTimeFieldType.secondOfMinute();
      DateTimeFormatterBuilder.TwoDigitYear twoDigitYear = new DateTimeFormatterBuilder.TwoDigitYear(dateTimeFieldType, 44, true);
      Locale locale = Locale.ENGLISH;
      
      // Given a date and time field type with a maximum value of 44
      // When printTo is called with null as the writer argument
      // Then an exception should be thrown
      
      try {
      twoDigitYear.printTo((Writer) null, (ReadablePartial) localTime, locale);
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      // no message in exception (getMessage() returned null)
      verifyException("org.joda.time.format.FormatUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11111And1AndPrintToTaking11111And1AndCreatesTwoDigitYearTaking3Arguments0() throws Throwable  {
      // rollbacked to evosuite
      StringWriter arg0 = new StringWriter(0);
      DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear = new DateTimeFormatterBuilder.TwoDigitYear((DateTimeFieldType) null, (-3481), false);
      Locale arg5 = Locale.US;
      ISOChronology arg2 = ISOChronology.getInstanceUTC();
      DateTimeZone arg4 = DateTimeZone.forOffsetHours(0);
      dateTimeFormatterBuilder_TwoDigitYear.printTo((Writer) arg0, (long) (-3481), (Chronology) arg2, (-3481), arg4, arg5);
      assertEquals("\uFFFD\uFFFD", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11111And1AndPrintToTaking11111And1AndCreatesTwoDigitYearTaking3Arguments1() throws Throwable  {
      // Given a string buffer to store the formatted date-time value
      StringBuffer arg0 = new StringBuffer(1);
      
      // When formatting a long value using a two-digit year formatter with a specific chronology and locale
      EthiopicChronology instance = EthiopicChronology.getInstance();
      JulianChronology chronoUTC = JulianChronology.getInstanceUTC();
      DateTimeZone zone = instance.getZone();
      Locale locale = Locale.forLanguageTag("US/Samoa");
      DateTimeFormatterBuilder.TwoDigitYear twoDigitYearFormatter = new DateTimeFormatterBuilder.TwoDigitYear(DateTimeFieldType.year(), 1034, true);
      twoDigitYearFormatter.printTo(arg0, 3056L, chronoUTC, -837, zone, locale);
      
      // Then the formatted date-time value should be equal to "2" and "\uFFFD\uFFFD", respectively
      assertEquals(2, arg0.length());
      assertEquals("\uFFFD\uFFFD", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTwoDigitYearTaking3Arguments() throws Throwable  {
      // Given a date time formatter that uses two digit years
      DateTimeFieldType millisecond = DateTimeFieldType.millisOfSecond();
      DateTimeFormatterBuilder.TwoDigitYear twoDigitYear = new DateTimeFormatterBuilder.TwoDigitYear(millisecond, 156, true);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(twoDigitYear, twoDigitYear);
      
      // When the date time formatter is used to print a value
      String printedValue = dateTimeFormatter.print((long) 156);
      
      // Then the output should be "56" and the estimated length should be 2
      assertEquals("56", printedValue);
      assertEquals(2, twoDigitYear.estimatePrintedLength());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTwoDigitYearTaking3ArgumentsAndCallsParseInto0() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFieldType arg0 = DateTimeFieldType.hourOfHalfday();
      DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear = new DateTimeFormatterBuilder.TwoDigitYear(arg0, 18, false);
      assertEquals(2, dateTimeFormatterBuilder_TwoDigitYear.estimateParsedLength());
      
      int parseInto = dateTimeFormatterBuilder_TwoDigitYear.parseInto((DateTimeParserBucket) null, "rbW770J,FQpb{Fj:;Fe", 5);
      assertEquals((-6), parseInto);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTwoDigitYearTaking3ArgumentsAndCallsParseInto1() throws Throwable  {
      // Given a DateTimeFieldType for hourOfHalfday
      DateTimeFieldType arg0 = DateTimeFieldType.hourOfHalfday();
      
      // And a TwoDigitYear with 18 as the minimum value and false for the parseLenient flag
      DateTimeFormatterBuilder.TwoDigitYear dateTimeFormatterBuilder_TwoDigitYear = new DateTimeFormatterBuilder.TwoDigitYear(arg0, 18, false);
      
      // When parsing a string using the TwoDigitYear formatter
      int parseInto = dateTimeFormatterBuilder_TwoDigitYear.parseInto((DateTimeParserBucket) null, ">Z8eKY2 Q'", 18);
      
      // Then the estimated length of the parsed string should be 2 characters long
      assertEquals(2, dateTimeFormatterBuilder_TwoDigitYear.estimateParsedLength());
      
      // And the parseInto method should return -19 for a value that is not within the range of the minimum value and maximum value
      assertEquals((-19), parseInto);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFixedNumberTaking3ArgumentsAndCallsPrintToTaking11And1() throws Throwable  {
      LocalDateTime arg1 = new LocalDateTime((DateTimeZone) null);
      DateTimeFieldType arg0 = DateTimeFieldType.dayOfMonth();
      DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber = new DateTimeFormatterBuilder.FixedNumber(arg0, 305, true);
      Locale arg2 = Locale.US;
      try {
      dateTimeFormatterBuilder_FixedNumber.printTo((Writer) null, (ReadablePartial) arg1, arg2);
      } catch(NullPointerException e) {
      // The code should not have reached this point, as the method is expected to throw a NullPointerException if the writer is null.
      fail("Unexpected exception: " + e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesUnpaddedNumberTaking3ArgumentsAndCallsPrintToTaking11And1() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFieldType arg0 = DateTimeFieldType.millisOfSecond();
      DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber = new DateTimeFormatterBuilder.UnpaddedNumber(arg0, (-1731453292), true);
      LocalTime arg1 = LocalTime.fromMillisOfDay((long) (-1763));
      Locale arg2 = Locale.CHINESE;
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder_UnpaddedNumber.printTo((Writer) null, (ReadablePartial) arg1, arg2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test2() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        LocalDate.parse("-S-");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \"-S-\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test3() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        MonthDay.parse("+");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \"+\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test4() throws Throwable  {
      // Undeclared exception!
      try {
      LocalDate.parse("+3o%PN!?.<ReDb1$Sb]");
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      //
      // Invalid format: \"+3o%PN!?.<ReDb1$Sb]\" is malformed at \"o%PN!?.<ReDb1$Sb]\"
      //
      verifyException("org.joda.time.format.DateTimeFormatter", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test5() throws Throwable  {
      // Test that an exception is thrown when the format of the input string is invalid
      try {
      MonthDay.parse("--02");
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the exception message is as expected
      verifyException("org.joda.time.format.DateTimeFormatter", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test6() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        Instant.parse("tn%B");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Invalid format: \"tn%B\" is malformed at \"n%B\"
         //
         verifyException("org.joda.time.format.DateTimeFormatter", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test7() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        LocalDate.parse("-01-15");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Cannot parse \"-01-15\": Value 15 for monthOfYear must be in the range [1,12]
         //
         verifyException("org.joda.time.field.FieldUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test8() throws Throwable  {
      try {
      DateTime.parse("-4--b-ch&bg-y/ih_j");
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Verify that the thrown exception is of type IllegalArgumentException
      verifyException("org.joda.time.format.DateTimeFormatter", e);
      
      /*
      * Verify the content of the error message. The error message should indicate that the date string "-4--b-ch&bg-y/ih_j" is malformed
      * at the character "--b-ch&bg-y/ih_j".
      */
      assertEquals("Invalid format: \"-4--b-ch&bg-y/ih_j\" is malformed at \"--b-ch&bg-y/ih_j\"", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintUnknownString() throws Throwable  {
      // Given: A DateTimeFormatterBuilder object and a PrintWriter object to print unknown strings
      DateTimeFormatterBuilder formatter = new DateTimeFormatterBuilder();
      MockPrintWriter arg0 = new MockPrintWriter(" - ");
      
      // When: Calling the printUnknownString method with a negative value of 2091
      formatter.printUnknownString(arg0, (-2091));
      
      // Then: The PrintWriter object should have been called with the unknown string "-2091"
      assertEquals("-2091", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendUnknownString() throws Throwable  {
      // This test is intended to verify that the DateTimeFormatterBuilder's appendUnknownString method
      // correctly handles an unknown string value and returns 0 as the length of the resulting StringBuffer.
      
      // Arrange
      StringBuffer arg0 = new StringBuffer();
      int input = -2922;
      
      // Act
      DateTimeFormatterBuilder.appendUnknownString(arg0, input);
      
      // Assert
      assertEquals(0, arg0.length());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCanBuildFormatterReturningFalse() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the canBuildFormatter method is called on the builder
      boolean canBuildFormatter = dateTimeFormatterBuilder.canBuildFormatter();
      
      // Then the return value should be false, indicating that no formatter has been built yet
      assertFalse(canBuildFormatter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCanBuildPrinterReturningTrue() throws Throwable  {
      // Given a DateTimeFormatterBuilder with an appendTimeZoneName method
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatterBuilder appendTimeZoneName = dateTimeFormatterBuilder.appendTimeZoneName();
      
      // When the canBuildPrinter method is called on the formatter
      boolean canBuildPrinter = appendTimeZoneName.canBuildPrinter();
      
      // Then the method should return true
      assertTrue(canBuildPrinter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFractionWithNegative() throws Throwable  {
      // Given: A DateTimeFormatterBuilder and a DateTimeFieldType with an invalid range
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFieldType arg0 = DateTimeFieldType.weekOfWeekyear();
      
      try {
      // When: The appendFraction method is called with an invalid range
      dateTimeFormatterBuilder.appendFraction(arg0, -438071376, -438071376);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Then: The method should throw an IllegalArgumentException with no message
      assertEquals(null, e.getMessage());
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFractionWithNullAndPositive() throws Throwable  {
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // Given a null field type
      try {
      dateTimeFormatterBuilder.appendFraction((DateTimeFieldType) null, 21, 48);
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      // Then the method should throw an IllegalArgumentException with a meaningful message
      assertEquals("Field type must not be null", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendShortTextThrowsIllegalArgumentException() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder.appendShortText((DateTimeFieldType) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Field type must not be null
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTextThrowsIllegalArgumentException() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance, and a null field type parameter
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFieldType fieldType = null;
      
      // When appendText is called with the null field type parameter
      dateTimeFormatterBuilder.appendText(fieldType);
      
      // Then an IllegalArgumentException is thrown, indicating that the field type must not be null
      try {
      dateTimeFormatterBuilder.appendText((DateTimeFieldType) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFixedSignedDecimalWithNegative() throws Throwable  {
      // Given a DateTimeFieldType and a negative integer value,
      // when attempting to append the fixed signed decimal format to the builder,
      // then an IllegalArgumentException is thrown with the message "Illegal number of digits: -435"
      
      DateTimeFieldType arg0 = DateTimeFieldType.clockhourOfDay();
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      try {
      dateTimeFormatterBuilder.appendFixedSignedDecimal(arg0, (-435));
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // verify that the correct exception is thrown with the expected message
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFixedSignedDecimalWithNullAndZero() throws Throwable  {
      // Arrange
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // Act and Assert
      try {
      dateTimeFormatterBuilder.appendFixedSignedDecimal((DateTimeFieldType) null, 0);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFixedSignedDecimal() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // And a DateTimeFieldType representing the year of century
      DateTimeFieldType arg0 = DateTimeFieldType.yearOfCentury();
      
      // When appendFixedSignedDecimal is called with the year of century and 4 digits as arguments
      DateTimeFormatterBuilder appendFixedSignedDecimal = dateTimeFormatterBuilder.appendFixedSignedDecimal(arg0, 4);
      
      // Then the method should return the same instance
      assertSame(dateTimeFormatterBuilder, appendFixedSignedDecimal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSignedDecimalWithZero() throws Throwable  {
      // Given
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFieldType yearOfCentury = DateTimeFieldType.yearOfCentury();
      
      // When (try to append a signed decimal with an invalid argument)
      try {
      dateTimeFormatterBuilder.appendSignedDecimal(yearOfCentury, 0, (-552));
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Then (verify that the correct exception is thrown)
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendWeekyearThrowsIllegalArgumentException() throws Throwable  {
      // Given: A DateTimeFormatterBuilder instance with an undeclared exception thrown
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      try {
      // When: Appending a weekyear using an invalid range of values
      dateTimeFormatterBuilder.appendWeekyear((-565), (-565));
      
      // Then: An IllegalArgumentException is thrown with no message
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Verify the exception is correct and relevant to the test case
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendWeekyear() throws Throwable  {
      // Given a DateTimeFormatterBuilder and a year number (2023)
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      int year = 2023;
      
      // When we append the weekyear with the provided year
      DateTimeFormatterBuilder appendWeekyear = dateTimeFormatterBuilder.appendWeekyear(year, 12);
      
      // Then the returned formatter should be the same instance as the builder
      assertSame(dateTimeFormatterBuilder, appendWeekyear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSignedDecimalWithNull() throws Throwable  {
      // Given
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When
      try {
      dateTimeFormatterBuilder.appendSignedDecimal((DateTimeFieldType) null, 624, (-1589));
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Then
      assertTrue(e instanceof IllegalArgumentException);
      assertEquals("Field type must not be null", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFixedDecimalWithNegative() throws Throwable  {
      // Given
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFieldType arg0 = DateTimeFieldType.weekOfWeekyear();
      
      // When
      try {
      dateTimeFormatterBuilder.appendFixedDecimal(arg0, (-1672));
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Then
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFixedDecimalWithNull() throws Throwable  {
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // Given a DateTimeFormatterBuilder with a null field type
      // When the appendFixedDecimal method is called with a null field type
      // Then an IllegalArgumentException should be thrown
      
      try {
      dateTimeFormatterBuilder.appendFixedDecimal((DateTimeFieldType) null, 2);
      fail("Expected exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      // Field type must not be null
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFixedDecimal() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the "appendFixedDecimal" method is called on the DateTimeFormatterBuilder instance with a DateTimeFieldType argument
      DateTimeFieldType arg0 = DateTimeFieldType.weekOfWeekyear();
      DateTimeFormatterBuilder appendFixedDecimal = dateTimeFormatterBuilder.appendFixedDecimal(arg0, 12);
      
      // Then the "dateTimeFormatterBuilder" reference should be returned
      assertSame(dateTimeFormatterBuilder, appendFixedDecimal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendDecimalWithZeroAndAppendDecimalThrowsIllegalArgumentException() throws Throwable  {
      // Given
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFieldType arg0 = DateTimeFieldType.secondOfMinute();
      
      // When
      try {
      dateTimeFormatterBuilder.appendDecimal(arg0, 0, 0);
      } catch (IllegalArgumentException e) {
      // Then
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);
      throw e;}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendDecimalWithNegativeAndNegative() throws Throwable  {
      DateTimeFieldType arg0 = DateTimeFieldType.secondOfMinute();
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // Given a negative minimum integer digits value
      int minIntDigits = -1989;
      
      // When the appendDecimal method is called with this value
      try {
      dateTimeFormatterBuilder.appendDecimal(arg0, minIntDigits, 560);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // Then a IllegalArgumentException is thrown
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendDecimalWithNull() throws Throwable  {
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // Given
      Integer maxIntegerValue = Integer.MAX_VALUE;
      
      // When
      try {
      dateTimeFormatterBuilder.appendDecimal((DateTimeFieldType) null, maxIntegerValue, maxIntegerValue);
      fail("Expected exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Then
      assertTrue(e instanceof IllegalArgumentException);
      assertEquals("Field type must not be null", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendLiteralTakingString() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatterBuilder appendLiteral = dateTimeFormatterBuilder.appendLiteral("0");
      assertSame(dateTimeFormatterBuilder, appendLiteral);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendLiteralTakingStringWithEmptyString() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When a literal string is appended to the builder
      DateTimeFormatterBuilder appendLiteral = dateTimeFormatterBuilder.appendLiteral("");
      
      // Then the same DateTimeFormatterBuilder instance should be returned
      assertSame(appendLiteral, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendLiteralTakingStringThrowsIllegalArgumentException() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder.appendLiteral((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Literal must not be null
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendOptionalThrowsIllegalArgumentException() throws Throwable  {
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      // Undeclared exception!
      try {
      dateTimeFormatterBuilder.appendOptional((DateTimeParser) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      //
      // No parser supplied
      //
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTaking1And1ThrowsArrayIndexOutOfBoundsException() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeParser[] arg1 = new DateTimeParser[0];
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder.append((DateTimePrinter) null, arg1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 0
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTaking1And1ThrowsIllegalArgumentException() throws Throwable  {
      // Given
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      HashMap<String, DateTimeZone> arg1 = new HashMap<>();
      DateTimeFormatterBuilder.TimeZoneName arg0 = new DateTimeFormatterBuilder.TimeZoneName(3, arg1);
      
      // When
      try {
      dateTimeFormatterBuilder.append((DateTimePrinter) arg0, (DateTimeParser[]) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Then
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTakingDateTimeFormatterThrowsIllegalArgumentException() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When append method is called with null formatter argument
      try {
      dateTimeFormatterBuilder.append((DateTimeFormatter) null);
      } catch(IllegalArgumentException e) {
      // Then an IllegalArgumentException should be thrown
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToParserThrowsUnsupportedOperationException() throws Throwable  {
      // Given: A DateTimeFormatterBuilder instance with no specified pattern
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When: Trying to obtain a parser from the builder
      try {
      dateTimeFormatterBuilder.toParser();
      
      // Then: An UnsupportedOperationException should be thrown, indicating that parsing is not supported
      fail("Expecting exception: UnsupportedOperationException");
      } catch (UnsupportedOperationException e) {
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToPrinterThrowsUnsupportedOperationException() throws Throwable  {
      // Given: A DateTimeFormatterBuilder instance
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When: The toPrinter method is invoked
      try {
      dateTimeFormatterBuilder.toPrinter();
      
      // Then: An UnsupportedOperationException is thrown, as printing is not supported by the builder
      fail("Expecting exception: UnsupportedOperationException");
      } catch(UnsupportedOperationException e) {
      verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToFormatterReturningDateTimeFormatterWhereIsPrinterIsFalse() throws Throwable  {
      // Given a DateTimeFormatterBuilder with an optional character literal
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatterBuilder.CharacterLiteral arg0 = new DateTimeFormatterBuilder.CharacterLiteral('g');
      dateTimeFormatterBuilder.appendOptional(arg0);
      
      // When the formatter is built
      DateTimeFormatter formatter = dateTimeFormatterBuilder.toFormatter();
      
      // Then the formatter should not parse any offset information
      assertFalse(formatter.isOffsetParsed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToFormatterThrowsUnsupportedOperationException() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder.toFormatter();
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // Both printing and parsing not supported
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFractionTaking3ArgumentsAndCallsPrintToTaking11111And11() throws Throwable  {
      // Given a DateTimeFormatterBuilder$Fraction instance named dateTimeFormatterBuilder_Fraction
      DateTimeFieldType arg0 = DateTimeFieldType.hourOfDay();
      Locale arg5 = Locale.ROOT;
      ISOChronology arg2 = ISOChronology.getInstance((DateTimeZone) null);
      DateTimeFormatterBuilder.Fraction dateTimeFormatterBuilder_Fraction = new DateTimeFormatterBuilder.Fraction(arg0, (-219279065), 5);
      
      // When the printTo method is called with a null StringBuffer object as one of its parameters
      try {
      // The method call will throw an exception because a null StringBuffer object cannot be passed as a parameter
      dateTimeFormatterBuilder_Fraction.printTo((StringBuffer) null, (long) 5, (Chronology) arg2, 84, (DateTimeZone) null, arg5);
      
      // If the exception is not caught, this line of code will fail the test
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // The method printTo() is expected to throw a NullPointerException when passed a null StringBuffer object as one of its parameters
      verifyException("org.joda.time.format.DateTimeFormatterBuilder$Fraction", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test9() throws Throwable  {
      // Create a new instance of the MonthDay class with the default constructor
      MonthDay monthDay = new MonthDay();
      
      // Set the locale to Italian
      Locale arg1 = Locale.ITALIAN;
      
      // Call the toString method with the format "S" and the locale "it_IT"
      String string = monthDay.toString(":S", arg1);
      
      // Assert that the result is ":0"
      assertEquals(":0", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTextFieldTaking2ArgumentsAndCallsPrintToTaking11111And10() throws Throwable  {
      // Create a PipedWriter to write to
      PipedWriter pipedWriter = new PipedWriter();
      
      // Create a DateTimeFormatterBuilder.TextField to format the date and time
      DateTimeFormatterBuilder.TextField textField = new DateTimeFormatterBuilder.TextField((DateTimeFieldType) null, true);
      
      // Create an ISOChronology for the UTC time zone
      ISOChronology isoChronology = ISOChronology.getInstanceUTC();
      
      // Create a FixedDateTimeZone for the UTC time zone
      DateTimeZone fixedDateTimeZone = (FixedDateTimeZone) DateTimeZone.UTC;
      
      // Create a Locale for Canada French
      Locale locale = Locale.CANADA_FRENCH;
      
      try {
      // Print the date and time to the piped writer using the text field, chronology, and time zone
      textField.printTo((Writer) pipedWriter, 1549L, (Chronology) isoChronology, 3, (DateTimeZone) fixedDateTimeZone, locale);
      
      // Expect an IOException to be thrown because the pipe is not connected
      fail("Expecting exception: IOException");
      } catch(IOException e) {
      // Verify that the exception is an IOException
      verifyException("java.io.PipedWriter", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTextFieldTaking2ArgumentsAndCallsPrintToTaking11111And11() throws Throwable  {
      // Given a DateTimeFieldType for the century of era, and a DateTimeZone for the default time zone
      DateTimeFieldType arg0 = DateTimeFieldType.centuryOfEra();
      DateTimeZone arg4 = DateTimeZone.getDefault();
      
      // When we create a GJChronology instance with the specified DateTimeZone
      GJChronology arg2 = GJChronology.getInstance(arg4);
      
      // And we create a DateTimeFormatterBuilder.TextField for the century of era field, with formatting set to false
      DateTimeFormatterBuilder.TextField dateTimeFormatterBuilder_TextField = new DateTimeFormatterBuilder.TextField(arg0, false);
      
      // Then an exception is thrown when we attempt to print to a null StringBuffer object
      try {
      dateTimeFormatterBuilder_TextField.printTo((StringBuffer) null, (long) 1493, (Chronology) arg2, 8, arg4, (Locale) null);
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Verify that the exception is thrown as expected
      verifyException("org.joda.time.format.DateTimeFormatterBuilder$TextField", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesUnpaddedNumberTaking3ArgumentsAndCallsPrintToTaking11111And10() throws Throwable  {
      // rollbacked to evosuite
      JulianChronology arg2 = JulianChronology.getInstanceUTC();
      FixedDateTimeZone arg4 = (FixedDateTimeZone)DateTimeZone.UTC;
      DateTimeFieldType arg0 = DateTimeFieldType.dayOfYear();
      DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber = new DateTimeFormatterBuilder.UnpaddedNumber(arg0, 4767, true);
      Locale arg5 = Locale.ITALY;
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder_UnpaddedNumber.printTo((Writer) null, (-3658L), (Chronology) arg2, 4767, (DateTimeZone) arg4, arg5);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesUnpaddedNumberTaking3ArgumentsAndCallsPrintToTaking11111And11() throws Throwable  {
      // Arrange
      JulianChronology arg2 = JulianChronology.getInstanceUTC();
      FixedDateTimeZone arg4 = (FixedDateTimeZone) DateTimeZone.UTC;
      DateTimeFieldType arg0 = DateTimeFieldType.hourOfHalfday();
      DateTimeFormatterBuilder.UnpaddedNumber dateTimeFormatterBuilder_UnpaddedNumber = new DateTimeFormatterBuilder.UnpaddedNumber(arg0, -1986, true);
      
      // Act & Assert
      try {
      dateTimeFormatterBuilder_UnpaddedNumber.printTo((StringBuffer) null, -1986L, arg2, -1986, arg4, (Locale) null);
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Verify that the exception is due to a null StringBuffer
      verifyException("org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11111And1AndPrintToTaking11111And1AndCreatesStringLiteralTakingString0() throws Throwable  {
      // Create a StringBuffer with the input date and time
      StringBuffer input = new StringBuffer(",y");
      
      // Create a DateTimeFormatterBuilder.StringLiteral object with the format string ",y"
      DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral = new DateTimeFormatterBuilder.StringLiteral(",y");
      
      // Create a DateTimeZone object with the offset of 4 hours and 4 minutes
      DateTimeZone arg4 = DateTimeZone.forOffsetHoursMinutes(4, 4);
      
      // Print the date and time to the StringBuffer using the format string ",y" and the DateTimeZone object
      dateTimeFormatterBuilder_StringLiteral.printTo(input, 0L, (Chronology) null, 4, arg4, (Locale) null);
      
      // Assert that the output of the printTo method is equal to "+04:04"
      assertEquals("+04:04", arg4.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesStringLiteralTakingStringAndCallsPrintToTaking11And1() throws Throwable  {
      // Create a new CharArrayWriter with a capacity of 3021 characters
      CharArrayWriter arg0 = new CharArrayWriter(3021);
      // Create a new MonthDay object with no arguments (representing the current month and day)
      MonthDay arg1 = new MonthDay();
      // Set the Locale to French
      Locale arg2 = Locale.FRENCH;
      // Create a new DateTimeFormatterBuilder.StringLiteral with the value "-w"
      DateTimeFormatterBuilder.StringLiteral dateTimeFormatterBuilder_StringLiteral = new DateTimeFormatterBuilder.StringLiteral("-w");
      // Call the printTo method on the dateTimeFormatterBuilder_StringLiteral object, passing in arg0 (the CharArrayWriter), arg1 (the MonthDay), and arg2 (the Locale) as arguments
      dateTimeFormatterBuilder_StringLiteral.printTo((Writer) arg0, (ReadablePartial) arg1, arg2);
      // Assert that the first character in the resulting string is 1, which represents the day of the month
      assertEquals(1, MonthDay.DAY_OF_MONTH);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11111And1AndPrintToTaking11111And1AndCreatesStringLiteralTakingString1() throws Throwable  {
      // Given
      CharArrayWriter writer = new CharArrayWriter(3021);
      Locale locale = Locale.FRENCH;
      CopticChronology copticChronology = CopticChronology.getInstanceUTC();
      DateTimeParserBucket bucket = new DateTimeParserBucket(1293L, copticChronology, locale, (Integer) 0, 3021);
      DateTimeZone zone = bucket.getZone();
      
      // When
      DateTimeFormatterBuilder.StringLiteral stringLiteral = new DateTimeFormatterBuilder.StringLiteral("");
      stringLiteral.printTo((Writer) writer, 132L, copticChronology, 3021, zone, locale);
      
      // Then
      assertEquals("", locale.getVariant());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTwoDigitWeekyearTakingInt() throws Throwable  {
      // Arrange
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatterBuilder appendTwoDigitWeekyear = dateTimeFormatterBuilder.appendTwoDigitWeekyear(10209375);
      appendTwoDigitWeekyear.appendLiteral("2.-In");
      DateTimeFormatterBuilder.Composite parser = (DateTimeFormatterBuilder.Composite)appendTwoDigitWeekyear.toParser();
      
      // Act and Assert
      assertEquals(7, parser.estimatePrintedLength());
      assertEquals(7, parser.estimateParsedLength());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11111And1AndPrintToTaking11111And1AndCreatesCharacterLiteralTakingChar0() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral = new DateTimeFormatterBuilder.CharacterLiteral(')');
      StringWriter arg0 = new StringWriter(1);
      JulianChronology arg2 = JulianChronology.getInstance();
      DateTimeZone arg4 = DateTimeZone.forOffsetMillis((-1389));
      Locale arg5 = Locale.UK;
      dateTimeFormatterBuilder_CharacterLiteral.printTo((Writer) arg0, (long) 1, (Chronology) arg2, 6, arg4, arg5);
      assertEquals(")", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11And1AndPrintToTaking11And1AndCreatesCharacterLiteralTakingChar1() throws Throwable  {
      // Given a CharArrayWriter with a capacity of 3021
      CharArrayWriter writer = new CharArrayWriter(3021);
      
      // And a MonthDay instance
      MonthDay monthDay = new MonthDay();
      
      // And a Locale.FRENCH locale
      Locale locale = Locale.FRANCE;
      
      // When we call the printTo method with the writer, the MonthDay and the locale
      DateTimeFormatterBuilder.CharacterLiteral characterLiteral = new DateTimeFormatterBuilder.CharacterLiteral('\\');
      characterLiteral.printTo(writer, monthDay, locale);
      
      // Then the result of the printTo method should be a string with the value "\\"
      assertEquals("\\", writer.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11111And1AndPrintToTaking11111And1AndCreatesCharacterLiteralTakingChar1() throws Throwable  {
      // No Comments were added
      DateTimeFormatterBuilder.CharacterLiteral dateTimeFormatterBuilder_CharacterLiteral = new DateTimeFormatterBuilder.CharacterLiteral(')');
      EthiopicChronology arg2 = EthiopicChronology.getInstance();
      DateTimeZone arg4 = arg2.getZone();
      StringBuffer arg0 = new StringBuffer(3663);
      dateTimeFormatterBuilder_CharacterLiteral.printTo(arg0, (long) (-1242), (Chronology) arg2, (-2423), arg4, (Locale) null);
      assertEquals(")", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneNameTaking2Arguments1() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder.TimeZoneName arg1 = new DateTimeFormatterBuilder.TimeZoneName(1, (Map<String, DateTimeZone>) null);
      DateTimeFormatter dateTimeFormatter = new DateTimeFormatter(arg1, arg1);
      String print = dateTimeFormatter.print(10000L);
      assertEquals(4, arg1.estimatePrintedLength());
      assertEquals("+00:00", print);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTimeZoneId() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the appendTimeZoneId method is called on the builder
      DateTimeFormatterBuilder appendTimeZoneId = dateTimeFormatterBuilder.appendTimeZoneId();
      
      // Then the same builder instance should be returned
      assertSame(dateTimeFormatterBuilder, appendTimeZoneId);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendClockhourOfDay() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the appendClockhourOfDay method is called with an argument of 12
      DateTimeFormatterBuilder appendClockhourOfDay = dateTimeFormatterBuilder.appendClockhourOfDay(12);
      
      // Then the return value should be the same as the original DateTimeFormatterBuilder object
      assertSame(appendClockhourOfDay, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTakingDateTimePrinterThrowsIllegalArgumentException() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder.append((DateTimePrinter) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No printer supplied
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSecondOfMinute() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance with appended second of minute
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      dateTimeFormatterBuilder.appendSecondOfMinute(59);
      
      // When we call appendSecondOfMinute on the same builder instance
      DateTimeFormatterBuilder appendSecondOfMinute = dateTimeFormatterBuilder.appendSecondOfMinute(59);
      
      // Then the same builder instance is returned with the new appended value
      assertSame(dateTimeFormatterBuilder, appendSecondOfMinute);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTwoDigitWeekyearTaking2Arguments() throws Throwable  {
      // Given: a DateTimeFormatterBuilder object "dateTimeFormatterBuilder" and a method to append two digit week year data (2022) with padding true
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatterBuilder appendTwoDigitWeekyear = dateTimeFormatterBuilder.appendTwoDigitWeekyear(2022, true);
      
      // When: the "dateTimeFormatterBuilder" object is used to build a formatter for two digit week year with padding
      DateTimeFormatter dateTimeFormatter = dateTimeFormatterBuilder.toFormatter();
      
      // Then: the returned formatter should be the same as the original builder
      assertSame(dateTimeFormatterBuilder, appendTwoDigitWeekyear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTimeZoneOffsetTaking4Arguments() throws Throwable  {
      // Test that the appendTimeZoneOffset method returns a reference to the same DateTimeFormatterBuilder instance.
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatterBuilder appendTimeZoneOffset = dateTimeFormatterBuilder.appendTimeZoneOffset("+01:00", true, 43, 833);
      assertSame(dateTimeFormatterBuilder, appendTimeZoneOffset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendMinuteOfDay() throws Throwable  {
      // Given a DateTimeFormatterBuilder and a value for the minute of day
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      int minuteOfDay = 45;
      
      // When we call appendMinuteOfDay with the value
      DateTimeFormatterBuilder result = dateTimeFormatterBuilder.appendMinuteOfDay(minuteOfDay);
      
      // Then the result should be the same as the original DateTimeFormatterBuilder
      assertSame(result, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendMinuteOfHourAndAppendTimeZoneNameTakingMap() throws Throwable  {
      // Create a new DateTimeFormatterBuilder and add a time zone name formatter
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      HashMap<String, DateTimeZone> arg0 = new HashMap<String, DateTimeZone>();
      DateTimeFormatterBuilder appendTimeZoneName = dateTimeFormatterBuilder.appendTimeZoneName((Map<String, DateTimeZone>) arg0);
      
      // Add a minute of hour formatter to the existing time zone name formatter
      DateTimeFormatterBuilder appendMinuteOfHour = appendTimeZoneName.appendMinuteOfHour(292272992);
      
      // Create a composite parser using the existing formatters
      DateTimeFormatterBuilder.Composite parser = (DateTimeFormatterBuilder.Composite)appendMinuteOfHour.toParser();
      
      // Test that the estimated length of the printed string is equal to 292273012
      assertEquals(292273012, parser.estimatePrintedLength());
      
      // Test that the estimated length of the parsed string is equal to 292273012
      assertEquals(292273012, parser.estimateParsedLength());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendMillisOfDay() throws Throwable  {
      // Given: A DateTimeFormatterBuilder instance named "dateTimeFormatterBuilder"
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When: The method appendMillisOfDay() is called on the builder with an argument of 292272992
      DateTimeFormatterBuilder appendMillisOfDay = dateTimeFormatterBuilder.appendMillisOfDay(292272992);
      
      // Then: The return value should be the same as the "dateTimeFormatterBuilder" instance
      assertSame(appendMillisOfDay, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendMonthOfYearShortText() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When appending the short text representation of the month of year
      DateTimeFormatterBuilder appendMonthOfYearShortText = dateTimeFormatterBuilder.appendMonthOfYearShortText();
      
      // Then assert that the same DateTimeFormatterBuilder object is returned
      assertSame(dateTimeFormatterBuilder, appendMonthOfYearShortText);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCanBuildPrinterReturningFalse() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the canBuildPrinter method is called on the builder
      boolean canBuildPrinter = dateTimeFormatterBuilder.canBuildPrinter();
      
      // Then the result should be false
      assertFalse(canBuildPrinter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendMillisOfSecond() throws Throwable  {
      // Create a new instance of the DateTimeFormatterBuilder class
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // Append milliseconds to the formatter using the appendMillisOfSecond method
      DateTimeFormatterBuilder appendMillisOfSecond = dateTimeFormatterBuilder.appendMillisOfSecond(43);
      
      // Assert that the returned instance is the same as the original builder
      assertSame(dateTimeFormatterBuilder, appendMillisOfSecond);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCanBuildParser() throws Throwable  {
      // Given: a DateTimeFormatterBuilder instance without a pattern
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When: the method "canBuildParser" is called
      boolean canBuildParser = dateTimeFormatterBuilder.canBuildParser();
      
      // Then: false should be returned
      assertFalse(canBuildParser);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendSecondOfDay() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance with a previously created formatter
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When a call is made to append the second of day component with value 1559
      DateTimeFormatterBuilder appendSecondOfDay = dateTimeFormatterBuilder.appendSecondOfDay(1559);
      
      // Then the same instance should be returned, indicating that the method call was successful
      assertSame(appendSecondOfDay, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFractionOfMinute() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When we append the fraction of minute with 18 digits
      DateTimeFormatterBuilder appendTimeZoneName = dateTimeFormatterBuilder.appendTimeZoneName();
      appendTimeZoneName.appendFractionOfMinute(18, 18);
      
      // Then we expect the builder to be able to build a parser
      assertTrue(dateTimeFormatterBuilder.canBuildParser());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendClockhourOfHalfday() throws Throwable  {
      // Given: A DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When: Appending the clock hour of half day format
      DateTimeFormatterBuilder appendClockhourOfHalfday = dateTimeFormatterBuilder.appendClockhourOfHalfday(12);
      
      // Then: The resulting DateTimeFormatterBuilder object should be the same as the original one
      assertSame(dateTimeFormatterBuilder, appendClockhourOfHalfday);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClear() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      dateTimeFormatterBuilder.clear();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendPattern() throws Throwable  {
      // Given a DateTimeFormatterBuilder and a pattern for appending to it
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      String pattern = "dd-MM-yyyy";
      
      // When we append the pattern to the builder
      DateTimeFormatterBuilder appendPattern = dateTimeFormatterBuilder.appendPattern(pattern);
      
      // Then the result should be the same instance as the original builder
      assertSame(dateTimeFormatterBuilder, appendPattern);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFractionOfSecond() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the appendFractionOfSecond method is called with 3 and 2 parameters respectively
      DateTimeFormatterBuilder appendFractionOfSecond = dateTimeFormatterBuilder.appendFractionOfSecond(3, 2);
      
      // Then the same DateTimeFormatterBuilder object is returned
      assertSame(dateTimeFormatterBuilder, appendFractionOfSecond);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendDayOfWeekText() throws Throwable  {
      // rollbacked to evosuite
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatterBuilder appendDayOfWeekText = dateTimeFormatterBuilder.appendDayOfWeekText();
      assertSame(appendDayOfWeekText, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendWeekOfWeekyear() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When appending the week of weekyear to the formatter
      DateTimeFormatterBuilder appendWeekOfWeekyear = dateTimeFormatterBuilder.appendWeekOfWeekyear(4);
      
      // Then the formatter should be returned
      assertSame(dateTimeFormatterBuilder, appendWeekOfWeekyear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendFractionOfDay() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the appendFractionOfDay method is called with parameters (46, 15)
      DateTimeFormatterBuilder appendFractionOfDay = dateTimeFormatterBuilder.appendFractionOfDay(46, 15);
      
      // Then the return value should be a reference to the same DateTimeFormatterBuilder object
      assertSame(dateTimeFormatterBuilder, appendFractionOfDay);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendMonthOfYearText() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance with no appended text
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When appendMonthOfYearText is called on the builder
      DateTimeFormatterBuilder appendMonthOfYearText = dateTimeFormatterBuilder.appendMonthOfYearText();
      
      // Then the builder should return itself and the appended text should be a month of year text
      assertSame(appendMonthOfYearText, dateTimeFormatterBuilder);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendHourOfHalfday() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the appendHourOfHalfday method is called on the builder object
      DateTimeFormatterBuilder appendHourOfHalfday = dateTimeFormatterBuilder.appendHourOfHalfday(12);
      
      // Then the same builder object is returned
      assertSame(dateTimeFormatterBuilder, appendHourOfHalfday);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendHourOfDay() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance named 'dateTimeFormatterBuilder'
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the method 'appendHourOfDay(23)' is called on the builder instance
      DateTimeFormatterBuilder appendHourOfDay = dateTimeFormatterBuilder.appendHourOfDay(23);
      
      // Then the result should be the same as the original builder instance
      assertSame(dateTimeFormatterBuilder, appendHourOfDay);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendCenturyOfEra() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance with some existing configuration
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When we append the century of era to the formatter builder
      DateTimeFormatterBuilder appendCenturyOfEra = dateTimeFormatterBuilder.appendCenturyOfEra(1, 1);
      
      // Then the resulting formatter should be the same as the original formatter builder
      assertSame(dateTimeFormatterBuilder, appendCenturyOfEra);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendDayOfWeek() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance with a day of the week appended
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      dateTimeFormatterBuilder.appendDayOfWeek(0);
      
      // When a time zone name is appended to the formatter
      DateTimeFormatterBuilder appendTimeZoneName = dateTimeFormatterBuilder.appendTimeZoneName();
      
      // Then the formatter should be able to build a parser for the time zone name
      boolean canBuildParser = appendTimeZoneName.canBuildParser();
      assertFalse(canBuildParser);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendYearOfEra() throws Throwable  {
      // Given a DateTimeFormatterBuilder object
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the appendYearOfEra method is called with the range of 1900 to 2022
      DateTimeFormatterBuilder appendYearOfEra = dateTimeFormatterBuilder.appendYearOfEra(1900, 2022);
      
      // Then the same DateTimeFormatterBuilder object should be returned
      assertSame(dateTimeFormatterBuilder, appendYearOfEra);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTwoDigitYearTakingInt() throws Throwable  {
      // Given the need to test a DateTimeFormatterBuilder with a two-digit year
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // When the builder is asked to append a two-digit year
      DateTimeFormatterBuilder appendTwoDigitYear = dateTimeFormatterBuilder.appendTwoDigitYear(1998);
      
      // Then the resulting formatter should be the same as the original builder
      assertSame(dateTimeFormatterBuilder, appendTwoDigitYear);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrintToTaking11And1AndPrintToTaking11And1() throws Throwable  {
      // No Comments were added
      MonthDay arg1 = new MonthDay();
      DateTimeFormatterBuilder.TimeZoneId dateTimeFormatterBuilder_TimeZoneId = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      MockFileWriter arg0 = new MockFileWriter("--", true);
      Locale arg2 = Locale.CANADA_FRENCH;
      dateTimeFormatterBuilder_TimeZoneId.printTo((Writer) arg0, (ReadablePartial) arg1, arg2);
      assertEquals(32, dateTimeFormatterBuilder_TimeZoneId.estimatePrintedLength());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendTakingDateTimeParser() throws Throwable  {
      // Create a new DateTimeFormatterBuilder instance
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      
      // Append the era text to the formatter builder
      DateTimeFormatterBuilder appendEraText = dateTimeFormatterBuilder.appendEraText();
      
      // Set the time zone ID for the formatter builder
      DateTimeFormatterBuilder.TimeZoneId arg0 = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      
      // Append the time zone ID to the formatter builder
      dateTimeFormatterBuilder.append((DateTimeParser) arg0);
      
      // Estimate the parsed length of the era text
      assertEquals(32, arg0.estimateParsedLength());
      
      // Check if the formatter builder can build a DateTimeFormatter instance
      boolean canBuildFormatter = appendEraText.canBuildFormatter();
      
      // Assert that the formatter builder can build a DateTimeFormatter instance
      assertTrue(canBuildFormatter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEstimatePrintedLengthAndEstimatePrintedLength() throws Throwable  {
      // Arrange
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatterBuilder.TimeZoneId timeZoneId = DateTimeFormatterBuilder.TimeZoneId.INSTANCE;
      
      // Act
      int estimatePrintedLength = timeZoneId.estimatePrintedLength();
      
      // Assert
      assertEquals(32, estimatePrintedLength);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAppendOptional() throws Throwable  {
      // Given a DateTimeFormatterBuilder instance with a TimeZoneOffset argument
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      DateTimeFormatterBuilder.TimeZoneOffset arg0 = new DateTimeFormatterBuilder.TimeZoneOffset("US/Hawaii", "US/Hawaii", true, 3600000, 3600000);
      
      // When the appendOptional method is called with the TimeZoneOffset argument
      dateTimeFormatterBuilder.appendOptional(arg0);
      
      // Then the estimatePrintedLength and estimateParsedLength methods should return the expected values
      assertEquals(13, arg0.estimatePrintedLength());
      assertEquals(13, arg0.estimateParsedLength());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTimeZoneOffsetTaking5ArgumentsAndCallsPrintToTaking11And1() throws Throwable  {
      // Set up test data
      MonthDay arg1 = new MonthDay();
      Locale arg2 = Locale.FRENCH;
      StringBuffer arg0 = new StringBuffer("");
      
      // Create a DateTimeFormatterBuilder.TimeZoneOffset object with a specific time zone offset
      DateTimeFormatterBuilder.TimeZoneOffset dateTimeFormatterBuilder_TimeZoneOffset = new DateTimeFormatterBuilder.TimeZoneOffset("", "_@", false, 595, 1958);
      
      // Print the MonthDay and Locale using the TimeZoneOffset formatter
      dateTimeFormatterBuilder_TimeZoneOffset.printTo(arg0, (ReadablePartial) arg1, arg2);
      
      // Assert that the printed length is 10 characters
      assertEquals(10, dateTimeFormatterBuilder_TimeZoneOffset.estimatePrintedLength());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test10() throws Throwable  {
      // Create a new instance of the MonthDay class with the current date and time
      MonthDay now = MonthDay.now();
      
      // Convert the MonthDay object to a string using its toString() method
      String string = now.toString();
      
      // Assert that the resulting string is equal to the expected value
      assertEquals("--02-14", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFixedNumberTaking3ArgumentsAndCallsPrintToTaking11111And1() throws Throwable  {
      // No Comments were added
      EthiopicChronology arg2 = EthiopicChronology.getInstance();
      DateTimeZone arg4 = arg2.getZone();
      Locale arg5 = Locale.CHINA;
      DateTimeFieldType arg0 = DateTimeFieldType.era();
      DateTimeFormatterBuilder.FixedNumber dateTimeFormatterBuilder_FixedNumber = new DateTimeFormatterBuilder.FixedNumber(arg0, 2055, true);
      // Undeclared exception!
      try { 
        dateTimeFormatterBuilder_FixedNumber.printTo((Writer) null, (long) 2055, (Chronology) arg2, 61, arg4, arg5);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.joda.time.format.DateTimeFormatterBuilder", e);
      }
  }
}
