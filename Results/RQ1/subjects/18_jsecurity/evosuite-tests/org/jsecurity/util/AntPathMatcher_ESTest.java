/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Mar 18 01:41:41 GMT 2024
 */

package org.jsecurity.util;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.jsecurity.util.AntPathMatcher;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class AntPathMatcher_ESTest extends AntPathMatcher_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDoMatchReturningTrue() throws Throwable  {
      // No Comments were added
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      boolean doMatch = antPathMatcher.doMatch("%hnH:](8F0JU+7V6\"h9", "%hnH:](8F0JU+7V6\"h9", false);
      assertTrue(doMatch);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractPathWithinPatternAndSetPathSeparator0() throws Throwable  {
      // Test for the AntPathMatcher's extractPathWithinPattern method
      // Create a new AntPathMatcher instance
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // Set the path separator to "6l)qy," (this is just an example, it could be any string)
      antPathMatcher.setPathSeparator("6l)qy,");
      
      // Extract the path within pattern for the given pattern and path
      String extractPathWithinPattern = antPathMatcher.extractPathWithinPattern("/", "qhf.t|S<}IlYKwiyO");
      
      // Assert that the extracted path is equal to "6l)qy,YKwi6l)qy,O"
      assertEquals("6l)qy,YKwi6l)qy,O", extractPathWithinPattern);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractPathWithinPatternWithEmptyString() throws Throwable  {
      // Given: We have an AntPathMatcher instance and a pattern with a wildcard at the end
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      String pattern = ">pYbfWt12TjKxB";
      
      // When: We extract the path within the pattern
      String extractedPath = antPathMatcher.extractPathWithinPattern("", pattern);
      
      // Then: The extracted path should be the same as the original pattern
      assertEquals(pattern, extractedPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractPathWithinPattern0() throws Throwable  {
      // No Comments were added
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      String extractPathWithinPattern = antPathMatcher.extractPathWithinPattern("/^Xs0/sd@V{*K", "/^Xs0/sd@V{*K");
      assertEquals("sd@V{*K", extractPathWithinPattern);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractPathWithinPatternReturningEmptyString() throws Throwable  {
      // Arrange
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // Act
      String extractPathWithinPattern = antPathMatcher.extractPathWithinPattern("DXm)7*.*", "");
      
      // Assert
      assertEquals("", extractPathWithinPattern);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractPathWithinPattern1() throws Throwable  {
      // Create an AntPathMatcher instance
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // Extract the path within a pattern
      String extractedPath = antPathMatcher.extractPathWithinPattern("I?yXWkrJm!JU~oO=", "XOffYfU!k^AMnP+A1j");
      
      // Assert that the extracted path is correct
      assertEquals("/XOffYfU!k^AMnP+A1j", extractedPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractPathWithinPatternAndSetPathSeparator1() throws Throwable  {
      // No Comments were added
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      antPathMatcher.setPathSeparator("F,9##UFlo>QWUVc");
      String extractPathWithinPattern = antPathMatcher.extractPathWithinPattern("/*bV@G<*F$vY", "%hnH:](8F0JU+7V6\"h9");
      assertEquals("F,9##UFlo>QWUVc%hnH:](8F,9##UFlo>QWUVc0JF,9##UFlo>QWUVc6\"h", extractPathWithinPattern);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testExtractPathWithinPattern2() throws Throwable  {
      // No Comments were added
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      String extractPathWithinPattern = antPathMatcher.extractPathWithinPattern("/*bV@G<*F$vY", "%hnH:](8F0JU+7V6\"h9");
      assertEquals("%hnH:](8F0JU+7V6\"h9", extractPathWithinPattern);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatch0() throws Throwable  {
      // Given a AntPathMatcher instance
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // When we match two strings with wildcard characters
      boolean match = antPathMatcher.match("*5?h*QN", "*5?h*QN");
      
      // Then the method should return true, indicating that the strings match
      assertTrue(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchStartAndMatchStartReturningFalse0() throws Throwable  {
      // Given
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // When
      boolean matchStart = antPathMatcher.matchStart("kC*L*", "kC*/B");
      
      // Then
      assertFalse(matchStart);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchStartAndMatchStartReturningFalse1() throws Throwable  {
      // Given a path pattern with an invalid character
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      String pattern = "*bt%G<*o$vY";
      
      // When matchStart is called with the pattern and a prefix that does not start with a valid character
      boolean matchStart = antPathMatcher.matchStart(pattern, "*");
      
      // Then the method should return false, indicating that the pattern is invalid
      assertFalse(matchStart);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatch1() throws Throwable  {
      // Given the AntPathMatcher class and its match method
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      boolean match;
      
      // When we call the match method with two similar strings
      match = antPathMatcher.match("Cu*)A?9y7O4JU", "Cu*)A?9y7O4JU");
      
      // Then the match method should return true, indicating that both strings are equal and match each other
      assertTrue(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAndMatchesReturningTrue0() throws Throwable  {
      // Given a string pattern "WWd5**" and a string to match "WWd5"
      String pattern = "WWd5**";
      String strToMatch = "WWd5";
      
      // When we use the AntPathMatcher to match the pattern with the string
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      boolean matches = antPathMatcher.matches(pattern, strToMatch);
      
      // Then we expect that the result of matching should be true
      assertTrue(matches);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAndMatchesReturningFalse0() throws Throwable  {
      AntPathMatcher pathMatcher = new AntPathMatcher();
      boolean patternMatchesActual = pathMatcher.matches("kC*[", "kitchen");
      assertFalse(patternMatchesActual);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAndMatchesReturningFalse1() throws Throwable  {
      // Given a path pattern "kC*" and a path "k"
      String pattern = "kC*";
      String path = "k";
      
      // When the method matches is called with these arguments
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      boolean matches = antPathMatcher.matches(pattern, path);
      
      // Then it should return false because the pattern does not match the given path
      assertFalse(matches);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatch2() throws Throwable  {
      // No Comments were added
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      boolean match = antPathMatcher.match("Cu*/A?9y7O4JU", "Cu*/A?9y7O4JU");
      assertTrue(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchReturningFalse() throws Throwable  {
      // Given a path with special characters and a matching path with the same special characters
      String path1 = "/?4 UBKxM$%wtdc";
      String path2 = "/?4 UBKxM$%wtdc";
      
      // When we match the two paths using an AntPathMatcher
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      boolean match = antPathMatcher.match(path1, path2);
      
      // Then the match should be false because the paths are not equivalent
      assertFalse(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchStartAndMatchStartReturningTrue0() throws Throwable  {
      // Given a AntPathMatcher instance and two strings representing paths
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      String pattern = "/users/**";
      String path = "/users/john/file1.txt";
      
      // When the matchStart method is called with the pattern and path as arguments
      boolean matchStart = antPathMatcher.matchStart(pattern, path);
      
      // Then the method should return true
      assertTrue(matchStart);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAndMatchesReturningFalse2() throws Throwable  {
      // No Comments were added
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      boolean matches = antPathMatcher.matches("Y#k[|?%o=gGyH*", "Y#k[|?%o=gGyH*!@#$%^&*()_+-={}[]|\";:/?.>,<");
      assertFalse(matches);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAndMatchesReturningFalse3() throws Throwable  {
      // Test that an invalid path with a trailing slash returns false
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      boolean matches = antPathMatcher.matches("/*", "/ ");
      assertFalse(matches);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatch3() throws Throwable  {
      // Given an AntPathMatcher instance with a double star pattern ("//**")
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // When the match method is called with a slash pattern ("/")
      boolean match = antPathMatcher.match("//**", "/");
      
      // Then we expect the match to be true (i.e., the double star pattern matches any path)
      assertTrue(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDoMatchReturningFalse() throws Throwable  {
      // Given
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // When
      boolean doMatch = antPathMatcher.doMatch("/?V1U/`-", "/", true);
      
      // Then
      assertFalse(doMatch);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAndMatchesReturningFalse4() throws Throwable  {
      // Given: A path pattern with a wildcard (*) and a literal
      String pattern = "kC*";
      String path = "kC*/";
      
      // When: The pattern is matched against the path using AntPathMatcher
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      boolean matches = antPathMatcher.matches(pattern, path);
      
      // Then: The match should be false because the wildcard does not match the literal
      assertFalse(matches);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchStartAndMatchStartReturningTrue1() throws Throwable  {
      // Given a string "/" and an AntPathMatcher instance
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // When the matchStart method is called with the same string as parameter
      boolean matchStart = antPathMatcher.matchStart("/", "/");
      
      // Then the method should return true since both strings are the same
      assertTrue(matchStart);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAndMatchesReturningTrue1() throws Throwable  {
      // Create an AntPathMatcher instance to test the pattern matching functionality.
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // Test that the pattern "/**" matches any path, including the one provided.
      boolean matches = antPathMatcher.matches("/**", "/path/to/file");
      
      // Assert that the match is successful.
      assertTrue(matches);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatch4() throws Throwable  {
      // Given a wildcard pattern "/*" and a path "/"
      String wildcardPattern = "/*";
      String path = "/";
      
      // When we call match with the wildcard pattern and path
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      boolean match = antPathMatcher.match(wildcardPattern, path);
      
      // Then it should return true since the path matches the wildcard pattern
      assertTrue(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAndMatchesReturningTrue2() throws Throwable  {
      // Given
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // When
      boolean matches = antPathMatcher.matches("*/bt**G**o$vY", "*/bt**G**o$vY");
      
      // Then
      assertTrue(matches);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsPatternReturningFalse() throws Throwable  {
      // Create a new instance of the AntPathMatcher class
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // Test that the "/" path is not considered a pattern
      boolean pattern = antPathMatcher.isPattern("/");
      assertFalse(pattern);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsPattern0() throws Throwable  {
      // Arrange
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // Act
      boolean pattern = antPathMatcher.isPattern("!/BU|gN5?[F}3Dp\")");
      
      // Assert
      assertTrue(pattern);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsPattern1() throws Throwable  {
      // Given: A valid file name with an extension of ".txt"
      String fileName = "example.txt";
      
      // When: The AntPathMatcher is used to check if the file name matches the pattern "**/*.txt"
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      boolean pattern = antPathMatcher.isPattern("**/*.txt");
      
      // Then: The file name should match the pattern and return true
      assertTrue(pattern);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchStartWithEmptyStringAndSetPathSeparatorWithEmptyString() throws Throwable  {
      // Create a new AntPathMatcher instance with an empty path separator
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      antPathMatcher.setPathSeparator("");
      
      // Test that the match starts with the specified pattern and input string
      boolean matchStart = antPathMatcher.matchStart("nX1W)tCxEwL)A-P-(7.", "");
      assertTrue(matchStart);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetPathSeparatorWithNull() throws Throwable  {
      // rollbacked to evosuite
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      antPathMatcher.setPathSeparator((String) null);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchStartAndMatchStartReturningFalse2() throws Throwable  {
      // Given
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // When
      boolean matchStart = antPathMatcher.matchStart("/api/v1/users/**", "/api/v2/users/*");
      
      // Then
      assertFalse(matchStart);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAndMatchesReturningFalse5() throws Throwable  {
      // Arrange
      AntPathMatcher antPathMatcher = new AntPathMatcher();
      
      // Act
      boolean matches = antPathMatcher.matches("**/foo/**/*", "/foo/bar/baz");
      
      // Assert
      assertFalse(matches);
  }
}
