/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 13:52:21 GMT 2024
 */

package com.google.javascript.jscomp;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.AbstractCompiler;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.ControlFlowAnalysis;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.rhino.Node;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class ControlFlowAnalysis_ESTest extends ControlFlowAnalysis_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsContinueStructureReturningFalse() throws Throwable  {
      // Test that a node with no continuation structure is not considered a continue structure
      Node arg0 = new Node(103);
      boolean isContinueStructure = ControlFlowAnalysis.isContinueStructure(arg0);
      assertFalse(isContinueStructure);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFollowNodeTaking2Arguments() throws Throwable  {
      // Testing the computeFollowNode method with a Node that has a label of 86
      Node arg0 = new Node(86, 86, 86);
      // Creating a new Node object with a label of 114 and assigning it to a variable
      Node node = new Node(114, arg0, arg0, arg0, 43, 38);
      // Calling the computeFollowNode method on the Node with a null ControlFlowAnalysis object
      Node computeFollowNode = ControlFlowAnalysis.computeFollowNode(arg0, (ControlFlowAnalysis) null);
      // Asserting that the returned Node is not null
      assertNotNull(computeFollowNode);
      // Asserting that the returned Node does not have an assign attribute set to true
      assertFalse(computeFollowNode.isAssign());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFollowNodeTakingNodeReturningNodeWhereIsWhileIsTrue() throws Throwable  {
      Compiler compiler = new Compiler();
      // Parse the test code to create a node representing the argument for the method being tested
      Node arg0 = compiler.parseTestCode("=SC_CONSTANT_PROPERTY_REHSSIGNED_VALUE");
      
      // Create a new node with an ID of 113 and an argument equal to the parsed test code
      Node node = new Node(113, arg0, arg0);
      
      // Compute the follow node for the given node using ControlFlowAnalysis.computeFollowNode()
      Node computeFollowNode = ControlFlowAnalysis.computeFollowNode(arg0);
      
      // Assert that the follow node is not null
      assertNotNull(computeFollowNode);
      
      // Assert that the follow node has one child
      assertTrue(computeFollowNode.hasOneChild());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFollowNodeTakingNode() throws Throwable  {
      // Given a Node with a non-null value, a Compiler object, and some test code that returns a Node object
      Node arg0 = new Node(116);
      Compiler compiler = new Compiler();
      Node arg2 = compiler.parseTestCode("Nt reachXl");
      
      // When the computeFollowNode method is called with this Node as an argument
      Node node = new Node(114, arg2, arg2, arg0, 43, 38);
      Node computeFollowNode = ControlFlowAnalysis.computeFollowNode(arg0);
      
      // Then the method should return a non-null value that is not a break Node
      assertNotNull(computeFollowNode);
      assertFalse(computeFollowNode.isBreak());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFollowNodeTakingNodeReturningNodeWhereIsCaseIsTrue() throws Throwable  {
      // Given a node with a string value and a follow set
      Node arg3 = Node.newString(": k", 2, 16);
      Node arg2 = new Node(111, arg3, arg3, arg3, 49, 51);
      Node arg0 = Node.newString(": k", 2, 16);
      Node node = new Node((-582), arg0, arg2);
      
      // When computeFollowNode is called with the node as an argument
      Node computedFollowNode = ControlFlowAnalysis.computeFollowNode(arg0);
      
      // Then the follow set of the node should be returned
      assertEquals(computedFollowNode, arg2);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsWhileIsTrue() throws Throwable  {
      // Create a compiler object to parse test code
      Compiler compiler = new Compiler();
      
      // Parse some test code to get a Node object
      Node arg2 = compiler.parseTestCode("yt{X#8!EN#pBj");
      
      // Create a new Node with the same type as arg2 and initialize its fields
      Node arg0 = new Node(113, arg2, arg2);
      
      // Compute the fall-through for the given node and store it in a variable
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Assert that the source name of the computed fall-through is equal to the expected value
      assertEquals("some_source_name", Node.SOURCENAME_PROP);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsVarIsTrue() throws Throwable  {
      // rollbacked to evosuite
      Node arg1 = Node.newString("?T\"8Bv{CN", 103, 115);
      Node arg0 = new Node(118, arg1);
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      assertFalse(computeFallThrough.isReturn());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsTrueIsTrue() throws Throwable  {
      // Given: A Node with a value of 44 and three children, each with a value of 125
      Node arg3 = new Node(125, 125, 125);
      Node arg0 = new Node(44, arg3, arg3, arg3);
      
      // When: The fall-through analysis is computed for the Node
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Then: The fall-through Node does not have a throw statement
      assertFalse(computeFallThrough.isThrow());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsThrowIsTrue() throws Throwable  {
      // Given: A Java Compiler object "compiler" and a parsed test code "com.google.javascript.jscomp.ControlFlowAnalysis"
      Compiler compiler = new Compiler();
      Node arg1 = compiler.parseTestCode("com.google.javascript.jscomp.ControlFlowAnalysis");
      
      // When: A new Node object is created with the same type as the input node and its fall-through status is computed using the "computeFallThrough" method of the ControlFlowAnalysis class
      Node arg0 = new Node(49, arg1);
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Then: The fall-through status of the new node is not a comma (",")
      assertFalse(computeFallThrough.isComma());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsThisIsTrue() throws Throwable  {
      // Given a Compiler object and some test code,
      Compiler compiler = new Compiler();
      String testCode = "|h";
      
      // When we parse the test code using the Compiler's parseTestCode method,
      Node arg4 = compiler.parseTestCode(testCode);
      
      // And when we create a Node object with some test data,
      Node arg0 = new Node(42, arg4, arg4, arg4, arg4);
      
      // Then we compute the fall-through analysis of the Node using ControlFlowAnalysis's computeFallThrough method,
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // And assert that the result is false, indicating that the Node does not have a fall-through case.
      assertFalse(computeFallThrough.isTrue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsSwitchIsTrue() throws Throwable  {
      // rollbacked to evosuite
      Node arg1 = Node.newString("?T\"8Bv{CN", 115, 103);
      Node arg0 = new Node(110, arg1);
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      assertEquals(49, Node.DIRECT_EVAL);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsReturnIsTrue() throws Throwable  {
      // rollbacked to evosuite
      Node arg3 = Node.newString((-564), "", (-564), (-958));
      Node arg0 = new Node(4, arg3, arg3, arg3, (-1637), 44);
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      assertEquals(30, Node.VAR_ARGS_NAME);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsRegExpIsTrue() throws Throwable  {
      // Arrange
      Node arg4 = new Node(86);
      Node arg0 = new Node(47, arg4, arg4, arg4, arg4);
      
      // Act
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Assert
      assertFalse(computeFallThrough.isGetProp());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsNumberIsTrue() throws Throwable  {
      // Given a node with a fall-through edge
      Node arg0 = new Node(39, new Node(125), new Node(125), new Node(125), 46, 30);
      
      // When the computeFallThrough method is called
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Then the fall-through edge should not be a hook
      assertFalse(computeFallThrough.isHook());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsNullIsTrue() throws Throwable  {
      // Create a node with 41 as its input ID
      Node arg0 = new Node(41, null, null, null, null);
      
      // Create a node with "hsI<:ghy}U;gy1" as its value
      Node arg4 = Node.newString(126, "hsI<:ghy}U;gy1");
      
      // Compute the fall-through node for the given node
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Assert that the fall-through node has an input ID of 53
      assertEquals(53, Node.INPUT_ID);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsNewIsTrue() throws Throwable  {
      // Arrange
      Compiler compiler = new Compiler();
      Node arg4 = compiler.parseTestCode("yt{X#8!ENpBj");
      Node arg0 = new Node(30, arg4, arg4, arg4, arg4);
      
      // Act
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Assert
      assertEquals(30, Node.VAR_ARGS_NAME);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsNameIsTrue() throws Throwable  {
      // Given a node with a value of 38 and a side effect flag set to all
      Node arg0 = new Node(38, 1, 45);
      
      // When computeFallThrough is called on this node
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Then the result should be a new node with a value of 38 and a side effect flag set to all
      assertEquals(0, Node.SIDE_EFFECTS_ALL);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsIfIsTrue() throws Throwable  {
      // Given
      Compiler compiler = new Compiler();
      Node inputNode = compiler.parseTestCode("3t,X#8o!j");
      Node startNode = new Node(108, inputNode, inputNode);
      
      // When
      Node fallThroughNode = ControlFlowAnalysis.computeFallThrough(startNode);
      
      // Then
      assertFalse(fallThroughNode.isAdd());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsGetElemIsTrue() throws Throwable  {
      // Create a new Node with value 35
      Node arg0 = new Node(35);
      
      // Compute the fall-through of the node using ControlFlowAnalysis.computeFallThrough()
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Assert that the fall-through of the node is -1
      assertEquals((-1), computeFallThrough.getLineno());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsFunctionIsTrue() throws Throwable  {
      // Given a Node with value 105
      Node node = new Node(105);
      
      // When we compute the fall through for this Node
      Node computedFallThrough = ControlFlowAnalysis.computeFallThrough(node);
      
      // Then the computed fall through should be false
      assertFalse(computedFallThrough.isTrue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsFalseIsTrue() throws Throwable  {
      // Given a node with value 43
      Node arg0 = new Node(43);
      
      // When the fall through is computed
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Then the result is false (i.e., there are no fall-through edges)
      assertTrue(computeFallThrough.isFalse());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsDelPropIsTrue() throws Throwable  {
      // rollbacked to evosuite
      Node arg1 = Node.newString("", (-564), 0);
      Node arg0 = new Node(31, arg1);
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      assertEquals(8, Node.FLAG_NO_THROWS);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsDecIsTrue() throws Throwable  {
      // Given: A Node object arg0 with a value of 103 and two children with values of 41 and 41
      Node arg0 = new Node(103, 41, 41);
      
      // When: The computeFallThrough method is called on arg0
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Then: The return value of the computeFallThrough method should be a Node object with a value of 2 and two children with values of 41 and 41
      assertEquals(new Node(2, 41, 41), computeFallThrough);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsCatchIsTrue() throws Throwable  {
      // Given: A Node object with a value of 120
      Node arg0 = new Node(120);
      
      // When: The computeFallThrough method is called on the Node object
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Then: The fallThrough property of the returned Node object should be false
      assertFalse(computeFallThrough.isInc());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsBreakIsTrue() throws Throwable  {
      // Given a Node with value 116
      Node node = new Node(116);
      
      // When the fall-through analysis is computed for this node
      Node fallThrough = ControlFlowAnalysis.computeFallThrough(node);
      
      // Then the fall-through node should not have an optional argument
      assertFalse(fallThrough.isOptionalArg());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsBlockIsTrue() throws Throwable  {
      // Given: A Node with a value of 125
      Node node = new Node(125, 125, 125);
      
      // When: The fall-through analysis is computed for the Node
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(node);
      
      // Then: The fall-through analysis indicates that the Node does not have an AND condition
      assertFalse(computeFallThrough.isAnd());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsAssignIsTrue() throws Throwable  {
      // Set up a Node with the given arguments
      Node arg1 = Node.newString("yt{X#8!EN#pBj", 1784, 1784);
      Node arg0 = new Node(86, arg1);
      
      // Call computeFallThrough on the given Node
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Check that the result is not a label name
      assertFalse(computeFallThrough.isLabelName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereHasMoreThanOneChildIsTrue() throws Throwable  {
      // Given a node representing a method body with a break statement
      Compiler compiler = new Compiler();
      Node arg2 = compiler.parseTestCode("[+u0{pm|~A.xweU+`");
      Node arg3 = Node.newString(51, "[+u0{pm|~A.xweU+`");
      Node arg0 = new Node(2, arg2, arg2, arg3, (-3450), 54);
      
      // When the fall-through is computed for this node
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Then the fall-through node should be the next statement after the break statement
      assertFalse(computeFallThrough.isCatch());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereGetTypeIsNegative() throws Throwable  {
      // Given a code snippet that uses the Collections2 class from Guava
      Compiler compiler = new Compiler();
      Node arg3 = compiler.parseTestCode("com.google.common.collect.Collections2");
      
      // When we parse the code and perform control flow analysis
      Node arg0 = new Node((-856), arg3, arg3, arg3, (-1852), (-1852));
      Node computedFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Then we expect the fall through to be 2, indicating that the code is unmodified
      assertEquals(2, Node.FLAG_THIS_UNMODIFIED);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereGetLinenoIsZero() throws Throwable  {
      // Setup
      Node[] nodes = new Node[0];
      Node rootNode = new Node(1810, nodes);
      
      // Execute
      Node fallThrough = ControlFlowAnalysis.computeFallThrough(rootNode);
      
      // Verify
      assertEquals(0, fallThrough.getChildCount());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsSyntheticBlockIsTrue() throws Throwable  {
      // Create a new compiler instance
      Compiler compiler = new Compiler();
      
      // Parse the input code and obtain the parse tree
      Node arg0 = compiler.parseTestCode("com.google.javascript.jscomp.DisambiguateProperties$ConcreteTypeSystem");
      
      // Compute the fall through graph for the parsed code
      Node computeFallThrough = ControlFlowAnalysis.computeFallThrough(arg0);
      
      // Check if the result is a quoted string, indicating that no fall through was found
      assertFalse(computeFallThrough.isQuotedString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsOrIsTrue() throws Throwable  {
      // Given: A Node object with some initial values
      Node node = new Node(100, 200, 300);
      
      // When: The computeFallThrough method is called on the Node object
      Node computedFallThrough = ControlFlowAnalysis.computeFallThrough(node);
      
      // Then: The returned value should be a Node object with the same values as the original Node object
      assertEquals(computedFallThrough, node);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFallThroughReturningNodeWhereIsIncIsTrue() throws Throwable  {
      // Given a Node with an integer value of 102
      Node node = new Node(102);
      
      // When the computeFallThrough method is called on this Node
      Node fallThroughNode = ControlFlowAnalysis.computeFallThrough(node);
      
      // Then the returned Node should have a null source file name
      assertNull(fallThroughNode.getSourceFileName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMayThrowExceptionWithNodeWhereIsNullIsTrue() throws Throwable  {
      // Given a Node object with some properties and a nested Node object
      Node root = new Node(103, 103, 103);
      Node child = new Node(41, root, 42, 16);
      
      // When we call the mayThrowException method on the child Node
      boolean actualResult = ControlFlowAnalysis.mayThrowException(child);
      
      // Then we expect the method to return true because the child Node has a nested Node with an ID of 103, which is the same as the root Node's ID
      assertTrue(actualResult);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMayThrowException() throws Throwable  {
      // No Comments were added
      Node arg1 = new Node(125);
      Node arg0 = new Node(54, arg1, 1, 41);
      boolean mayThrowException = ControlFlowAnalysis.mayThrowException(arg0);
      assertFalse(mayThrowException);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMayThrowExceptionWithNodeWhereIsGetPropIsTrue() throws Throwable  {
      // Given: a variable named "arg0" of type "Node" with the value of 33, and a boolean variable named "mayThrowException" initialized to false.
      // When: the ControlFlowAnalysis class is called with the arg0 node as an argument.
      Node arg0 = new Node(33);
      boolean mayThrowException = ControlFlowAnalysis.mayThrowException(arg0);
      
      // Then: assert that the "mayThrowException" variable was set to true.
      assertTrue(mayThrowException);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMayThrowExceptionWithNodeWhereIsSyntheticBlockIsTrue() throws Throwable  {
      // Test that the method mayThrowException returns false when given a Node object as argument
      
      Compiler compiler = new Compiler();
      Node testCode = compiler.parseTestCode("7");
      boolean actualMayThrowException = ControlFlowAnalysis.mayThrowException(testCode);
      assertFalse(actualMayThrowException);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMayThrowExceptionWithNodeWhereIsThrowIsTrue() throws Throwable  {
      // Given a node with value 49
      Node arg0 = new Node(49);
      
      // When we call the mayThrowException method on this node
      boolean mayThrowException = ControlFlowAnalysis.mayThrowException(arg0);
      
      // Then we expect it to return true, indicating that an exception may be thrown
      assertTrue(mayThrowException);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsBreakTargetWithNodeWhereIsSyntheticBlockIsTrue() throws Throwable  {
      // Given: a Compiler object and a parsed AST of some code
      Compiler compiler = new Compiler();
      Node arg0 = compiler.parseTestCode("");
      
      // When: checking if the node is a break target
      boolean breakTarget = ControlFlowAnalysis.isBreakTarget(arg0, "");
      
      // Then: it should not be a break target
      assertFalse(breakTarget);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProcessWithNodeWhereIsLabelIsTrueAndNodeWhereIsLabelIsTrue() throws Throwable  {
      // Setup
      Compiler compiler = new Compiler();
      Node parsedCode = compiler.parseTestCode("");
      ControlFlowAnalysis controlFlowAnalysis = new ControlFlowAnalysis(compiler, true, true);
      
      // Execute
      Node node = new Node(126, parsedCode, parsedCode, parsedCode, 115, (-2122));
      controlFlowAnalysis.process(node, node);
      
      // Verify
      assertFalse(node.isThis());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testVisitThrowsNullPointerException() throws Throwable  {
      // Given: A JUnit test that verifies the behavior of a method that takes a NodeTraversal argument
      Compiler compiler = new Compiler();
      Node testCodeNode = compiler.parseTestCode("");
      Node node = new Node(115, testCodeNode, testCodeNode, testCodeNode, 2, 0);
      
      // When: The method is called with a null NodeTraversal argument
      ControlFlowAnalysis controlFlowAnalysis = new ControlFlowAnalysis(compiler, true, true);
      try {
      controlFlowAnalysis.visit((NodeTraversal) null, node, testCodeNode);
      fail("Expected NullPointerException");
      } catch (NullPointerException e) {
      // Then: The method throws a NullPointerException with the expected message
      verifyException("com.google.javascript.jscomp.ControlFlowAnalysis", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetCatchHandlerForBlock() throws Throwable  {
      // Create a new node with a block that contains a try-catch statement.
      Node arg0 = new Node(125);
      Node node = new Node(16, arg0, arg0, 52, 29);
      
      // Get the catch handler for the block.
      Node catchHandlerForBlock = ControlFlowAnalysis.getCatchHandlerForBlock(arg0);
      
      // Check that the catch handler is null.
      assertNull(catchHandlerForBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetExceptionHandlerThrowsNullPointerException() throws Throwable  {
      Node arg0 = new Node((-1416));
      // Undeclared exception!
      try {
      ControlFlowAnalysis.getExceptionHandler(arg0);
      fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      // Verify that the exception is thrown due to an invalid argument (the node has no parent)
      assertEquals("The node must have a parent", "com.google.javascript.jscomp.ControlFlowAnalysis", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetExceptionHandlerWithNodeWhereIsFunctionIsTrue() throws Throwable  {
      // Create a new Node with some arbitrary values for its fields
      Node arg2 = new Node(125, 125, 125);
      Node arg0 = new Node(105, arg2, arg2, 8203, 30);
      
      // Call the getExceptionHandler method on the Node and assert that it returns null
      Node exceptionHandler = ControlFlowAnalysis.getExceptionHandler(arg0);
      assertNull(exceptionHandler);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetExceptionHandlerWithNodeWhereIsScriptIsTrue() throws Throwable  {
      // Given a code snippet "3t,X#8o!j"
      Compiler compiler = new Compiler();
      Node arg0 = compiler.parseTestCode("3t,X#8o!j");
      
      // When the exception handler is obtained for this code snippet
      Node exceptionHandler = ControlFlowAnalysis.getExceptionHandler(arg0);
      
      // Then the exception handler should be null
      assertNull(exceptionHandler);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsContinueStructureWithNonNull() throws Throwable  {
      // Given a node with a string value "Hello World!"
      Node arg0 = Node.newString(115, "Hello World!");
      
      // When we check if it is a continue structure
      boolean continueStructure = ControlFlowAnalysis.isContinueStructure(arg0);
      
      // Then it should return true
      assertTrue(continueStructure);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsContinueStructureWithNodeWhereIsDoIsTrue() throws Throwable  {
      // rollbacked to evosuite
      Node arg1 = Node.newString(115, "F$mn`,F|)Q3m1");
      Node arg0 = new Node(114, arg1);
      boolean continueStructure = ControlFlowAnalysis.isContinueStructure(arg0);
      assertTrue(continueStructure);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsContinueStructureWithNodeWhereIsWhileIsTrue() throws Throwable  {
      // Arrange
      Compiler compiler = new Compiler();
      Node arg2 = compiler.parseTestCode("yt{X#8!EN#pBj");
      Node arg0 = new Node(113, arg2, arg2);
      
      // Act
      boolean continueStructure = ControlFlowAnalysis.isContinueStructure(arg0);
      
      // Assert
      assertTrue(continueStructure);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsBreakStructure() throws Throwable  {
      // rollbacked to evosuite
      Node arg3 = Node.newString((-564), "", (-564), (-959));
      Node arg0 = new Node(115, arg3, arg3, arg3, 2, 10);
      boolean breakStructure = ControlFlowAnalysis.isBreakStructure(arg0, false);
      assertTrue(breakStructure);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsBreakTargetReturningTrue() throws Throwable  {
      // Create a new instance of the Compiler class
      Compiler compiler = new Compiler();
      
      // Parse some test code using the Compiler's parseTestCode method
      Node arg4 = compiler.parseTestCode("com.google.javascript.jscomp.ControlFlowAnalysis");
      
      // Create a new node with the same structure as the parsed test code
      Node arg0 = new Node(114, arg4, arg4, arg4, arg4);
      
      // Check if the node is a break target
      boolean breakTarget = ControlFlowAnalysis.isBreakTarget(arg0, (String) null);
      
      // Assert that the node is indeed a break target
      assertTrue(breakTarget);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsBreakTargetWithNodeWhereIsWhileIsTrue() throws Throwable  {
      Compiler compiler = new Compiler();
      Node testCode = compiler.parseTestCode("com.google.javascript.jscomp.ControlFlowAnalysis");
      Node nodeToAnalyze = new Node(113, testCode);
      
      // Test that a null pointer exception is thrown when passing an invalid argument to the method
      try {
      ControlFlowAnalysis.isBreakTarget(nodeToAnalyze, "");
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Verify that the expected exception was thrown and that no message was provided in the exception object
      verifyException("com.google.javascript.jscomp.ControlFlowAnalysis", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMayThrowExceptionWithNodeWhereIsDecIsTrue() throws Throwable  {
      // Given a node with a value of 103
      Node arg0 = new Node(103);
      
      // When we use the ControlFlowAnalysis to check if it may throw an exception
      boolean mayThrowException = ControlFlowAnalysis.mayThrowException(arg0);
      
      // Then we expect the method to return true, indicating that the node may throw an exception
      assertTrue(mayThrowException);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMayThrowExceptionWithNodeWhereIsIncIsTrue() throws Throwable  {
      // Given a Node with an exception-throwing method
      Node node = new Node(102, 999, 102);
      
      // When we call the mayThrowException method on that Node
      boolean result = ControlFlowAnalysis.mayThrowException(node);
      
      // Then we expect it to return true, indicating that the method may throw an exception
      assertTrue(result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMayThrowExceptionWithNodeWhereIsAssignIsTrue() throws Throwable  {
      // Given a Node with an integer value of 86
      Node arg0 = new Node(86);
      
      // When the method mayThrowException is called on this Node
      boolean mayThrowException = ControlFlowAnalysis.mayThrowException(arg0);
      
      // Then assert that it returns true
      assertTrue(mayThrowException);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMayThrowExceptionWithNodeWhereIsInstanceOfIsTrue() throws Throwable  {
      // Given a node with a non-null child node
      Node arg1 = Node.newString((-564), "", (-564), (-564));
      Node arg0 = new Node(52, arg1);
      
      // When the method is called on this node
      boolean mayThrowException = ControlFlowAnalysis.mayThrowException(arg0);
      
      // Then it should return true
      assertTrue(mayThrowException);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMayThrowExceptionWithNonNull() throws Throwable  {
      // Given: The method "mayThrowException" is being called with a node of type "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph$2".
      Node arg0 = Node.newString(37, "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph$2", 938, 1);
      // When: The method is called with the given node.
      boolean mayThrowException = ControlFlowAnalysis.mayThrowException(arg0);
      // Then: Assert that the method returns true indicating that an exception may be thrown.
      assertTrue(mayThrowException);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMayThrowExceptionWithNodeWhereIsGetElemIsTrue() throws Throwable  {
      // Given: a Node object with an integer value of 35
      Node arg0 = new Node(35);
      
      // When: the ControlFlowAnalysis.mayThrowException method is called with the Node object as its argument
      boolean mayThrowException = ControlFlowAnalysis.mayThrowException(arg0);
      
      // Then: the method returns true, indicating that an exception may be thrown when attempting to access the value of the Node object
      assertTrue(mayThrowException);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMayThrowExceptionWithNodeWhereIsNewIsTrue() throws Throwable  {
      // Given: A node with a value of 30 is created.
      Node arg0 = new Node(30);
      
      // When: The method mayThrowException is called with the node as an argument.
      boolean mayThrowException = ControlFlowAnalysis.mayThrowException(arg0);
      
      // Then: The result should be true, indicating that the node may throw an exception.
      assertTrue(mayThrowException);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsBreakTargetWithNonNull() throws Throwable  {
      // Arrange
      Node arg0 = Node.newString(108, "JSC_FUNCTION_NAMESPACE_ERROR", 125, 125);
      Node node = new Node(792, arg0);
      
      // Act
      boolean breakTarget = ControlFlowAnalysis.isBreakTarget(arg0, "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph");
      
      // Assert
      assertFalse(breakTarget);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsBreakTargetWithNodeWhereGetCharnoIsPositive() throws Throwable  {
      Node arg0 = new Node(125, 125, 125);
      // Check that the method correctly identifies whether or not a node is a break target
      assertTrue(ControlFlowAnalysis.isBreakTarget(arg0, "breakTargetLabel"));
      
      // Check that the method throws an exception when passed a null argument
      try {
      ControlFlowAnalysis.isBreakTarget(null, "breakTargetLabel");
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Verify that the expected exception was thrown
      verifyException("com.google.javascript.jscomp.ControlFlowAnalysis", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFollowNodeTakingNodeReturningNodeWhereIsInIsTrue() throws Throwable  {
      // No Comments were added
      Node arg0 = new Node(125);
      Node arg2 = new Node(51);
      Node node = new Node((-3), arg0, arg2);
      Node computeFollowNode = ControlFlowAnalysis.computeFollowNode(arg0);
      assertFalse(computeFollowNode.isBreak());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComputeFollowNodeTakingNodeReturningNull() throws Throwable  {
      // This test case ensures that the computeFollowNode method returns null when the input node is a JSC_FUNCTION_NAMESPACE_ERROR.
      
      Node arg0 = Node.newString(125, "JSC_FUNCTION_NAMESPACE_ERROR", 125, 125);
      Node node = new Node(16, arg0);
      
      Node computeFollowNode = ControlFlowAnalysis.computeFollowNode(arg0);
      
      assertNull(computeFollowNode);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProcessWithNonNullAndNonNull() throws Throwable  {
      // Given a Compiler object and a Node object with source code
      Compiler compiler = new Compiler();
      Node node = Node.newString(4, "", 4, 4);
      
      // When the ControlFlowAnalysis method is called on the Compiler object with the Node object as an argument
      ControlFlowAnalysis controlFlowAnalysis = new ControlFlowAnalysis(compiler, false, true);
      controlFlowAnalysis.process(node, node);
      
      // Then the resulting Node object has a source position of 16388
      assertEquals(16388, node.getSourcePosition());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProcessWithNodeWhereGetTypeIsNegativeAndNodeWhereGetTypeIsNegative() throws Throwable  {
      // Given
      Compiler compiler = new Compiler();
      Node node117 = new Node(117, 117, 117);
      ControlFlowAnalysis controlFlowAnalysis = new ControlFlowAnalysis(compiler, false, false);
      Node nodeMinus1 = new Node((-1), node117, node117, node117);
      
      // When
      try {
      controlFlowAnalysis.process(nodeMinus1, nodeMinus1);
      fail("Expecting exception: RuntimeException");
      } catch (RuntimeException e) {
      verifyException("com.google.common.base.Preconditions", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProcessWithNodeWhereIsBreakIsTrueAndNodeWhereIsBreakIsTrue() throws Throwable  {
      // Given a Node object representing some code to be analyzed by the Compiler class,
      // and a boolean value indicating whether control flow analysis should be performed
      // recursively or not.
      Node arg1 = new Node(116, 116, 116);
      Compiler arg0 = new Compiler();
      arg0.parseTestCode("Nt reachbl");
      ControlFlowAnalysis controlFlowAnalysis = new ControlFlowAnalysis(arg0, false, false);
      
      // When the process method is called with the Node object and a flag indicating whether
      // to perform recursive control flow analysis or not.
      controlFlowAnalysis.process(arg1, arg1);
      
      // Then an exception should be thrown, indicating that an internal compiler error has occurred.
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProcessWithNodeWhereIsIfIsTrueAndNodeWhereIsIfIsTrue() throws Throwable  {
      // Set up the Compiler object and parse some test code
      Compiler compiler = new Compiler();
      Node parsedCode = compiler.parseTestCode("Cannot find continue target.");
      
      // Create a ControlFlowAnalysis object with throwOnError set to true and trackThrowables set to true
      ControlFlowAnalysis controlFlowAnalysis = new ControlFlowAnalysis(compiler, true, true);
      
      // Create a Node with the appropriate fields for the test case
      Node node = new Node(108, parsedCode, parsedCode, parsedCode, 36, 30);
      
      // Try to process the Node using the ControlFlowAnalysis object, expecting a RuntimeException to be thrown
      try {
      controlFlowAnalysis.process(node, node);
      fail("Expecting exception: RuntimeException");
      } catch (RuntimeException e) {
      // Catch the exception and verify that it is the expected type
      assertTrue(e instanceof RuntimeException);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProcessWithNodeWhereIsReturnIsTrue() throws Throwable  {
      // Create a new compiler instance and parse the input string "z E: k"
      Compiler compiler = new Compiler();
      Node parsedNode = compiler.parseTestCode("z E: k");
      
      // Create a new ControlFlowAnalysis object with the given parameters
      ControlFlowAnalysis controlFlowAnalysis = new ControlFlowAnalysis(compiler, true, true);
      
      // Create a new Node instance with the given parameters
      Node node = new Node(4, parsedNode, parsedNode, parsedNode, 0, 0);
      
      // Process the node using the ControlFlowAnalysis object
      controlFlowAnalysis.process(node, node);
      
      // Assert that the isTypeOf() method returns false for the given node
      assertFalse(node.isTypeOf());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProcessWithNodeWhereIsFunctionIsTrueAndNodeWhereIsFunctionIsTrue() throws Throwable  {
      Node input = new Node(105);
      Compiler compiler = new Compiler();
      ControlFlowAnalysis controlFlowAnalysis = new ControlFlowAnalysis(compiler, false, false);
      // Given: A node with an invalid value (105)
      
      try {
      controlFlowAnalysis.process(input, input);
      fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
      // When: The node is passed to the ControlFlowAnalysis class for analysis
      // Then: An exception is thrown due to the invalid value of the node
      verifyException("com.google.common.base.Preconditions", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetCfg() throws Throwable  {
      // Given a Compiler object and a ControlFlowAnalysis instance with the "reachable" option set to true and the "ignoreSyntheticNodes" option set to true
      Compiler arg0 = new Compiler();
      ControlFlowAnalysis controlFlowAnalysis = new ControlFlowAnalysis(arg0, true, true);
      
      // When we get the control flow graph for the given code
      ControlFlowGraph<Node> cfg = controlFlowAnalysis.getCfg();
      
      // Then the control flow graph should be null
      assertNull(cfg);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testProcessWithNodeWhereIsBlockIsTrueAndNodeWhereIsBlockIsTrue() throws Throwable  {
      // Create a new Node with value 125
      Node arg2 = new Node(125);
      
      // Create a new ControlFlowAnalysis object with null compiler and disable type checking and scope analysis
      ControlFlowAnalysis arg1 = new ControlFlowAnalysis((AbstractCompiler) null, false, false);
      
      // Process the Node using the ControlFlowAnalysis object
      arg1.process(arg2, arg2);
      
      // Create a new NodeTraversal object with null compiler and the previously created ControlFlowAnalysis object
      NodeTraversal nodeTraversal = new NodeTraversal((AbstractCompiler) null, arg1);
      
      // Create a new Node with value 77 and two child nodes that are equal to the newly created Node
      Node arg0 = new Node(77, arg2, arg2);
      
      // Traverse the Node using the NodeTraversal object
      nodeTraversal.traverse(arg0);
      
      // Assert that the value of Node.DIRECTIVES is equal to 48
      assertEquals(48, Node.DIRECTIVES);
  }
}
