/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Thu Mar 21 13:55:58 GMT 2024
 */

package com.google.javascript.jscomp;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import com.google.javascript.jscomp.ExploitAssigns;
import com.google.javascript.rhino.Node;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class ExploitAssigns_Original_ESTest extends ExploitAssigns_Original_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereGetTypeIsNegative() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node((-3155));
      arg0.setWasEmptyNode(true);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isNull());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsWithIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("Z4s, Ak");
      Node arg0 = new Node(119, arg2, arg2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isVar());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsVarArgsIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("tNUolxjBfpwD.");
      Node arg0 = new Node(15, arg2, arg2);
      arg0.setVarArgs(true);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isSwitch());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsTypeOfIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = new Node(0, 0, 0);
      Node arg0 = new Node(32, arg1, 38, 0);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(32, Node.INCRDECR_PROP);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsTrueIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = Node.newString((-699), "l6)+K&a/[1");
      Node arg0 = new Node(44, arg1);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isRegExp());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsThrowIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = new Node(1087, 38, 1665);
      Node arg0 = new Node(49, arg1, 12, (-1167));
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(1, Node.FLAG_GLOBAL_STATE_UNMODIFIED);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsThisIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = new Node(517, 517, 25);
      Node arg0 = new Node(42, arg1, (-255), 1149);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(36, Node.QUOTED_PROP);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsSwitchIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = Node.newString("", 110, 2085);
      Node arg0 = new Node(110, arg1);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isGetProp());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsStringKeyIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg3 = Node.newString("Y*=DK0<_|H>Rb1N>nR}");
      Node arg0 = new Node(154, arg3, arg3, arg3, 48, 86);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(31, Node.SIDE_EFFECTS_FLAGS_MASK);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsStringIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = new Node((-496), (-923), 1082);
      Node arg0 = new Node(40, arg1, (-2594), 37);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(8, Node.FLAG_NO_THROWS);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsSetterDefIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("Z4s, Ak");
      Node arg0 = new Node(148, arg2, arg2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.wasEmptyNode());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsReturnIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = new Node(8232, 0, 1798);
      Node arg0 = new Node(4, arg1, 15, 1798);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(38, Node.SYNTHETIC_BLOCK_PROP);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsRegExpIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = new Node(1087);
      Node arg0 = new Node(47, arg1, (-1650), 100);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(51, Node.STATIC_SOURCE_FILE);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsOrIsTrue() throws Throwable  {
      Node arg1 = new Node(8232);
      Node arg0 = new Node(100, arg1, 51, 49);
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(16, Node.SOURCENAME_PROP);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsOptionalArgIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(8232, 8232, 8232);
      arg0.setOptionalArg(true);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isContinue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsObjectLitIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(64);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(16, Node.SOURCENAME_PROP);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsNumberIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = Node.newString("tNUolxjBfpwD.");
      Node arg0 = new Node(39, arg1, 16, 3142);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(68678, optimizeSubtree.getSourcePosition());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsNullIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg3 = Node.newString("");
      Node arg0 = new Node(41, arg3, arg3, arg3);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isNoSideEffectsCall());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsNotIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("");
      Node arg0 = new Node(26, arg2, arg2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsNewIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg3 = new Node(8232, 8232, 8232);
      Node arg0 = new Node(30, arg3, arg3, arg3, 41, 12);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isThrow());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsNameIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(38, 38, 38);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(8, Node.FLAG_NO_THROWS);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsNEIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(13);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isTry());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsLabelNameIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("^Brb<*S3E7p6");
      Node arg0 = new Node(153, arg2, arg2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isLocalResultCall());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsLabelIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = new Node(86, 8232, 2683);
      Node arg0 = new Node(126, arg1, 32, 2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(38, Node.SYNTHETIC_BLOCK_PROP);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsInstanceOfIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg3 = new Node(8232, 8232, 8232);
      Node arg0 = new Node(52, arg3, arg3, arg3, 30, 50);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isOptionalArg());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsInIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("");
      Node arg0 = new Node(51, arg2, arg2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals((-1), optimizeSubtree.getLineno());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsHookIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(98, 3046, (-644));
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(16, Node.FLAG_LOCAL_RESULTS);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsGetPropIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg3 = Node.newString("");
      Node arg0 = new Node(33, arg3, arg3, arg3);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(4, Node.FLAG_ARGUMENTS_UNMODIFIED);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsGetElemIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = new Node(8211, 8211, 8211);
      Node arg0 = new Node(35, arg2, arg2, 1, 44);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isAnd());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsFunctionIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("<Y5vIsw-$");
      Node arg0 = new Node(105, arg2, arg2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isVoid());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsForIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(115, 1429, 1429);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.hasMoreThanOneChild());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsFalseIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node[] arg1 = new Node[0];
      Node arg0 = new Node(43, arg1, 108, 16);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(39, Node.EMPTY_BLOCK);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsExprResultIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(130, 130, 130);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isInc());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsEmptyIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(124, (-36), (-36));
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(0, optimizeSubtree.getChildCount());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsDoIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("<Y5vIsw-$");
      Node arg0 = new Node(114, arg2, arg2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isNew());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsDecIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node[] arg1 = new Node[0];
      Node arg0 = new Node(103, arg1);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(37, Node.OPT_ARG_NAME);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsDebuggerIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("^Brb<*S3E7p6");
      Node arg0 = new Node(152, arg2, arg2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isAssignAdd());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsContinueIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = Node.newString("i)ji1H[:i*[", 117, 117);
      Node arg0 = new Node(117, arg1, (-1227), (-1032));
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(12, Node.COLUMN_BITS);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsCommaIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("^Brb<*S3E7p6");
      Node arg0 = new Node(85, arg2, arg2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isStringKey());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsCatchIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("/@?i");
      Node arg0 = new Node(120, arg2, arg2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertSame(optimizeSubtree, arg0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsCallIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg3 = Node.newString("Ms");
      Node arg0 = new Node(37, arg3, arg3, arg3);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(1, optimizeSubtree.getChildCount());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsBlockIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(125, 125, (-959));
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(15, Node.NO_SIDE_EFFECTS);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsAssignAddIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("/@?i");
      Node arg0 = new Node(93, arg2, arg2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(51, Node.STATIC_SOURCE_FILE);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsAssignIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(86, 823, 86);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isInstanceOf());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsArrayLitIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(63);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(12, Node.COLUMN_BITS);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereGetTypeIsZero() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = Node.newString("\"#j5xW&3", 0, 8192);
      Node arg0 = new Node(0, arg1);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(50, Node.FREE_CALL);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsAndIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node[] arg1 = new Node[0];
      Node arg0 = new Node(101, arg1);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isNE());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsDelPropIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg3 = Node.newString("tNUolxjBfdpwD.");
      Node arg0 = new Node(31, arg3, arg3, arg3, 0, 12);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isCase());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereGetLengthIsPositive() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(8232);
      arg0.setLength(29);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(12, Node.COLUMN_BITS);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsAddIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg1 = Node.newString("J<)F|Yf=w,`D`<pi|");
      Node arg0 = new Node(21, arg1, 46, 0);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(41, Node.BRACELESS_TYPE);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsCaseIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(111, 111, 111);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertEquals(36, Node.QUOTED_PROP);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsWhileIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg2 = Node.newString("!s");
      Node arg0 = new Node(113, arg2, arg2);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertNull(optimizeSubtree.getSourceFileName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOptimizeSubtreeReturningNodeWhereIsIfIsTrue() throws Throwable  {
      ExploitAssigns exploitAssigns = new ExploitAssigns();
      Node arg0 = new Node(108);
      Node optimizeSubtree = exploitAssigns.optimizeSubtree(arg0);
      assertFalse(optimizeSubtree.isExprResult());
  }
}
