/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Mar 18 11:58:57 GMT 2024
 */

package org.apache.commons.collections4.list;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import org.apache.commons.collections4.list.TreeList;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TreeList_ESTest extends TreeList_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextIndex() throws Throwable  {
      // No Comments were added
      TreeList<Integer> arg0 = new TreeList<Integer>();
      TreeList.TreeListIterator<Integer> treeList_TreeListIterator = new TreeList.TreeListIterator<Integer>(arg0, 270);
      int nextIndex = treeList_TreeListIterator.nextIndex();
      assertEquals(270, nextIndex);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckModCount() throws Throwable  {
      // Create a new TreeList<Object> object
      TreeList<Object> treeList = new TreeList<Object>();
      
      // Create an iterator for the TreeList object
      TreeList.TreeListIterator<Object> iterator = new TreeList.TreeListIterator<Object>(treeList, (-779));
      
      // Check that the modCount of the TreeList is correct
      iterator.checkModCount();
      
      // Assert that the iterator has a next element
      assertTrue(iterator.hasNext());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSizeReturningZero() throws Throwable  {
      // Given: A LinkedList of Integers and a TreeList initialized with the LinkedList
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      TreeList<Integer> treeList = new TreeList<Integer>(arg0);
      
      // When: The size of the TreeList is retrieved
      int size = treeList.size();
      
      // Then: The size should be equal to the number of elements in the LinkedList
      assertFalse(arg0.contains(size));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSizeReturningPositive() throws Throwable  {
      // Given: The LinkedList arg0 contains a null element
      // When: A new TreeList is created from the LinkedList arg0
      // Then: The TreeList should not contain the size of the LinkedList (which is null)
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      arg0.add((Integer) null);
      TreeList<Integer> treeList = new TreeList<Integer>(arg0);
      int size = treeList.size();
      assertFalse(arg0.contains(size));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetTaking2Arguments() throws Throwable  {
      // Set up the input arguments for the test
      LinkedList<Integer> arg0 = new LinkedList<>();
      arg0.add((Integer) null);
      
      // Create a TreeList from the input arguments and set it to a variable
      TreeList<Integer> arg1 = new TreeList<>(arg0);
      TreeList<Object> treeList = new TreeList<>(arg1);
      
      // Test that setting a null value at index 0 returns a TreeList with size 1
      TreeList set = (TreeList)treeList.set(0, (Object) null);
      assertEquals(1, set.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testListIteratorTakingIntReturningListIteratorWhereHasNextIsTrue() throws Throwable  {
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      // Creating a LinkedList containing null and adding it to the list of items to be sorted
      arg0.add((Integer) null);
      arg0.addAll((Collection<? extends Integer>) arg0);
      TreeList<Integer> treeList = new TreeList<Integer>(arg0);
      // Creating an instance of a TreeList from the LinkedList containing null and adding it to the list of items to be sorted
      ListIterator<Integer> listIterator = treeList.listIterator(1);
      // Creating a ListIterator for the TreeList and positioning it at index 1
      assertTrue(listIterator.hasPrevious());
      // Asserting that the previous element exists in the TreeList using the hasPrevious() method of the ListIterator
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testListIteratorTakingIntReturningListIteratorWhereHasNextIsFalse() throws Throwable  {
      // Given an empty TreeList
      TreeList<Integer> treeList = new TreeList<Integer>();
      
      // When we create a ListIterator from the TreeList with index 0
      ListIterator<Integer> listIterator = treeList.listIterator(0);
      
      // Then the ListIterator should not have any elements
      assertFalse(listIterator.hasNext());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testListIteratorTakingNoArgumentsReturningListIteratorWhereHasNextIsTrue() throws Throwable  {
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      arg0.add((Integer) null);
      TreeList<Object> treeList = new TreeList<Object>(arg0);
      ListIterator<Object> listIterator = treeList.listIterator();
      // Check that the iterator does not have a previous element
      assertFalse(listIterator.hasPrevious());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGet() throws Throwable  {
      // Create a new TreeList with an object as its element
      TreeList<Object> treeList = new TreeList<>();
      Object arg0 = new Object();
      treeList.add(arg0);
      
      // Add the same object to the TreeList again
      treeList.add(arg0);
      
      // Get the second element from the TreeList
      Object get = treeList.get(1);
      
      // Assert that the returned value is the same as the first element added
      assertSame(get, arg0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testContainsReturningTrue() throws Throwable  {
      // No Comments were added
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      arg0.add((Integer) null);
      TreeList<Object> treeList = new TreeList<Object>(arg0);
      boolean contains = treeList.contains((Object) null);
      assertTrue(contains);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToArrayReturningNonEmptyArray() throws Throwable  {
      // Test that the LinkedList and TreeList classes work correctly with null elements
      LinkedList<Integer> arg1 = new LinkedList<Integer>();
      arg1.add((Integer) null);
      arg1.addAll((Collection<? extends Integer>) arg1);
      TreeList<Integer> treeList = new TreeList<Integer>(arg1);
      treeList.add((Integer) null);
      treeList.addAll(1, (Collection<? extends Integer>) arg1);
      Object[] array = treeList.toArray();
      assertEquals(5, array.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetThrowsIndexOutOfBoundsException() throws Throwable  {
      // No Comments were added
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      TreeList<Integer> treeList = new TreeList<Integer>(arg0);
      // Undeclared exception!
      try { 
        treeList.get(0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // Invalid index:0, size=0
         //
         verifyException("org.apache.commons.collections4.list.TreeList", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetTakingObject() throws Throwable  {
      // No Comments were added
      TreeList<Object> arg0 = new TreeList<Object>();
      TreeList.TreeListIterator<Object> treeList_TreeListIterator = new TreeList.TreeListIterator<Object>(arg0, (-779));
      // Undeclared exception!
      try { 
        treeList_TreeListIterator.set(arg0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.list.TreeList$TreeListIterator", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveTakingNoArguments() throws Throwable  {
      // Create a TreeList<Integer> object and an iterator for it
      TreeList<Integer> arg0 = new TreeList<Integer>();
      TreeList.TreeListIterator<Integer> treeList_TreeListIterator = new TreeList.TreeListIterator<Integer>(arg0, (-11));
      
      // Remove the current element from the iterator (should throw an IllegalStateException)
      try {
      treeList_TreeListIterator.remove();
      fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
      // The remove() method should only be called on a valid element in the list,
      // and this iterator has not been advanced to any element yet.
      // Since we have passed (-11) as the initial index for the iterator, it is outside the bounds of the list,
      // and so calling remove() on it should throw an IllegalStateException.
      verifyException("org.apache.commons.collections4.list.TreeList$TreeListIterator", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrevious() throws Throwable  {
      // No Comments were added
      TreeList<Integer> arg0 = new TreeList<Integer>();
      TreeList.TreeListIterator<Integer> treeList_TreeListIterator = new TreeList.TreeListIterator<Integer>(arg0, (-1333));
      // Undeclared exception!
      try { 
        treeList_TreeListIterator.previous();
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // Already at start of list.
         //
         verifyException("org.apache.commons.collections4.list.TreeList$TreeListIterator", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTreeListTakingCollection0() throws Throwable  {
      // No Comments were added
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      arg0.add((Integer) null);
      TreeList<Integer> arg1 = new TreeList<Integer>(arg0);
      // Undeclared exception!
      try { 
        arg1.addAll(0, (Collection<? extends Integer>) arg1);
        fail("Expecting exception: ConcurrentModificationException");
      
      } catch(ConcurrentModificationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.list.TreeList$TreeListIterator", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveTakingIntWithZero() throws Throwable  {
      // rollbacked to evosuite
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      arg0.add((Integer) null);
      arg0.addAll((Collection<? extends Integer>) arg0);
      arg0.add((Integer) null);
      arg0.removeFirstOccurrence((Object) null);
      TreeList<Object> treeList = new TreeList<Object>(arg0);
      treeList.remove(0);
      boolean addAll = treeList.addAll((Collection<?>) arg0);
      assertEquals(3, treeList.size());
      assertTrue(addAll);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddAllAndRemoveTakingInt0() throws Throwable  {
      // No Comments were added
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      arg0.add((Integer) null);
      arg0.addAll((Collection<? extends Integer>) arg0);
      arg0.add((Integer) null);
      TreeList<Object> treeList = new TreeList<Object>(arg0);
      treeList.addAll((Collection<?>) arg0);
      treeList.remove(1);
      assertEquals(5, treeList.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveTakingInt0() throws Throwable  {
      // Create a LinkedList with null elements and add it to a TreeList
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      arg0.add((Integer) null);
      arg0.addAll((Collection<? extends Integer>) arg0);
      arg0.add((Integer) null);
      TreeList<Object> treeList = new TreeList<Object>(arg0);
      
      // Call the remove method with an index argument
      treeList.remove(1);
      
      // Assert that the size of the treeList is 2, indicating that the element at index 1 was removed
      assertEquals(2, treeList.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveTakingInt1() throws Throwable  {
      // Test that the TreeList can be constructed from a LinkedList with null elements
      LinkedList<Integer> arg1 = new LinkedList<Integer>();
      arg1.add((Integer) null);
      arg1.addAll((Collection<? extends Integer>) arg1);
      arg1.add((Integer) null);
      
      // Create a TreeList using the linked list as its initial contents
      TreeList<Object> treeList = new TreeList<Object>(arg1);
      
      // Add an element to the beginning of the list and check that the size is correct
      treeList.addAll(1, (Collection<?>) arg1);
      assertEquals(5, treeList.size());
      
      // Remove an element from the middle of the list and check that the size is correct
      treeList.remove(1);
      assertEquals(4, treeList.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveTakingInt2() throws Throwable  {
      // No Comments were added
      LinkedList<Integer> arg1 = new LinkedList<Integer>();
      arg1.add((Integer) null);
      arg1.add((Integer) null);
      TreeList<Object> arg0 = new TreeList<Object>(arg1);
      arg1.add((Integer) null);
      arg0.addAll(0, (Collection<?>) arg1);
      TreeList<Object> treeList = new TreeList<Object>(arg0);
      treeList.remove(2);
      assertEquals(4, treeList.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTreeListTakingCollection1() throws Throwable  {
      // Tests that adding null elements to a LinkedList and then creating a TreeList from it results in an empty TreeList with the correct size.
      LinkedList<Integer> arg0 = new LinkedList<>();
      arg0.add(null);
      arg0.addAll((Collection<? extends Integer>) arg0);
      arg0.add(null);
      TreeList<Integer> treeList = new TreeList<>(arg0);
      treeList.addAll(1, (Collection<? extends Integer>) arg0);
      treeList.removeAll(arg0);
      assertEquals(0, treeList.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveTakingInt3() throws Throwable  {
      // Tests the addAll() method of TreeList with a null collection argument
      // Creates a new LinkedList containing two null values
      LinkedList<Integer> arg1 = new LinkedList<>();
      arg1.add((Integer) null);
      arg1.add((Integer) null);
      // Creates a new TreeList with the LinkedList as its argument
      TreeList<Object> treeList = new TreeList<>(arg1);
      // Adds all elements of the LinkedList to the TreeList, starting from index 1
      treeList.addAll(1, (Collection<?>) arg1);
      // Asserts that the size of the TreeList is equal to 3
      assertEquals(3, treeList.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveTakingInt4() throws Throwable  {
      // Given: A LinkedList containing null elements and a TreeList initialized with the LinkedList
      LinkedList<Integer> arg1 = new LinkedList<Integer>();
      arg1.add((Integer) null);
      arg1.add((Integer) null);
      TreeList<Object> treeList = new TreeList<Object>(arg1);
      
      // When: Adding all elements from the LinkedList to the TreeList at position 1, and then removing one element
      treeList.addAll(1, (Collection<?>) arg1);
      treeList.remove(1);
      
      // Then: The size of the TreeList should be 7, as 3 null elements were added to the LinkedList and 2 null elements were removed from the LinkedList
      assertEquals(7, treeList.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTreeListTakingCollection2() throws Throwable  {
      // LinkedList<Integer> arg0 represents a list of integers
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      
      // Add three null values to the list
      arg0.add((Integer) null);
      arg0.add((Integer) null);
      arg0.add((Integer) null);
      
      // Create a TreeList object with the list of integers as its argument
      TreeList<Object> treeList = new TreeList<Object>(arg0);
      
      // lastIndexOf(arg0) returns the index of the last occurrence of arg0 in the list, or -1 if not found
      int lastIndexOf = treeList.lastIndexOf(arg0);
      
      // Assert that the lastIndexOf method returned -1, indicating that the argument was not found in the list
      assertEquals((-1), lastIndexOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddAllAndRemoveTakingInt1() throws Throwable  {
      // No Comments were added
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      arg0.add((Integer) null);
      arg0.add((Integer) null);
      TreeList<Object> treeList = new TreeList<Object>(arg0);
      treeList.addAll((Collection<?>) arg0);
      treeList.remove(1);
      assertEquals(3, treeList.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveTakingInt5() throws Throwable  {
      // Create a linked list with two null nodes
      LinkedList<Integer> arg0 = new LinkedList<>();
      arg0.add((Integer) null);
      arg0.add((Integer) null);
      
      // Create a tree list from the linked list
      TreeList<Object> treeList = new TreeList<>(arg0);
      
      // Remove the first node from the tree list
      Object remove = treeList.remove(1);
      
      // Assert that the removed node is null
      assertNull(remove);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testListIteratorTakingIntThrowsIndexOutOfBoundsException() throws Throwable  {
      TreeList<Object> treeList = new TreeList<Object>();
      // Test that a negative index throws an IndexOutOfBoundsException
      try {
      // Attempt to create a list iterator with a negative index.
      treeList.listIterator((-1));
      fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
      // Verify that the expected exception was thrown.
      verifyException("org.apache.commons.collections4.list.TreeList", e);
      
      // Verify that the exception message contains the expected information about the invalid index and size.
      assertTrue(e.getMessage().contains("Invalid index:-1, size=0"));}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddAll() throws Throwable  {
      // No Comments were added
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      arg0.add((Integer) null);
      TreeList<Object> treeList = new TreeList<Object>(arg0);
      boolean addAll = treeList.addAll((Collection<?>) arg0);
      assertEquals(2, treeList.size());
      assertTrue(addAll);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToArrayReturningEmptyArray() throws Throwable  {
      // Given an empty tree list
      TreeList<Integer> treeList = new TreeList<>();
      
      // When we call the toArray method on the list
      Object[] array = treeList.toArray();
      
      // Then the resulting array should be empty
      assertEquals(0, array.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testContainsReturningFalse() throws Throwable  {
      // Create a new LinkedList and a TreeList with the same argument
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      TreeList<Object> treeList = new TreeList<Object>(arg0);
      
      // Assert that the TreeList does not contain null
      boolean contains = treeList.contains((Object) null);
      assertFalse(contains);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesTreeListTakingCollection3() throws Throwable  {
      // Given: we have a LinkedList<Integer> with one element and a TreeList<Integer> that is initialized with the LinkedList
      LinkedList<Integer> arg1 = new LinkedList<>();
      Integer arg0 = new Integer(0);
      arg1.add(arg0);
      TreeList<Integer> treeList = new TreeList<>(arg1);
      
      // When: we add all elements of the LinkedList to the TreeList at index 0 twice
      treeList.addAll(0, (Collection<? extends Integer>) arg1);
      treeList.addAll(0, (Collection<? extends Integer>) arg1);
      
      // Then: the size of the TreeList should be 3
      assertEquals(3, treeList.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPreviousIndex() throws Throwable  {
      // No Comments were added
      TreeList<Object> arg0 = new TreeList<Object>();
      TreeList.TreeListIterator<Object> treeList_TreeListIterator = new TreeList.TreeListIterator<Object>(arg0, (-1));
      int previousIndex = treeList_TreeListIterator.previousIndex();
      assertEquals((-2), previousIndex);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAdd() throws Throwable  {
      LinkedList<Integer> arg1 = new LinkedList<Integer>(); // Create an empty linked list as the argument for the TreeList constructor
      TreeList<Object> treeList = new TreeList<Object>(arg1); // Create a new instance of TreeList using the linked list as an argument
      treeList.add(0, (Object) arg1); // Add the linked list to the TreeList at index 0 as an Object
      assertEquals(1, treeList.size()); // Assert that the size of the TreeList is equal to 1, which means the linked list was added successfully
      
      treeList.remove(0); // Remove the element at index 0 from the TreeList
      assertEquals(0, treeList.size()); // Assert that the size of the TreeList is equal to 0, which means the element was removed successfully
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClear() throws Throwable  {
      // No Comments were added
      LinkedList<Object> arg0 = new LinkedList<Object>();
      TreeList<Object> treeList = new TreeList<Object>(arg0);
      treeList.clear();
      assertEquals(0, treeList.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testListIteratorTakingNoArgumentsReturningListIteratorWhereHasNextIsFalse() throws Throwable  {
      LinkedList<Integer> arg0 = new LinkedList<Integer>();
      TreeList<Object> treeList = new TreeList<Object>(arg0);
      ListIterator<Object> listIterator = treeList.listIterator();
      
      // Assert that the iterator does not have a next element
      assertFalse(listIterator.hasNext());
      
      // Assert that the iterator does not have a previous element
      assertFalse(listIterator.hasPrevious());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIterator() throws Throwable  {
      // rollbacked to evosuite
      TreeList<Integer> treeList = new TreeList<Integer>();
      treeList.iterator();
      assertEquals(0, treeList.size());
  }
}
