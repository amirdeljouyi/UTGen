/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 18:04:55 GMT 2024
 */

package org.znerd.xmlenc;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import org.znerd.xmlenc.XMLEncoder;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class XMLEncoder_ESTest extends XMLEncoder_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking5ArgumentsThrowsRuntimeExceptionAndCreatesXMLEncoder0() throws Throwable  {
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      StringWriter arg0 = new StringWriter();
      char[] arg1 = new char[6];
      arg1[0] = 'P';
      arg1[1] = 'd';
      arg1[2] = '>';
      try {
      xMLEncoder.text((Writer) arg0, arg1, 0, 13, false);
      fail("Expecting exception: RuntimeException");
      } catch(RuntimeException e) {
      // The character 0x0 is not valid.
      verifyException("org.znerd.xmlenc.XMLEncoder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking5ArgumentsThrowsRuntimeExceptionAndCreatesXMLEncoder1() throws Throwable  {
      // Given
      XMLEncoder encoder = new XMLEncoder("UTF-16");
      StringWriter output = new StringWriter();
      char[] input = new char[3];
      input[0] = '&';
      
      // When
      try {
      encoder.text(output, input, 0, 112, false);
      fail("Expected exception: RuntimeException");
      } catch (RuntimeException e) {
      throw e;}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking5ArgumentsThrowsRuntimeExceptionAndGetEncoder0() throws Throwable  {
      // Given: A string containing a character that is not valid according to the encoding scheme.
      String invalidChar = "l6=";
      
      // When: Encoding the string using the UTF-16 encoding scheme.
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      StringWriter output = new StringWriter();
      char[] inputChars = new char[5];
      inputChars[0] = 'l';
      inputChars[1] = '6';
      inputChars[2] = '=';
      try {
      encoder.text((Writer) output, inputChars, 0, 1227, true);
      fail("Expecting exception: RuntimeException");
      } catch(RuntimeException e) {
      // Then: The encoder throws a runtime exception when encountering the invalid character.
      verifyException("org.znerd.xmlenc.XMLEncoder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking5ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndGetEncoder() throws Throwable  {
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      StringWriter arg0 = new StringWriter();
      char[] arg1 = new char[3];
      arg1[0] = '/';
      arg1[1] = '/';
      arg1[2] = ' ';
      try {
      encoder.text((Writer) arg0, arg1, 0, 53, true);
      fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
      // Expected exception
      verifyException("org.znerd.xmlenc.XMLEncoder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking5ArgumentsThrowsIndexOutOfBoundsException() throws Throwable  {
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      StringWriter arg0 = new StringWriter();
      char[] arg1 = new char[8];
      
      // Given: we have an XMLEncoder instance and a StringWriter object,
      //        with a char array of length 8 and negative indexes.
      
      try {
      xMLEncoder.text((Writer) arg0, arg1, -171, -171, true);
      
      // When: we call the text method with the StringWriter,
      //       char array, negative indexes, and true as parameters.
      
      fail("Expecting exception: IndexOutOfBoundsException");
      } catch(IndexOutOfBoundsException e) {
      // Then: we expect an IndexOutOfBoundsException to be thrown.
      
      verifyException("java.io.StringWriter", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoder0() throws Throwable  {
      // Create a new instance of the XMLEncoder class with the UTF-8 encoding
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-8");
      
      // Verify that the encoding is set to UTF-8
      assertEquals("UTF-8", xMLEncoder.getEncoding());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWhitespaceTaking4ArgumentsThrowsIndexOutOfBoundsException() throws Throwable  {
      // Given
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      StringWriter arg0 = new StringWriter();
      char[] arg1 = new char[4];
      
      // When
      try {
      xMLEncoder.whitespace((Writer) arg0, arg1, 2565, 2565);
      } catch (IndexOutOfBoundsException e) {
      // Then
      assertEquals("Expecting exception: IndexOutOfBoundsException", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndAttributeAndAttributeWithTrue() throws Throwable  {
      // Create a new XMLEncoder with a default encoding of ISO-8859-1
      XMLEncoder xMLEncoder = new XMLEncoder("ISO-8859-1");
      
      // Create a new StringWriter to store the encoded data
      StringWriter arg0 = new StringWriter();
      
      // Call the attribute method on the XMLEncoder instance with the given arguments
      xMLEncoder.attribute(arg0, "ISO-8859-1", "ISO-8859-1", '\'', true);
      
      // Assert that the output of the attribute method is as expected
      assertEquals(" ISO-8859-1='ISO-8859-1'", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndCallsAttribute0() throws Throwable  {
      // Create an XML encoder and a string writer to write the encoded data
      XMLEncoder xMLEncoder = new XMLEncoder("ISO-8859-5V> =I[&JV+<^%QPOT");
      StringWriter arg0 = new StringWriter();
      
      // Encode the attribute with a single quote and no escaping of special characters
      xMLEncoder.attribute(arg0, "ISO-8859-5V> =I[&JV+<^%QPOT", "ISO-8859-5V> =I[&JV+<^%QPOT", '\'', false);
      
      // Check that the encoded attribute matches the expected result
      assertEquals("ISO-8859-5V> =I[&JV+<^%QPOT='ISO-8859-5V&gt; =I[&JV+&lt;^%QPOT'", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndCallsAttribute1() throws Throwable  {
      // No Comments were added
      XMLEncoder xMLEncoder = new XMLEncoder("ISO-8859-G.7FMI{U%MJPP\"({AZ");
      StringWriter arg0 = new StringWriter();
      xMLEncoder.attribute(arg0, "ISO-8859-G.7FMI{U%MJPP\"({AZ", "ISO-8859-G.7FMI{U%MJPP\"({AZ", '\"', false);
      assertEquals(" ISO-8859-G.7FMI{U%MJPP\"({AZ=\"ISO-8859-G.7FMI{U%MJPP&quot;({AZ\"", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAttributeAndGetEncoder() throws Throwable  {
      // No Comments were added
      XMLEncoder encoder = XMLEncoder.getEncoder("ISO-8859-5V> =I[&JV+<^%QPOT");
      StringWriter arg0 = new StringWriter();
      encoder.attribute(arg0, "ISO-8859-5V> =I[&JV+<^%QPOT", "ISO-8859-5V> =I[&JV+<^%QPOT", '\'', true);
      assertEquals(" ISO-8859-5V> =I[&JV+<^%QPOT='ISO-8859-5V&gt; =I[&amp;JV+&lt;^%QPOT'", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndCallsAttribute2() throws Throwable  {
      // rollbacked to evosuite
      StringWriter arg0 = new StringWriter();
      XMLEncoder xMLEncoder = new XMLEncoder("ISO-8859-' (0X");
      xMLEncoder.attribute(arg0, "ISO-8859-' (0X", "ISO-8859-' (0X", '\"', false);
      assertEquals(" ISO-8859-' (0X=\"ISO-8859-' (0X\"", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAttributeThrowsIllegalArgumentException() throws Throwable  {
      // Test that XMLEncoder throws an IllegalArgumentException when trying to encode a null writer
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      
      try {
      // This call should throw an IllegalArgumentException because the writer is null
      encoder.attribute((Writer) null, "UTF-16", "UTF-16", '>', false);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the correct exception was thrown
      verifyException("org.znerd.xmlenc.XMLEncoder", e);
      
      // Check that the message of the exception is accurate
      assertEquals("Character 0x3e ('>') is not a valid quotation mark.", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetEncoderAndTextTaking11And1AndTextTaking11And1WithOtherChar0() throws Throwable  {
      // Given: A StringWriter and an XMLEncoder with UTF-16 encoding
      StringWriter arg0 = new StringWriter();
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      
      // When: The text method is called on the encoder with a greater than symbol and false as arguments
      encoder.text((Writer) arg0, '>', false);
      
      // Then: The output string should be the encoded form of the greater than symbol
      assertEquals("&gt;", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetEncoderAndTextTaking11And1AndTextTaking11And1WithOtherChar1() throws Throwable  {
      // Given a XMLEncoder object and a StringWriter instance
      XMLEncoder encoder = XMLEncoder.getEncoder("ISO-8859-DAAE+=;T++{");
      StringWriter arg0 = new StringWriter();
      
      // When the "text" method is called with the Writer and false as arguments
      encoder.text((Writer) arg0, '<', false);
      
      // Then the output string in the Writer should be equal to "&lt;"
      assertEquals("&lt;", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetEncoderAndTextTaking11And1AndTextTaking11And1WithOtherChar2() throws Throwable  {
      // Given a string writer and an XML encoder with UTF-16 encoding
      StringWriter arg0 = new StringWriter();
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      
      // When we call the text method with a tab character as input
      encoder.text((Writer) arg0, '\t', false);
      
      // Then we expect the output to be a string containing a single tab character
      assertEquals("\t", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndTextTaking11And1AndTextTaking11And1WithTrue0() throws Throwable  {
      // Given a XMLEncoder instance with the ISO-8859-CP character encoding
      XMLEncoder xMLEncoder = new XMLEncoder("ISO-8859-CP");
      
      // And a StringWriter object to write the encoded text
      StringWriter arg0 = new StringWriter();
      
      // When we call the text method with the Writer and '=' as input, and true for the escape argument
      xMLEncoder.text((Writer) arg0, '=', true);
      
      // Then the encoded text should be "="
      assertEquals("=", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndTextTaking11And1AndTextTaking11And1WithFalse0() throws Throwable  {
      // Given a XMLEncoder with UTF-16 encoding
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      
      // And a StringWriter to write the encoded text
      StringWriter arg0 = new StringWriter();
      
      // When we call the "text" method with a writer, line separator, and false encoding
      xMLEncoder.text((Writer) arg0, '\r', false);
      
      // Then the resulting string should be "\r"
      assertEquals("\r", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndTextTaking11And1AndTextTaking11And1WithFalse1() throws Throwable  {
      // Create an XMLEncoder instance with UTF-16 encoding
      XMLEncoder xmlEncoder = new XMLEncoder("UTF-16");
      
      // Create a StringWriter to hold the encoded text
      StringWriter encodedText = new StringWriter();
      
      // Encode a newline character as XML text
      xmlEncoder.text(encodedText, '\n', false);
      
      // Assert that the encoded text is equal to the expected value
      assertEquals("&newline;", encodedText.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetEncoderAndTextTaking11And1AndTextTaking11And1WithTrue() throws Throwable  {
      // Given
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      StringWriter arg0 = new StringWriter();
      
      // When
      encoder.text((Writer) arg0, '\uFFFF', true);
      
      // Then
      assertEquals("\uFFFF", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndTextTaking11And1AndTextTaking11And1WithFalse2() throws Throwable  {
      // Create an XMLEncoder instance with a UTF-16 encoding scheme
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      
      // Create a StringWriter object to hold the encoded text
      StringWriter arg0 = new StringWriter();
      
      // Use the XMLEncoder instance to encode an ampersand character (&)
      xMLEncoder.text((Writer) arg0, '&', false);
      
      // Assert that the encoded text is equal to "&amp;"
      assertEquals("&amp;", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndTextTaking11And1AndTextTaking11And1WithTrue1() throws Throwable  {
      // Create a new XMLEncoder with the specified encoding
      XMLEncoder xMLEncoder = new XMLEncoder("ISO-8859-DAAEI=;T++{");
      
      // Create a new StringWriter to store the encoded data
      StringWriter encodedData = new StringWriter();
      
      // Encode the specified character using the XMLEncoder
      xMLEncoder.text(encodedData, '&', true);
      
      // Assert that the encoded data is equal to the expected value
      assertEquals("&", encodedData.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndTextTaking11And1AndTextTaking11And1WithTrue2() throws Throwable  {
      // Arrange
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      StringWriter arg0 = new StringWriter();
      
      // Act
      xMLEncoder.text((Writer) arg0, '\"', true);
      
      // Assert
      assertEquals("\"", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking11And1ThrowsRuntimeException() throws Throwable  {
      // No Comments were added
      StringWriter arg0 = new StringWriter();
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      try { 
        xMLEncoder.text((Writer) arg0, '\u001C', true);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // The character 0x1c is not valid.
         //
         verifyException("org.znerd.xmlenc.XMLEncoder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetEncoderAndTextTaking11And1() throws Throwable  {
      // rollbacked to evosuite
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      StringWriter arg0 = new StringWriter();
      encoder.text((Writer) arg0, 'D', false);
      assertEquals("D", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetEncoderAndTextTaking11And1AndTextTaking11And1WithOtherChar3() throws Throwable  {
      // Create an instance of the encoder with a specific encoding
      XMLEncoder encoder = XMLEncoder.getEncoder("ISO-8859-DAAEI=;T++{");
      
      // Use a StringWriter to capture the output of the encode() method
      StringWriter arg0 = new StringWriter();
      
      // Encode a specific character using the encoder
      encoder.text((Writer) arg0, '\uFFFA', false);
      
      // Assert that the encoded value is equal to a specific string
      assertEquals("&#65530;", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking11And1ThrowsNullPointerException() throws Throwable  {
      // No Comments were added
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      // Undeclared exception!
      try { 
        encoder.text((Writer) null, '(', true);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.znerd.xmlenc.XMLEncoder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking2ArgumentsThrowsRuntimeException() throws Throwable  {
      // Create an instance of the XMLEncoder with a UTF-16 encoding
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      
      // Create a StringWriter object to write the encoded data
      StringWriter arg0 = new StringWriter();
      
      try {
      // Try to encode the character 0x1f (a control character) using the XMLEncoder
      xMLEncoder.text((Writer) arg0, '\u001F');
      
      // Fail if no exception was thrown
      fail("Expecting exception: RuntimeException");
      } catch(RuntimeException e) {
      // Verify that the expected exception is thrown with a message indicating the invalid character
      verifyException("org.znerd.xmlenc.XMLEncoder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking2ArgumentsThrowsNullPointerExceptionAndTextTaking2ArgumentsWithOtherChar0() throws Throwable  {
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      
      // Try to encode a null writer, which should throw a NullPointerException
      try {
      encoder.text((Writer) null, '>');
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      verifyException("org.znerd.xmlenc.XMLEncoder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndCallsTextTaking2Arguments0() throws Throwable  {
      // Given a string that needs to be encoded as XML
      String input = "<some>text</some>";
      
      // When encoding the string using an XMLEncoder
      XMLEncoder xMLEncoder = new XMLEncoder(input);
      StringWriter arg0 = new StringWriter();
      xMLEncoder.text((Writer) arg0, '<');
      
      // Then the resulting string should be encoded as XML
      assertEquals("&lt;some>text&lt;/some>", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetEncoderAndTextTaking2Arguments0() throws Throwable  {
      // Given a XML encoder object
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      
      // When we encode a character using the text method
      StringWriter arg0 = new StringWriter();
      encoder.text((Writer) arg0, '=');
      
      // Then the encoded string should be equal to "="
      assertEquals("=", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndCallsTextTaking2Arguments1() throws Throwable  {
      // Given: A new XMLEncoder instance with UTF-16 encoding
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      
      // And: A StringWriter to hold the encoded text
      StringWriter arg0 = new StringWriter();
      
      // When: The text method is called with a Writer and a newline character as arguments
      xMLEncoder.text((Writer) arg0, '\r');
      
      // Then: The resulting string should be a newline character in UTF-16 encoding
      assertEquals("\r", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndCallsTextTaking2Arguments2() throws Throwable  {
      // Given: A new XMLEncoder instance with UTF-16 encoding
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      
      // When: Text is encoded using the XMLEncoder instance
      StringWriter arg0 = new StringWriter();
      xMLEncoder.text((Writer) arg0, '\n');
      
      // Then: The encoded text should be a newline character (\n)
      assertEquals("\n", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndCallsTextTaking2Arguments3() throws Throwable  {
      // Given: Set up an instance of the XMLEncoder class with a UTF-16 encoding
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      
      // When: Call the text method with a StringWriter and a special character
      StringWriter output = new StringWriter();
      xMLEncoder.text((Writer) output, '\uFFFA');
      
      // Then: Verify that the correct string is written to the output stream
      assertEquals("\uFFFA", output.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndCallsTextTaking2Arguments4() throws Throwable  {
      // Given
      XMLEncoder xmlEncoder = new XMLEncoder("ISO-8859-DAAEI=;T++{");
      StringWriter output = new StringWriter();
      
      // When
      xmlEncoder.text((Writer) output, '&');
      
      // Then
      assertEquals("&", output.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetEncoderAndTextTaking2Arguments1() throws Throwable  {
      // Given a UTF-16 encoding
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      
      // When the text method is called with a tab character
      StringWriter arg0 = new StringWriter();
      encoder.text((Writer) arg0, '\t');
      
      // Then the result is a string containing a tab character
      assertEquals("\t", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking2ArgumentsWithDigit() throws Throwable  {
      // Given the XMLEncoder class is initialized with a UTF-16 encoding
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      
      // When we encode a character value of '9' using the XMLEncoder
      StringWriter arg0 = new StringWriter();
      xMLEncoder.text((Writer) arg0, '9');
      
      // Then the encoded string should match the expected value "9"
      assertEquals("9", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoderAndCallsTextTaking2Arguments5() throws Throwable  {
      // Given a XMLEncoder instance
      XMLEncoder xMLEncoder = new XMLEncoder("ISO-8859-DAAEI=;T++{");
      
      // When we encode a string using the XMLEncoder instance
      StringWriter arg0 = new StringWriter();
      xMLEncoder.text((Writer) arg0, '\uFFFC');
      
      // Then the resulting string should be "&#65532;"
      assertEquals("&#65532;", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking2ArgumentsThrowsNullPointerException() throws Throwable  {
      // Given: A valid XML encoder instance
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      
      // When: The text method is called with a null writer and an invalid character
      try {
      encoder.text((Writer) null, 'H');
      } catch(NullPointerException e) {
      // Then: An exception should be thrown
      verifyException("org.znerd.xmlenc.XMLEncoder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking2ArgumentsThrowsNullPointerExceptionAndTextTaking2ArgumentsWithOtherChar1() throws Throwable  {
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      try {
      encoder.text(null, '#');
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      verifyException("org.znerd.xmlenc.XMLEncoder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking5ArgumentsWithPositive() throws Throwable  {
      StringWriter output = new StringWriter();
      // Create an XMLEncoder instance with the given encoding
      XMLEncoder encoder = XMLEncoder.getEncoder("ISO-8859-DAAEI=;T++{");
      
      // Prepare a char array with the characters to be encoded
      char[] input = new char[6];
      input[4] = '\t';
      
      try {
      // Encode the given characters into XML format
      encoder.text(output, input, 4, 62, true);
      fail("Expecting exception: RuntimeException");
      } catch (RuntimeException e) {
      // Verify that the expected exception is thrown
      verifyException("org.znerd.xmlenc.XMLEncoder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking5ArgumentsThrowsArrayIndexOutOfBoundsException0() throws Throwable  {
      // Tests that the XMLEncoder throws an ArrayIndexOutOfBoundsException when encoding a string with an invalid character
      StringWriter arg0 = new StringWriter();
      char[] arg1 = new char[6];
      arg1[0] = 'P';
      arg1[1] = 'P';
      arg1[2] = 'P';
      arg1[3] = '9';
      arg1[4] = '<';
      arg1[5] = '\r';
      try {
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      xMLEncoder.text((Writer) arg0, arg1, 0, 13, false);
      fail("Expecting exception: ArrayIndexOutOfBoundsException");
      } catch(ArrayIndexOutOfBoundsException e) {
      verifyException("org.znerd.xmlenc.XMLEncoder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking5ArgumentsThrowsArrayIndexOutOfBoundsExceptionAndTextTaking5ArgumentsWithTrue() throws Throwable  {
      // Given: A StringWriter and a char array with one element
      StringWriter arg0 = new StringWriter();
      char[] arg1 = new char[1];
      arg1[0] = '\n';
      
      // When: Encoding the character as text using XMLEncoder
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      xMLEncoder.text((Writer) arg0, arg1, 0, (int) '\n', true);
      
      // Then: Expecting an ArrayIndexOutOfBoundsException to be thrown
      fail("Expecting exception: ArrayIndexOutOfBoundsException");
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking5ArgumentsThrowsArrayIndexOutOfBoundsException1() throws Throwable  {
      // Given: an XMLEncoder instance with a StringWriter and a char array containing a unicode character that is out of bounds
      XMLEncoder xMLEncoder = new XMLEncoder("UTF-16");
      StringWriter arg0 = new StringWriter();
      char[] arg1 = new char[1];
      arg1[0] = '\uFFFD';
      
      // When: invoking the text method with an invalid index value (negative)
      try {
      xMLEncoder.text((Writer) arg0, arg1, 0, (int) '\uFFFD', false);
      fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
      // Then: verify that the expected exception is thrown
      verifyException("org.znerd.xmlenc.XMLEncoder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking5ArgumentsThrowsRuntimeExceptionAndGetEncoder1() throws Throwable  {
      // Given: An XML encoder and an invalid character (0x0)
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      char[] arg1 = new char[6];
      arg1[0] = '&';
      
      // When: We try to encode the invalid character using the XML encoder
      StringWriter arg0 = new StringWriter();
      try {
      encoder.text((Writer) arg0, arg1, 0, (int) '&', true);
      } catch(RuntimeException e) {
      // Then: We expect an exception to be thrown
      verifyException("org.znerd.xmlenc.XMLEncoder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking5ArgumentsThrowsRuntimeExceptionAndGetEncoder2() throws Throwable  {
      // Given a XMLEncoder instance with ISO-8859-UF-6 encoding
      XMLEncoder encoder = XMLEncoder.getEncoder("ISO-8859-UF-6");
      
      // And a StringWriter to hold the encoded output
      StringWriter output = new StringWriter();
      
      // When we attempt to encode an invalid character (0x0)
      char[] input = new char[1];
      input[0] = '\uFFFD'; // The "replacement character" (U+FFFD)
      try {
      encoder.text(output, input, 0, (int) '\uFFFD', true);
      fail("Expecting exception: RuntimeException");
      } catch(RuntimeException e) {
      // The expected exception was thrown
      verifyException("org.znerd.xmlenc.XMLEncoder", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateXMLEncoderThrowsUnsupportedEncodingException() throws Throwable  {
      // rollbacked to evosuite
      XMLEncoder xMLEncoder = null;
      try {
        xMLEncoder = new XMLEncoder("output.xml");
        fail("Expecting exception: UnsupportedEncodingException");
      
      } catch(Throwable e) {
         //
         // output.xml
         //
         verifyException("org.znerd.xmlenc.XMLEncoder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoder1() throws Throwable  {
      // Given a XMLEncoder instance with the encoding "ASCII"
      XMLEncoder xMLEncoder = new XMLEncoder("ASCII");
      
      // When the getEncoding method is called
      String actualEncoding = xMLEncoder.getEncoding();
      
      // Then the returned encoding should be "ASCII"
      assertEquals("ASCII", actualEncoding);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXMLEncoder2() throws Throwable  {
      // rollbacked to evosuite
      XMLEncoder xMLEncoder = new XMLEncoder("US-ASCII");
      assertEquals("US-ASCII", xMLEncoder.getEncoding());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateXMLEncoderThrowsIllegalArgumentException() throws Throwable  {
      // No Comments were added
      XMLEncoder xMLEncoder = null;
      try {
        xMLEncoder = new XMLEncoder((String) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // encoding == null
         //
         verifyException("org.znerd.xmlenc.XMLEncoder", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTextTaking11And1() throws Throwable  {
      // No Comments were added
      XMLEncoder xMLEncoder = new XMLEncoder("ISO-8859-5V> =I[&JV+<^%QPOT");
      StringWriter arg0 = new StringWriter();
      xMLEncoder.text((Writer) arg0, "ISO-8859-5V> =I[&JV+<^%QPOT", false);
      assertEquals("ISO-8859-5V&gt; =I[&JV+&lt;^%QPOT", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetEncoding() throws Throwable  {
      // Given: The XMLEncoder class is being used to encode a string in UTF-8 format
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-8");
      String encoding = encoder.getEncoding();
      
      // When: The getEncoding method is called on the XMLEncoder instance
      String actualEncoding = encoder.getEncoding();
      
      // Then: The correct encoding (UTF-8) should be returned
      assertEquals("UTF-8", actualEncoding);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDeclaration() throws Throwable  {
      // Given: An XML encoder is created with a specific encoding.
      XMLEncoder encoder = XMLEncoder.getEncoder("ISO-8859-1");
      
      // When: The XML declaration is written to a string writer.
      StringWriter arg0 = new StringWriter();
      encoder.declaration(arg0);
      
      // Then: The resulting string matches the expected declaration.
      assertEquals("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWhitespaceTaking2Arguments() throws Throwable  {
      XMLEncoder encoder = XMLEncoder.getEncoder("UTF-16");
      StringWriter output = new StringWriter();
      encoder.whitespace(output, "");
      assertEquals("UTF-16", encoder.getEncoding()); // Assert that the encoding used by the encoder is "UTF-16"
  }
}
