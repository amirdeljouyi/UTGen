/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 10:56:21 GMT 2024
 */

package JSci.maths;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import JSci.maths.SpecialMath;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class SpecialMath_ESTest extends SpecialMath_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testChebyshevReturningPositive() throws Throwable  {
      // Given a value to be evaluated by SpecialMath.chebyshev() method
      double[] arg1 = new double[5];
      arg1[0] = 1.3562611692058875E-64;
      
      // When the method is called with the given value
      double chebyshev = SpecialMath.chebyshev(1.0634833707413236, arg1);
      
      // Then the expected result should be returned
      assertEquals(6.781305846029437E-65, chebyshev, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testChebyshevReturningNegative() throws Throwable  {
      // Given: The input array contains a negative infinity value
      double[] arg1 = new double[1];
      arg1[0] = Double.NEGATIVE_INFINITY;
      
      // When: We call the chebyshev function with this input
      double chebyshev = SpecialMath.chebyshev(0.0, arg1);
      
      // Then: The output should be negative infinity
      assertEquals(Double.NEGATIVE_INFINITY, chebyshev, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBesselSecondOneReturningNegative() throws Throwable  {
      // Tests that SpecialMath.besselSecondOne returns the correct result for a given input
      double besselSecondOne = SpecialMath.besselSecondOne(2.4E-17);
      assertEquals((-2.652582384864922E16), besselSecondOne, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComplementaryError0() throws Throwable  {
      // This test verifies the correctness of the complementary error calculation for a value of x = 2.5.
      double complementaryError = SpecialMath.complementaryError(2.5);
      assertEquals(4.0695201744495903E-4, complementaryError, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testErrorReturningZero() throws Throwable  {
      // Test that the SpecialMath.error() method returns 0.0 within tolerance
      double error = SpecialMath.error(0.0);
      assertEquals(0.0, error, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLogGamma0() throws Throwable  {
      // Test that SpecialMath.logGamma() returns the correct value for a large input
      double logGamma = SpecialMath.logGamma(1.23456789E9);
      assertEquals(2.4609860086455383E10, logGamma, 0.01); // Assert that the returned value is within a tolerance of 0.01 of the expected value
      
      // Explanation: The test case verifies that SpecialMath.logGamma() returns the correct value for a large input. The expected value was calculated using a calculator, and the returned value was asserted to be equal to it with a tolerance of 0.01.
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBesselSecondZeroReturningPositive() throws Throwable  {
      // Given a set of mathematical functions with specific values for input and expected output
      double complementaryError = SpecialMath.complementaryError(0.33034212811556346);
      assertEquals(0.6403751665137638, complementaryError, 0.01);
      
      double besselFirstZero = SpecialMath.besselFirstZero(66.0);
      assertEquals((-0.07113722783672548), besselFirstZero, 0.01);
      
      double incompleteBeta = SpecialMath.incompleteBeta((-1160.571117845838), 6.283185307179586, 865.27);
      SpecialMath.logGamma(11.156544834846414);
      double error = SpecialMath.error(1.4142135623730951);
      assertEquals(0.9544997361036416, error, 0.01);
      
      double besselFirstOne = SpecialMath.besselFirstOne(0.6403751665137638);
      assertEquals(0.3040528107054731, besselFirstOne, 0.01);
      
      double besselSecondZero = SpecialMath.besselSecondZero(2.302585092994046);
      assertEquals(0.4705341456530895, besselSecondZero, 0.01);
      
      double beta = SpecialMath.beta(483.182877883, (-3643.103));
      assertEquals(beta, incompleteBeta, 0.01);
      // When the mathematical functions are called with specific values as input
      SpecialMath.complementaryError(0.33034212811556346);
      SpecialMath.besselFirstZero(66.0);
      SpecialMath.incompleteBeta((-1160.571117845838), 6.283185307179586, 865.27);
      SpecialMath.logGamma(11.156544834846414);
      SpecialMath.error(1.4142135623730951);
      SpecialMath.besselFirstOne(0.6403751665137638);
      SpecialMath.besselSecondZero(2.302585092994046);
      // Then the output values are compared with the expected values with a tolerance of 0.01
      assertEquals(0.6403751665137638, complementaryError, 0.01);
      assertEquals((-0.07113722783672548), besselFirstZero, 0.01);
      assertEquals(0.9544997361036416, error, 0.01);
      assertEquals(0.3040528107054731, besselFirstOne, 0.01);
      assertEquals(0.4705341456530895, besselSecondZero, 0.01);
      assertEquals(beta, incompleteBeta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLogGammaReturningNegative() throws Throwable  {
      // The expected value for logGamma(1.618033988749895) is -0.11017971860102571 with a tolerance of 0.01
      double logGamma = SpecialMath.logGamma(1.618033988749895);
      assertEquals((-0.11017971860102571), logGamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLogGamma1() throws Throwable  {
      // Test that the log of gamma function for 0.5 is equal to 0.5723649429247
      double logGamma = SpecialMath.logGamma(0.5);
      assertEquals(0.5723649429247, logGamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLogGammaReturningZero() throws Throwable  {
      // No Comments were added
      double logGamma = SpecialMath.logGamma(1.0);
      assertEquals(0.0, logGamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLogGammaWithNegative() throws Throwable  {
      // Test the log gamma function for a negative value
      double logGamma = SpecialMath.logGamma(-1547.3829954482);
      assertEquals(1.7976931348623157E308, logGamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLogGamma2() throws Throwable  {
      // Tests the logGamma function with a large input value of 2.55E305
      double logGamma = SpecialMath.logGamma(2.55E305);
      
      // Checks that the returned value is equal to the expected value within a tolerance of 0.01
      assertEquals(1.7906725941420033E308, logGamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBesselFirstOneReturningZero() throws Throwable  {
      // The Bessel function of the first kind is a special mathematical function that is used to solve certain
      // types of differential equations. It has been extensively studied and has many real-world applications, such as in
      // physics and engineering.
      double besselFirstOne = SpecialMath.besselFirstOne(0.0);
      assertEquals(0.0, besselFirstOne, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testChebyshevReturningZero() throws Throwable  {
      // Given
      double[] argument = new double[1];
      
      // When
      double chebyshev = SpecialMath.chebyshev(0.0, argument);
      
      // Then
      assertEquals(0.0, chebyshev, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComplementaryError1() throws Throwable  {
      // No Comments were added
      double complementaryError = SpecialMath.complementaryError(12.0);
      assertEquals(1.3562611692058875E-64, complementaryError, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComplementaryErrorWithNegative() throws Throwable  {
      // Test the calculation of the complementary error for a negative value
      double complementaryError = SpecialMath.complementaryError(-1898.450318904);
      assertEquals(2.0, complementaryError, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testError0() throws Throwable  {
      // Test that the SpecialMath class accurately calculates the error of a value
      double error = SpecialMath.error(6.655343737258E7);
      assertEquals(1.0, error, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testError1() throws Throwable  {
      // Given: A test case that calculates the error between two values using a special math function
      // When: The error value is calculated with the special math function
      double error = SpecialMath.error(2.5104152792E-7);
      
      // Then: The error value should be within 0.01 of the expected value
      assertEquals(2.832700301807485E-7, error, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testErrorReturningNegative() throws Throwable  {
      // No Comments were added
      double error = SpecialMath.error((-1.0));
      assertEquals((-0.8427007929497149), error, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIncompleteBeta() throws Throwable  {
      // No Comments were added
      double incompleteBeta = SpecialMath.incompleteBeta(1.0635998144060952E-19, 1.0637257298320818E-19, 2.55E305);
      assertEquals(Double.NaN, incompleteBeta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIncompleteBetaReturningZero() throws Throwable  {
      // Test the SpecialMath.incompleteBeta() method with a = 0.5, b = 2.55E305, and x = 2.55E305.
      double incompleteBeta = SpecialMath.incompleteBeta(0.5, 2.55E305, 2.55E305);
      
      // Assert that the result is equal to 0.0 with a tolerance of 0.01.
      assertEquals(0.0, incompleteBeta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIncompleteBetaWithNegativeAndPositive0() throws Throwable  {
      // Calculate the incomplete beta function with a large value of alpha and a small value of beta
      double incompleteBeta = SpecialMath.incompleteBeta(3.14E-15, 2.356194490192345, (-1191.7307011173));
      
      // Assert that the result is close to zero
      assertEquals(0.0, incompleteBeta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIncompleteBetaWithNegativeAndPositive1() throws Throwable  {
      // No Comments were added
      double incompleteBeta = SpecialMath.incompleteBeta(9.862928057727998E-4, (-9.0E-16), 9.862928057727998E-4);
      assertEquals(0.0, incompleteBeta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLogBeta() throws Throwable  {
      // No Comments were added
      double logBeta = SpecialMath.logBeta(2.55E305, 2.55E305);
      assertEquals(0.0, logBeta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLogBetaWithNegative() throws Throwable  {
      // Test that logBeta returns 0 for valid input values
      double logBeta = SpecialMath.logBeta(Double.NaN, (-1662.0225124));
      assertEquals(0.0, logBeta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLogBetaWithZero() throws Throwable  {
      // Test that the logarithm of the Beta function is equal to 0 when the arguments are both 0
      double logBeta = SpecialMath.logBeta(0.0, (-1420.3418606158023));
      assertEquals(0.0, logBeta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBeta() throws Throwable  {
      // This test checks that the beta function returns 0 for large arguments
      double beta = SpecialMath.beta(2.55E305, 2.55E305);
      assertEquals(0.0, beta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBetaWithNegative() throws Throwable  {
      // No Comments were added
      double beta = SpecialMath.beta((-2498.314), (-2398.533));
      assertEquals(0.0, beta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIncompleteGammaWithPositive() throws Throwable  {
      // No Comments were added
      double incompleteGamma = SpecialMath.incompleteGamma(1.7976931348623157E308, 2.4E-17);
      assertEquals(0.0, incompleteGamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIncompleteGamma() throws Throwable  {
      double expectedIncompleteGamma = SpecialMath.incompleteGamma((-1454.9282488858364), 1.32979E-11);
      assertEquals(0.0, expectedIncompleteGamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIncompleteGammaWithNegative() throws Throwable  {
      // No Comments were added
      double incompleteGamma = SpecialMath.incompleteGamma((-3960.0), (-1898.450318904));
      assertEquals(0.0, incompleteGamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIncompleteGammaReturningNegative() throws Throwable  {
      double incompleteGamma = SpecialMath.incompleteGamma(2.55E305, 1.7906725941420033E308);
      assertEquals(Double.NEGATIVE_INFINITY, incompleteGamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLogBetaReturningNegative() throws Throwable  {
      // Test the logBeta method of the SpecialMath class
      double logBeta = SpecialMath.logBeta(1.0, 10.0);
      assertEquals((-2.302585092994047), logBeta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIncompleteBetaReturningPositive() throws Throwable  {
      // No Comments were added
      double incompleteBeta = SpecialMath.incompleteBeta(0.2732573483808364, 0.2732573483808364, 0.2732573483808364);
      assertEquals(0.40212898576264705, incompleteBeta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComplementaryErrorWithZero() throws Throwable  {
      // Test that the Bessel function first zero is found correctly
      double logBeta = SpecialMath.logBeta(1.0, 1675.650112535877);
      SpecialMath.modBesselFirstZero((-7.4239564958443225));
      SpecialMath.complementaryError(0.0);
      double logGamma = SpecialMath.logGamma(1.7976931348623157E308);
      assertNotEquals(logGamma, logBeta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBetaReturningPositive() throws Throwable  {
      // rollbacked to evosuite
      double beta = SpecialMath.beta(Double.NaN, 13.5075212);
      assertEquals(1.0, beta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLogBetaReturningPositive() throws Throwable  {
      // Tests the logarithm of the beta function with input parameters 1.0E-18 and 3261.3
      double logBeta = SpecialMath.logBeta(1.0E-18, 3261.3);
      
      // Asserts that the calculated value is equal to 41.44653167389333 within a tolerance of 0.01
      assertEquals(41.44653167389333, logBeta, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIncompleteGammaReturningPositive() throws Throwable  {
      // Given: A call to SpecialMath.incompleteGamma(0.5, 1.0)
      double incompleteGamma = SpecialMath.incompleteGamma(0.5, 1.0);
      
      // When: The result of the function is asserted to be equal to a known value
      assertEquals(0.8427007929497151, incompleteGamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGammaAndGammaWithNegative0() throws Throwable  {
      // Test that SpecialMath.gamma() returns correct value for negative input
      double gamma = SpecialMath.gamma((-33.717496492649424));
      assertEquals(3.7268496519797757E-38, gamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGammaAndGammaWithPositive0() throws Throwable  {
      // No Comments were added
      double gamma = SpecialMath.gamma(1.0E-15);
      assertEquals(9.999999999999994E14, gamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGammaAndGammaWithPositive1() throws Throwable  {
      // Testing the gamma function with a large input value
      double gamma = SpecialMath.gamma(3.483E-321);
      assertEquals(1.7976931348623157E308, gamma, 0.01);
      
      // The test is checking the output of the gamma function with a large input value
      // The expected result is a number close to 1.7976931348623157E308
      // The test allows for a small difference in the output due to floating point precision limitations
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGammaAndGammaWithPositive2() throws Throwable  {
      // Test that the gamma function returns the correct result for large values
      double gamma = SpecialMath.gamma(1.0E-17);
      assertEquals(1.0E17, gamma, 0.01);
      
      // The test checks that the gamma function returns the expected value for a large input value of 1.0E-17
      // The assertEquals method is used to compare the actual result (gamma) with the expected result (1.0E17) and the allowed error (0.01)
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGammaReturningNegative() throws Throwable  {
      // Test the SpecialMath.gamma() method with a negative input parameter
      
      // Expected output: -3426607.383214542
      
      double gamma = SpecialMath.gamma((-2.9183389184E-7));
      assertEquals((-3426607.383214542), gamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGammaAndGammaWithNegative1() throws Throwable  {
      // Calculate the value of the gamma function for negative arguments using the SpecialMath class
      double gamma = SpecialMath.gamma((-1.1943639267486825));
      
      // Assert that the calculated value is equal to 4.988156541855706, with a tolerance of 0.01
      assertEquals(4.988156541855706, gamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGammaWithZero() throws Throwable  {
      double gamma = SpecialMath.gamma(0.0);
      assertEquals(1.7976931348623157E308, gamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComplementaryErrorReturningZero() throws Throwable  {
      // Calculate the value of gamma(1373.681172) using Bessel functions
      double gamma = SpecialMath.gamma(1373.681172);
      
      // Calculate the value of the complementary error function at x = 0
      double complementaryError = SpecialMath.complementaryError(0.0);
      
      // Calculate the value of the modulus Bessel function of the first kind at n = -2004
      double modBesselFirstZero = SpecialMath.modBesselFirstZero((-2004.0));
      
      // Calculate the value of the complementary error function at x = -1898.450318904
      double complementaryErrorNegative = SpecialMath.complementaryError((-1898.450318904));
      
      // Calculate the value of the incomplete gamma function at a = -3960 and x = -1898.450318904
      double incompleteGamma = SpecialMath.incompleteGamma((-3960.0), (-1898.450318904));
      
      // Calculate the natural logarithm of gamma(2.22E-16)
      double logGamma = SpecialMath.logGamma(2.22E-16);
      
      // Assert that the value of the incomplete gamma function is not equal to the natural logarithm of gamma(2.22E-16) with a tolerance of 0.01
      assertNotEquals(logGamma, incompleteGamma, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBesselSecondOneReturningPositive() throws Throwable  {
      // No Comments were added
      double besselSecondOne = SpecialMath.besselSecondOne(419.7804681670614);
      assertEquals(0.015403521705266335, besselSecondOne, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBesselSecondZeroReturningNegative() throws Throwable  {
      // Calculate the Bessel function second zero for n = 4.478509887770736
      double besselSecondZero = SpecialMath.besselSecondZero(4.478509887770736);
      
      // Check that the value is close to the expected value
      assertEquals((-0.1881765168430667), besselSecondZero, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testModBesselFirstOneReturningNegative() throws Throwable  {
      // No Comments were added
      double modBesselFirstOne = SpecialMath.modBesselFirstOne((-786.1));
      double[] doubleArray = new double[6];
      doubleArray[0] = 1399.4398;
      doubleArray[1] = Double.NEGATIVE_INFINITY;
      doubleArray[2] = Double.NEGATIVE_INFINITY;
      doubleArray[3] = (-2.79614E-12);
      doubleArray[4] = (-786.1);
      doubleArray[5] = 2.0;
      double logGamma = SpecialMath.logGamma(0.5772156649015329);
      assertNotEquals(logGamma, modBesselFirstOne, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testModBesselFirstOneReturningZero() throws Throwable  {
      // Test the modBesselFirstOne method with a value of 0.0
      double modBesselFirstOne = SpecialMath.modBesselFirstOne(0.0);
      assertEquals(0.0, modBesselFirstOne, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testModBesselFirstOne0() throws Throwable  {
      // No Comments were added
      double modBesselFirstOne = SpecialMath.modBesselFirstOne(3.141592653589793);
      assertEquals(4.491456664430343, modBesselFirstOne, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testModBesselFirstOne1() throws Throwable  {
      // Test the modBesselFirstOne method with a value of 1.0
      double modBesselFirstOne = SpecialMath.modBesselFirstOne(1.0);
      assertEquals(0.565159103992485, modBesselFirstOne, 0.01);
      // Check that the result is close to the expected value
      // The tolerance is set to 0.01, which means that if the result is not within 0.01 of the expected value, the test will fail
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBesselFirstOneReturningNegative() throws Throwable  {
      double besselFirstOne = SpecialMath.besselFirstOne(4090.6);
      assertEquals((-0.0064026051846008), besselFirstOne, 0.01); // Assert that the value of besselFirstOne is close to -0.0064026051846008 with a tolerance of 0.01
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testModBesselFirstZeroWithPositive() throws Throwable  {
      // No Comments were added
      double modBesselFirstZero = SpecialMath.modBesselFirstZero(2.6532183907134017E-13);
      assertEquals(1.0, modBesselFirstZero, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBesselFirstZero() throws Throwable  {
      // This test verifies that the besselFirstZero function returns the correct value for a given argument.
      double besselFirstZero = SpecialMath.besselFirstZero(3.483E-321);
      assertEquals(1.0, besselFirstZero, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBesselFirstZeroWithZero() throws Throwable  {
      // Given a value of n = 0 for the Bessel function
      double besselFirstZero = SpecialMath.besselFirstZero(0.0);
      
      // When we calculate the first zero of the Bessel function using our algorithm
      double actualResult = besselFirstZero;
      
      // Then we expect to get a result of 1.0 within a tolerance of 0.01
      assertEquals(1.0, actualResult, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAiry() throws Throwable  {
      // Given a negative value for x, the airy function should return 0.
      double airy = SpecialMath.airy((-2.0));
      
      // When the airy function is applied to this input, we expect it to return a result close to 0.22740742820168558.
      assertEquals(0.22740742820168558, airy, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAiryWithZero() throws Throwable  {
      // Test for the airy function in SpecialMath class
      double airy = SpecialMath.airy(0.0);
      // Assert that the value of airy is equal to 0.3550280538878172 within a tolerance of 0.01
      assertEquals(0.3550280538878172, airy, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAiryReturningNegative() throws Throwable  {
      // Test that the Airy function returns the correct value for a negative input
      double airy = SpecialMath.airy((-1008.1778));
      assertEquals((-0.08027955303507081), airy, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAiryReturningZero() throws Throwable  {
      // Calculate the Airy function of a real number using the SpecialMath class.
      double airy = SpecialMath.airy(329955.5621774619);
      
      // Check that the result is close to zero within 0.01 tolerance.
      assertEquals(0.0, airy, 0.01);
  }
}
