/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 11:11:02 GMT 2024
 */

package JSci.maths;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import JSci.maths.LinearMath;
import JSci.maths.matrices.AbstractComplexSquareMatrix;
import JSci.maths.matrices.AbstractDoubleSquareMatrix;
import JSci.maths.matrices.ComplexDiagonalMatrix;
import JSci.maths.matrices.DoubleFileSquareMatrix;
import JSci.maths.matrices.DoubleSparseSquareMatrix;
import JSci.maths.matrices.DoubleTridiagonalMatrix;
import JSci.maths.polynomials.RealPolynomial;
import JSci.maths.vectors.AbstractComplexVector;
import JSci.maths.vectors.AbstractDoubleVector;
import JSci.maths.vectors.DoubleVector;
import JSci.maths.vectors.IntegerVector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class LinearMath_Original_ESTest extends LinearMath_Original_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEigenSolveHermitianThrowsNullPointerException() throws Throwable  {
      AbstractComplexVector[] arg1 = new AbstractComplexVector[1];
      // Undeclared exception!
      try { 
        LinearMath.eigenSolveHermitian((AbstractComplexSquareMatrix) null, arg1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("JSci.maths.LinearMath", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOrthonormalizeReturningNonEmptyArray() throws Throwable  {
      DoubleVector doubleVector = new DoubleVector(4);
      AbstractDoubleVector[] arg0 = new AbstractDoubleVector[2];
      arg0[0] = (AbstractDoubleVector) doubleVector;
      arg0[1] = (AbstractDoubleVector) doubleVector;
      AbstractDoubleVector[] orthonormalize = LinearMath.orthonormalize(arg0);
      assertFalse(orthonormalize.equals((Object)arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLeastSquaresFitReturningRealPolynomialWhereIsZeroIsFalse() throws Throwable  {
      double[][] arg1 = new double[2][9];
      double[] doubleArray = new double[1];
      doubleArray[0] = 822.85473;
      arg1[0] = doubleArray;
      arg1[1] = arg1[0];
      RealPolynomial leastSquaresFit = LinearMath.leastSquaresFit(0, arg1);
      assertFalse(leastSquaresFit.isZero());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEigenvalueSolveSymmetricTaking3ArgumentsThrowsTooManyResourcesException() throws Throwable  {
      DoubleSparseSquareMatrix arg0 = new DoubleSparseSquareMatrix(1742, 195);
      IntegerVector integerVector = new IntegerVector(1742);
      AbstractDoubleVector arg1 = integerVector.toDoubleVector();
      // Undeclared exception!
      LinearMath.eigenvalueSolveSymmetric((AbstractDoubleSquareMatrix) arg0, arg1, 10);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEigenvalueSolveSymmetricTaking3Arguments() throws Throwable  {
      DoubleSparseSquareMatrix arg0 = new DoubleSparseSquareMatrix(1251, 1251);
      IntegerVector integerVector = new IntegerVector(1251);
      AbstractDoubleVector arg1 = integerVector.toDoubleVector();
      double[] eigenvalueSolveSymmetric = LinearMath.eigenvalueSolveSymmetric((AbstractDoubleSquareMatrix) arg0, arg1, 1);
      assertArrayEquals(new double[] {0.0}, eigenvalueSolveSymmetric, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test0() throws Throwable  {
      double[] arg1 = new double[6];
      arg1[0] = (double) 250;
      arg1[1] = (double) 250;
      ComplexDiagonalMatrix complexDiagonalMatrix = new ComplexDiagonalMatrix(arg1, arg1);
      AbstractComplexSquareMatrix[] polarDecompose = complexDiagonalMatrix.polarDecompose();
      assertEquals(2, polarDecompose.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test1() throws Throwable  {
      double[] arg1 = new double[3];
      arg1[1] = Double.NaN;
      ComplexDiagonalMatrix complexDiagonalMatrix = new ComplexDiagonalMatrix(arg1, arg1);
      AbstractComplexSquareMatrix[] polarDecompose = complexDiagonalMatrix.polarDecompose();
      assertNull(polarDecompose);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEigenvalueSolveHermitian() throws Throwable  {
      double[] arg1 = new double[4];
      arg1[0] = (double) 1251;
      arg1[1] = (double) 1251;
      ComplexDiagonalMatrix arg0 = new ComplexDiagonalMatrix(arg1, arg1);
      double[] eigenvalueSolveHermitian = LinearMath.eigenvalueSolveHermitian(arg0);
      assertArrayEquals(new double[] {2502.0, 2.2737367544323206E-13, 0.0, 0.0}, eigenvalueSolveHermitian, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEigenvalueSolveHermitianThrowsException() throws Throwable  {
      double[] arg1 = new double[7];
      arg1[3] = Double.NEGATIVE_INFINITY;
      ComplexDiagonalMatrix arg0 = new ComplexDiagonalMatrix(arg1, arg1);
      try { 
        LinearMath.eigenvalueSolveHermitian(arg0);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // No convergence after 250 iterations.
         //
         verifyException("JSci.maths.LinearMath", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEigenSolveSymmetricTaking1And1AndEigenSolveSymmetricTaking1And1AndEigenSolveSymmetricTaking1And1ReturningNonEmptyArray0() throws Throwable  {
      DoubleFileSquareMatrix arg0 = new DoubleFileSquareMatrix(5);
      AbstractDoubleVector[] arg1 = new AbstractDoubleVector[7];
      double[] eigenSolveSymmetric = LinearMath.eigenSolveSymmetric((AbstractDoubleSquareMatrix) arg0, arg1);
      assertEquals(5, eigenSolveSymmetric.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEigenvalueSolveSymmetricTakingAbstractDoubleSquareMatrix() throws Throwable  {
      DoubleTridiagonalMatrix arg0 = new DoubleTridiagonalMatrix(82);
      double[] eigenvalueSolveSymmetric = LinearMath.eigenvalueSolveSymmetric((AbstractDoubleSquareMatrix) arg0);
      assertEquals(82, eigenvalueSolveSymmetric.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEigenSolveSymmetricTaking1And1AndEigenSolveSymmetricTaking1And1AndEigenSolveSymmetricTaking1And1ReturningNonEmptyArray1() throws Throwable  {
      DoubleTridiagonalMatrix arg0 = new DoubleTridiagonalMatrix(4);
      AbstractDoubleVector[] arg1 = new AbstractDoubleVector[4];
      double[] eigenSolveSymmetric = LinearMath.eigenSolveSymmetric(arg0, arg1);
      assertEquals(4, eigenSolveSymmetric.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEigenvalueSolveSymmetricTakingDoubleTridiagonalMatrix() throws Throwable  {
      DoubleTridiagonalMatrix arg0 = new DoubleTridiagonalMatrix(4);
      double[] eigenvalueSolveSymmetric = LinearMath.eigenvalueSolveSymmetric(arg0);
      assertEquals(4, eigenvalueSolveSymmetric.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOrthonormalizeReturningEmptyArray() throws Throwable  {
      AbstractDoubleVector[] arg0 = new AbstractDoubleVector[0];
      AbstractDoubleVector[] orthonormalize = LinearMath.orthonormalize(arg0);
      assertEquals(0, orthonormalize.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLeastSquaresFitReturningRealPolynomialWhereIsZeroIsTrue() throws Throwable  {
      double[][] arg1 = new double[3][9];
      RealPolynomial leastSquaresFit = LinearMath.leastSquaresFit(26, arg1);
      assertTrue(leastSquaresFit.isOne());
      assertEquals(26, leastSquaresFit.degree());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSolveGMResThrowsAssertionError() throws Throwable  {
      DoubleSparseSquareMatrix arg0 = new DoubleSparseSquareMatrix(250);
      DoubleVector arg1 = new DoubleVector(250);
      // Undeclared exception!
      try { 
        LinearMath.solveGMRes(arg0, arg1, 250, 250);
        fail("Expecting exception: AssertionError");
      
      } catch(AssertionError e) {
         //
         // There is a bug.
         //
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSolveGMResWithNullAndNegative() throws Throwable  {
      DoubleFileSquareMatrix arg0 = new DoubleFileSquareMatrix(5);
      // Undeclared exception!
      try { 
        LinearMath.solveGMRes(arg0, (AbstractDoubleVector) null, (-1620), 5);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Number of allowed iterations must be a positive integer: -1620 <= 0.
         //
         verifyException("JSci.maths.LinearMath", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSolveGMResWithNegative() throws Throwable  {
      DoubleSparseSquareMatrix arg0 = new DoubleSparseSquareMatrix(1251, 1251);
      DoubleVector arg1 = new DoubleVector(1251);
      // Undeclared exception!
      try { 
        LinearMath.solveGMRes(arg0, arg1, 1251, (-0.5));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Tolerance must be positive or zero: -0.5 < 0.
         //
         verifyException("JSci.maths.LinearMath", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSolveCG() throws Throwable  {
      DoubleSparseSquareMatrix arg0 = new DoubleSparseSquareMatrix(4);
      DoubleVector arg2 = new DoubleVector(4);
      AbstractDoubleVector solveCG = LinearMath.solveCG(arg0, arg2, arg2, 4, 4, 4);
      assertSame(arg2, solveCG);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSolveCGWithZero() throws Throwable  {
      DoubleFileSquareMatrix arg0 = new DoubleFileSquareMatrix(45);
      // Undeclared exception!
      try { 
        LinearMath.solveCG(arg0, (AbstractDoubleVector) null, (AbstractDoubleVector) null, 45, 0, 45);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Number of allowed iterations must be a positive integer: 0 <= 0.
         //
         verifyException("JSci.maths.LinearMath", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSolveCGWithNegative() throws Throwable  {
      DoubleFileSquareMatrix arg0 = new DoubleFileSquareMatrix(20);
      // Undeclared exception!
      try { 
        LinearMath.solveCG(arg0, (AbstractDoubleVector) null, (AbstractDoubleVector) null, 20, 1220, (-1135.3552093));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Tolerance must be positive or zero: -1135.3552093 < 0.
         //
         verifyException("JSci.maths.LinearMath", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLinearRegression() throws Throwable  {
      double[][] arg0 = new double[3][3];
      AbstractDoubleVector linearRegression = LinearMath.linearRegression(arg0);
      assertEquals(Double.NaN, linearRegression.infNorm(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSolve() throws Throwable  {
      DoubleFileSquareMatrix arg0 = new DoubleFileSquareMatrix(5);
      DoubleVector arg1 = new DoubleVector(5);
      AbstractDoubleVector solve = LinearMath.solve(arg0, arg1);
      assertEquals(Double.NaN, solve.infNorm(), 0.01);
  }
}
