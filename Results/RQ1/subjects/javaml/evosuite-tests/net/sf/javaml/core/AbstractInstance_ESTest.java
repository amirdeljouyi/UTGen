/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 17:13:58 GMT 2024
 */

package net.sf.javaml.core;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.function.Consumer;
import net.sf.javaml.core.AbstractInstance;
import net.sf.javaml.core.DenseInstance;
import net.sf.javaml.core.Instance;
import net.sf.javaml.core.SparseInstance;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class AbstractInstance_ESTest extends AbstractInstance_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashCode() throws Throwable  {
      // Given
      Object arg1 = new Object();
      SparseInstance sparseInstance = new SparseInstance(-1, arg1);
      
      // When
      int hashCode = sparseInstance.hashCode();
      
      // Then
      assertEquals(0, hashCode);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSqrtReturningInstanceWhereGetIDIsZero() throws Throwable  {
      // Given: A SparseInstance object with an ID of 0
      SparseInstance sparseInstance = new SparseInstance();
      AbstractInstance.nextID = 0;
      
      // When: The sqrt() method is called on the instance
      Instance sqrt = sparseInstance.sqrt();
      
      // Then: The resulting Instance has an ID of 0
      assertEquals(0, sqrt.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSqrtReturningInstanceWhereGetIDIsNegative() throws Throwable  {
      // Create a new SparseInstance with the next available ID
      SparseInstance sparseInstance = new SparseInstance();
      AbstractInstance.nextID = (-1);
      
      // Calculate the square root of the instance's ID
      Instance sqrt = sparseInstance.sqrt();
      
      // Assert that the calculated ID is equal to the expected value
      assertEquals((-1), sqrt.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTakingInstanceReturningInstanceWhereGetIDIsNegative() throws Throwable  {
      // Test that multiplying a sparse instance by a dense instance results in the correct ID
      DenseInstance arg0 = new DenseInstance(1727);
      AbstractInstance.nextID = -2;
      SparseInstance sparseInstance = new SparseInstance(-2);
      Instance multiply = sparseInstance.multiply((Instance) arg0);
      assertEquals(-1, multiply.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTakingDoubleReturningInstanceWhereGetIDIsZero() throws Throwable  {
      // Given: A SparseInstance with ID 0 and a multiplier of 0.0
      SparseInstance sparseInstance = new SparseInstance();
      AbstractInstance.nextID = 0;
      
      // When: The multiply method is called with the multiplier 0.0
      Instance multiply = sparseInstance.multiply(0.0);
      
      // Then: The result should have an ID of 0
      assertEquals(0, multiply.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTakingDoubleReturningInstanceWhereGetIDIsNegative() throws Throwable  {
      // rollbacked to evosuite
      SparseInstance sparseInstance = new SparseInstance();
      AbstractInstance.nextID = (-850);
      Instance multiply = sparseInstance.multiply((-1209.8385112476703));
      assertEquals((-850), multiply.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMinusTakingDoubleReturningInstanceWhereGetIDIsZero() throws Throwable  {
      // Given a sparse instance with 4 features and an ID of 0
      double[] featureVals = new double[4];
      Object label = new Object();
      SparseInstance sparseInstance = new SparseInstance(featureVals, label);
      AbstractInstance.nextID = 0;
      
      // When we call the minus method with a negative value
      Instance result = sparseInstance.minus(-2318.903);
      
      // Then the ID of the resulting instance should be 0
      assertEquals(0, result.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIterator() throws Throwable  {
      // rollbacked to evosuite
      SparseInstance sparseInstance = new SparseInstance();
      sparseInstance.iterator();
      assertEquals(0, sparseInstance.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetIDReturningPositive() throws Throwable  {
      // Given a SparseInstance and a DenseInstance with the same data
      double[] arg0 = new double[0];
      SparseInstance sparseInstance = new SparseInstance(arg0);
      DenseInstance denseInstance = new DenseInstance(arg0);
      
      // When we get the ID of the DenseInstance
      int iD = denseInstance.getID();
      
      // Then we expect the ID to be 1
      assertEquals(1, iD);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEquals() throws Throwable  {
      // No Comments were added
      SparseInstance arg0 = new SparseInstance();
      arg0.equals(arg0);
      assertEquals(0, arg0.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideTakingInstanceReturningInstanceWhereGetIDIsZero() throws Throwable  {
      // Given two instances, one sparse and one dense
      SparseInstance sparseInstance = new SparseInstance();
      DenseInstance denseInstance = new DenseInstance(0);
      
      // When the sparse instance is divided by the dense instance
      AbstractInstance.nextID = 0;
      Instance divide = sparseInstance.divide((Instance) denseInstance);
      
      // Then the resulting instance has the correct ID
      assertEquals(0, divide.getID());
      
      // And the original instances have not been modified
      assertEquals(1, sparseInstance.getID());
      assertEquals(0, denseInstance.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideTakingDoubleReturningInstanceWhereGetIDIsZero() throws Throwable  {
      SparseInstance sparseInstance = new SparseInstance();
      AbstractInstance.nextID = 0;
      // Given a specific input value for the method "divide"
      double inputValue = -4377.996363608;
      // When the method "divide" is called with the input value
      Instance divide = sparseInstance.divide(inputValue);
      // Then the result of calling the method "divide" should be equal to 0
      assertEquals(0, divide.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideTakingDoubleReturningInstanceWhereGetIDIsNegative() throws Throwable  {
      // Given a SparseInstance with ID -2761 and a negative value of 4377.996363608
      SparseInstance sparseInstance = new SparseInstance();
      AbstractInstance.nextID = (-2761);
      double inputValue = (-4377.996363608);
      
      // When the divide method is called with this input value
      Instance divide = sparseInstance.divide(inputValue);
      
      // Then the resulting ID should be the same as the original ID, which is -2761
      assertEquals((-2761), divide.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClassValueReturningNull() throws Throwable  {
      // rollbacked to evosuite
      double[] arg0 = new double[3];
      SparseInstance sparseInstance = new SparseInstance(arg0, (Object) null);
      sparseInstance.classValue();
      assertEquals(0, sparseInstance.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClassValueReturningNonNull() throws Throwable  {
      // rollbacked to evosuite
      double[] arg0 = new double[0];
      Object arg1 = new Object();
      SparseInstance sparseInstance = new SparseInstance(arg0, arg1);
      sparseInstance.classValue();
      assertEquals(0, sparseInstance.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTakingDouble() throws Throwable  {
      // Create a new instance with ID -1
      Object arg1 = new Object();
      SparseInstance sparseInstance = new SparseInstance((-1), arg1);
      
      // Set the nextID to -1
      AbstractInstance.nextID = (-1);
      
      // Call the sqrt method on the instance and assert that the ID is -1
      Instance sqrt = sparseInstance.sqrt();
      assertEquals((-1), sqrt.getID());
      
      // Add a double value of -1 to the instance and assert that the ID is 0
      Instance add = sparseInstance.add((double) (-1));
      assertEquals(0, add.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSqrtReturningInstanceWhereGetIDIsPositive() throws Throwable  {
      // Given a DenseInstance with ID 31
      DenseInstance denseInstance = new DenseInstance(31);
      
      // When the sqrt method is called on the instance
      Instance sqrt = denseInstance.sqrt();
      
      // Then the result should have an ID of 1
      assertEquals(1, sqrt.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTakingInstance() throws Throwable  {
      // Given a SparseInstance instance
      SparseInstance sparseInstance = new SparseInstance();
      
      // When we add an Instance to it
      Instance add = sparseInstance.add((Instance) null);
      
      // Then we expect the ID of the added instance to be 1
      assertEquals(1, add.getID());
      
      // And we expect the added instance not to be null
      assertNotNull(add);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideTakingInstanceReturningInstanceWhereGetIDIsPositive() throws Throwable  {
      // Given a DenseInstance with ID 1727
      DenseInstance denseInstance = new DenseInstance(1727);
      
      // When we divide the DenseInstance by itself
      Instance dividedInstance = denseInstance.divide((Instance) denseInstance);
      
      // Then we expect the result to have an ID of 1
      assertEquals(1, dividedInstance.getID());
      
      // And we expect the result to not be equal to the original instance
      assertFalse(dividedInstance.equals((Object) denseInstance));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTakingInstanceReturningInstanceWhereGetIDIsPositive() throws Throwable  {
      DenseInstance denseInstance = new DenseInstance(1727);
      Instance multiply = denseInstance.multiply((Instance) denseInstance);
      
      // Assert that the result of the multiplication is equal to the original instance
      assertEquals(denseInstance, multiply);
      
      // Assert that the result of the multiplication is equivalent to the original instance
      assertTrue(denseInstance.equals(multiply));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTakingDoubleReturningInstanceWhereGetIDIsPositive() throws Throwable  {
      // Given a DenseInstance with an ID of 882
      DenseInstance denseInstance = new DenseInstance(882);
      
      // When we multiply the instance by 882
      Instance multiply = denseInstance.multiply((double) 882);
      
      // Then the result should have an ID of 1
      assertEquals(1, multiply.getID());
      
      // And the result should be equal to the original instance
      assertTrue(multiply.equals((Object) denseInstance));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideTakingDoubleReturningInstanceWhereGetIDIsPositive() throws Throwable  {
      // Given a SparseInstance with ID 4993
      SparseInstance sparseInstance = new SparseInstance(4993);
      
      // When dividing the instance by 4993
      Instance divide = sparseInstance.divide((double) 4993);
      
      // Then the resulting Instance should have ID 1
      assertEquals(1, divide.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMinusTakingDouble() throws Throwable  {
      double[] featureValues = new double[4];
      Object label = new Object();
      SparseInstance sparseInstance = new SparseInstance(featureValues, label);
      Instance minus = sparseInstance.minus(-2318.903);
      assertEquals(1, minus.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMinusTakingDoubleReturningInstanceWhereSizeIsZero() throws Throwable  {
      // Given a dense instance with an ID of 0
      DenseInstance denseInstance = new DenseInstance(0);
      
      // When we call the minus method with a double value of 0
      Instance minus = denseInstance.minus((double) 0);
      
      // Then the resulting instance should have an ID of 1
      assertEquals(1, minus.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMinusTakingInstance() throws Throwable  {
      // Test that the sparseInstance minus method returns a new instance with the correct ID
      SparseInstance sparseInstance = new SparseInstance(-1, -1);
      Instance minus = sparseInstance.minus((Instance) null);
      assertNotNull(minus); // Make sure the result is not null
      assertEquals(1, minus.getID()); // Check that the returned instance has the correct ID
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetIDReturningZero() throws Throwable  {
      // Given a SparseInstance with an ID of -2
      SparseInstance sparseInstance = new SparseInstance(-2);
      
      // When the getID method is called on the SparseInstance
      int iD = sparseInstance.getID();
      
      // Then the returned ID should be 0
      assertEquals(0, iD);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test0() throws Throwable  {
      // rollbacked to evosuite
      double[] arg0 = new double[7];
      DenseInstance denseInstance = new DenseInstance(arg0);
      Instance copy = denseInstance.copy();
      assertEquals(1, copy.getID());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNext() throws Throwable  {
      // Given a SparseInstance object
      SparseInstance sparseInstance = new SparseInstance();
      
      // When we create a new InstanceValueIterator object for the SparseInstance
      AbstractInstance.InstanceValueIterator instanceValueIterator = sparseInstance.new InstanceValueIterator();
      
      // Then we can call next() on the iterator and expect the first value to be the ID of the SparseInstance
      assertEquals(0, instanceValueIterator.next());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemove() throws Throwable  {
      // Test that the InstanceValueIterator does not support removing instances from the instance.
      SparseInstance sparseInstance = new SparseInstance();
      AbstractInstance.InstanceValueIterator instanceValueIterator = sparseInstance.new InstanceValueIterator();
      try {
      instanceValueIterator.remove();
      fail("Expecting exception: UnsupportedOperationException");
      } catch(UnsupportedOperationException e) {
      // Cannot remove from instance using the iterator.
      verifyException("net.sf.javaml.core.AbstractInstance$InstanceValueIterator", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test1() throws Throwable  {
      SparseInstance sparseInstance = new SparseInstance();
      Consumer<Object> mockConsumer = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      sparseInstance.forEach(mockConsumer);
      // Asserts that the ID of the sparse instance is 0
      assertEquals(0, sparseInstance.getID());
  }
}
