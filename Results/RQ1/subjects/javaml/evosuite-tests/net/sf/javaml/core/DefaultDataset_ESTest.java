/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 17:29:32 GMT 2024
 */

package net.sf.javaml.core;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.SortedSet;
import net.sf.javaml.core.Dataset;
import net.sf.javaml.core.DefaultDataset;
import net.sf.javaml.core.DenseInstance;
import net.sf.javaml.core.Instance;
import net.sf.javaml.core.SparseInstance;
import net.sf.javaml.distance.EuclideanDistance;
import net.sf.javaml.distance.SpearmanFootruleDistance;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.util.MockRandom;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class DefaultDataset_ESTest extends DefaultDataset_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInstanceReturningNull() throws Throwable  {
      // Given a dataset with 1000 instances
      DefaultDataset defaultDataset = new DefaultDataset();
      defaultDataset.setSize(1000);
      
      // When we retrieve the instance at index 950
      Instance instance = defaultDataset.instance(950);
      
      // Then the result is null, since there are no instances at that index
      assertNull(instance);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTaking2Arguments() throws Throwable  {
      // Given a dataset with 1 instance
      DefaultDataset defaultDataset = new DefaultDataset();
      DenseInstance denseInstance = new DenseInstance(0);
      Instance arg1 = denseInstance.sqrt();
      defaultDataset.add(0, arg1);
      
      // When we add the instance to the dataset
      Instance instance = defaultDataset.instance(0);
      
      // Then the dataset size is 1
      assertEquals(1, instance.noAttributes());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClasses() throws Throwable  {
      // Given an empty default dataset
      DefaultDataset defaultDataset = new DefaultDataset();
      
      // When we retrieve the list of classes
      SortedSet<Object> classes = defaultDataset.classes();
      
      // Then the returned set should be empty
      assertTrue(classes.isEmpty());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddAllTakingCollection() throws Throwable  {
      // Create a new DefaultDataset instance
      DefaultDataset defaultDataset = new DefaultDataset();
      
      // Create a LinkedHashSet<SparseInstance> that contains some instances
      LinkedHashSet<SparseInstance> arg0 = new LinkedHashSet<>();
      arg0.add(new SparseInstance(1, 2, "feature_1"));
      arg0.add(new SparseInstance(3, 4, "feature_2"));
      arg0.add(new SparseInstance(5, 6, "feature_3"));
      
      // Call the addAll method of the DefaultDataset with the LinkedHashSet<SparseInstance> as an argument
      boolean addAll = defaultDataset.addAll((Collection<? extends Instance>) arg0);
      
      // Assert that the addAll method returned false because the dataset already contains some instances
      assertFalse(addAll);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCopy() throws Throwable  {
      // Given a default dataset
      DefaultDataset defaultDataset = new DefaultDataset();
      
      // When we call the copy method
      Dataset copy = defaultDataset.copy();
      
      // Then we should get a different instance than the original dataset
      assertNotSame(copy, defaultDataset);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClassValue() throws Throwable  {
      // Setup
      DefaultDataset dataset = new DefaultDataset();
      
      // Test
      Object classValue = dataset.classValue(2022);
      
      // Assertion
      assertNull(classValue);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClassIndexReturningNegative() throws Throwable  {
      // Given a dataset with no classes
      DefaultDataset defaultDataset = new DefaultDataset();
      
      // When the class index is requested for a null input
      int classIndex = defaultDataset.classIndex(null);
      
      // Then the method should return -1
      assertEquals(-1, classIndex);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNoAttributes() throws Throwable  {
      // Given an empty dataset
      DefaultDataset defaultDataset = new DefaultDataset();
      
      // When the number of attributes in the dataset is requested
      int noAttributes = defaultDataset.noAttributes();
      
      // Then the result should be 0, indicating that there are no attributes in the dataset
      assertEquals(0, noAttributes);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFolds() throws Throwable  {
      DefaultDataset defaultDataset = new DefaultDataset();
      // Create an instance of SparseInstance, which is a type of Instance.
      SparseInstance sparseInstance = new SparseInstance();
      defaultDataset.add((Instance) sparseInstance);
      // Create a MockRandom object to use for generating random numbers.
      MockRandom mockRandom = new MockRandom();
      // Split the default dataset into 2159 folds using the mockRandom object as the source of randomness.
      Dataset[] folds = defaultDataset.folds(2159, mockRandom);
      // Assert that the number of folds is equal to the expected value.
      assertEquals(2159, folds.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTakingInstanceWithNonEmptyMap() throws Throwable  {
      // Arrange
      DefaultDataset defaultDataset = new DefaultDataset();
      DenseInstance denseInstance = new DenseInstance(8);
      SparseInstance sparseInstance = new SparseInstance();
      EuclideanDistance euclideanDistance = new EuclideanDistance();
      
      // Act
      Set<Instance> kNearest = defaultDataset.kNearest(8, sparseInstance, euclideanDistance);
      
      // Assert
      assertEquals(1, kNearest.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testKNearestWithNegativeAndNonEmptyMap() throws Throwable  {
      DefaultDataset defaultDataset = new DefaultDataset();
      // Create a new DenseInstance with a single feature
      double[] arg0 = new double[1];
      DenseInstance arg1 = new DenseInstance(arg0);
      defaultDataset.add((Instance) arg1);
      // Calculate the Spearman footrule distance for the given instance and a negative value for k
      SpearmanFootruleDistance arg2 = new SpearmanFootruleDistance();
      // Use the DefaultDataset's kNearest method to find the k nearest instances to the given instance with a negative value for k.
      Set<Instance> kNearest = defaultDataset.kNearest((-1849), arg1, arg2);
      // Assert that the returned set is empty since there are no instances in the dataset within the specified distance.
      assertTrue(kNearest.isEmpty());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddTakingInstanceWithEmptyMap() throws Throwable  {
      // Create a new dataset with no instances
      DefaultDataset dataset = new DefaultDataset();
      
      // Create a new instance and add it to the dataset
      SparseInstance instance = new SparseInstance();
      dataset.add(instance);
      
      // Get the k nearest neighbors for an unknown instance
      EuclideanDistance distanceMetric = new EuclideanDistance();
      Set<Instance> kNearest = dataset.kNearest(14, instance, distanceMetric);
      
      // Assert that there are no nearest neighbors returned
      assertEquals(0, kNearest.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClassIndexReturningZero() throws Throwable  {
      // Given a dataset with the class "red"
      DefaultDataset defaultDataset = new DefaultDataset();
      
      // When the method getClassIndex is called with the class "red"
      int classIndex = defaultDataset.classIndex("red");
      
      // Then the method should return 0
      assertEquals(0, classIndex);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClear() throws Throwable  {
      // Given: A dataset is created and initialized with the empty dataset method.
      DefaultDataset defaultDataset = new DefaultDataset();
      
      // When: The clear method is called on the dataset.
      defaultDataset.clear();
      
      // Then: The dataset should be empty after calling the clear method.
      assertTrue(defaultDataset.isEmpty());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddAllTaking2Arguments() throws Throwable  {
      // Set up a new DefaultDataset object
      DefaultDataset arg1 = new DefaultDataset();
      
      // Try to add all the instances from the dataset to itself
      boolean addAll = arg1.addAll(0, (Collection<? extends Instance>) arg1);
      
      // Assert that the method returned false since adding the same dataset twice is not allowed
      assertFalse(addAll);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInstanceReturningInstanceWhereGetIDIsZero() throws Throwable  {
      // Given a DefaultDataset object and a SparseInstance object
      DefaultDataset defaultDataset = new DefaultDataset();
      SparseInstance sparseInstance = new SparseInstance(0);
      
      // When we add the SparseInstance to the DefaultDataset
      defaultDataset.add((Instance)sparseInstance);
      
      // Then the Instance we retrieved from the DefaultDataset should be the same as the SparseInstance we added
      Instance instance = defaultDataset.instance(0);
      assertSame(instance, sparseInstance);
  }
}
