/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 17:20:14 GMT 2024
 */

package net.sf.javaml.core;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import net.sf.javaml.core.Complex;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class Complex_ESTest extends Complex_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesComplexTaking2Arguments() throws Throwable  {
      // Given a Complex number with real part 1.2 and imaginary part 2.3
      Complex complex = new Complex(1.2, 2.3);
      
      // When the absolute value of the Complex number is calculated
      double absValue = complex.abs();
      
      // Then the absolute value should be close to 2.5942243542145693
      assertEquals(2.5942243542145693, absValue, 0.01);
      
      // And the real part of the Complex number should be equal to 1.2
      assertEquals(1.2, complex.re, 0.01);
      
      // And the imaginary part of the Complex number should be equal to 2.3
      assertEquals(2.3, complex.im, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPlusTaking2ArgumentsReturningComplexWhereAbsIsPositive() throws Throwable  {
      // Given: two complex numbers arg1 and arg2 with equal real and imaginary parts
      Complex arg1 = Complex.I;
      
      // When: adding the two complex numbers
      Complex plus = Complex.plus(arg1, arg1);
      
      // Then: the sum is 0.0 + 2.0i
      assertEquals(0.0, plus.re, 0.01);
      assertEquals(2.0, plus.abs(), 0.01);
      assertEquals(2.0, plus.im, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTaking2ComplexsReturningComplexWhereAbsIsZero() throws Throwable  {
      // Given: Two complex numbers arg0 and arg1 with real and imaginary components re and im respectively
      Complex arg0 = Complex.I; // Real part of the complex number is 1 and imaginary part is 0
      Complex arg1 = Complex.multiply(arg0, 0.0); // Multiplying a complex number by 0 results in a complex number with real and imaginary components both equal to 0
      
      // When: The complex numbers are multiplied together
      Complex multiply = Complex.multiply(arg0, arg1);
      
      // Then: The result of the multiplication is a complex number with real and imaginary components both equal to 0
      assertEquals(0.0, multiply.abs(), 0.01); // abs() method returns the magnitude (or modulus) of the complex number, which in this case is 0
      assertEquals(0.0, arg1.im, 0.01); // The imaginary component of arg1 is still 0
      assertEquals(0.0, arg1.re, 0.01); // The real component of arg1 is still 0
      assertEquals(0.0, multiply.im, 0.01); // The imaginary component of the result of the multiplication is also 0
      assertEquals(0.0, multiply.re, 0.01); // The real component of the result of the multiplication is also 0
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTaking2ComplexsReturningComplexWhereAbsIsPositive() throws Throwable  {
      // Given a complex number z = -1 + i*0
      Complex arg1 = Complex.I;
      // When we multiply it by itself
      Complex multiply = Complex.multiply(arg1, arg1);
      // Then the real part of the result should be approximately -1
      assertEquals((-1.0), multiply.re, 0.01);
      // And the imaginary part should be approximately 0
      assertEquals(0.0, multiply.im, 0.01);
      // And the absolute value of the result should be approximately 1
      assertEquals(1.0, multiply.abs(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMultiplyTaking1And1ReturningComplexWhereAbsIsPositive() throws Throwable  {
      // Given two complex numbers, arg1 and arg0
      Complex arg1 = Complex.I;
      Complex arg0 = Complex.multiply(arg1, -1.0);
      
      // When the plus method is called with arg0 and arg1 as arguments
      Complex plus = Complex.plus(arg0, arg1);
      
      // Then the resulting complex number's imaginary part should be equal to 0.0 within a tolerance of 0.01
      assertEquals(0.0, plus.im, 0.01);
      
      // And the absolute value of arg0 should be equal to 1.0 within a tolerance of 0.01
      assertEquals(1.0, arg0.abs(), 0.01);
      
      // And the absolute value of the resulting complex number should be equal to 0.0 within a tolerance of 0.01
      assertEquals(0.0, plus.abs(), 0.01);
      
      // And the real part of the resulting complex number should be equal to 0.0 within a tolerance of 0.01
      assertEquals(0.0, plus.re, 0.01);
      
      // And the real part of arg0 should be equal to -0.0 within a tolerance of 0.01
      assertEquals(-0.0, arg0.re, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConjugate() throws Throwable  {
      // No Comments were added
      Complex complex = Complex.I;
      complex.conjugate();
      assertEquals((-1.0), complex.im, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPlusTakingComplex() throws Throwable  {
      // Given a complex number "Complex.I" with imaginary part equal to 1.0
      Complex arg0 = Complex.I;
      
      // When we add the complex number to itself
      arg0.plus(arg0);
      
      // Then the resulting complex number's imaginary part should be equal to 2.0, with a tolerance of 0.01
      assertEquals(2.0, arg0.im, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTimesTakingComplex() throws Throwable  {
      // Given: A complex number with an imaginary part of 1
      Complex given = Complex.I;
      
      // When: The complex number is multiplied by itself
      given.times(given);
      
      // Then: The result should have a real part of 0 and an imaginary part within 0.01 of 0
      assertEquals(0.0, given.re, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMinus() throws Throwable  {
      // Arrange
      Complex complex = Complex.I;
      
      // Act
      complex.minus(complex);
      
      // Assert
      assertEquals(0.0, complex.im, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToString() throws Throwable  {
      // Given
      Complex complex = Complex.I;
      
      // When
      String string = complex.toString();
      
      // Then
      assertEquals("0.0 + -770357.04i", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesComplexTakingNoArguments() throws Throwable  {
      // Creates a new instance of the Complex class with default values
      Complex complex = new Complex();
      
      // Asserts that the imaginary part is 0.0 within a tolerance of 0.01
      assertEquals(0.0, complex.im, 0.01);
      
      // Asserts that the real part is 0.0 within a tolerance of 0.01
      assertEquals(0.0, complex.re, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAbsReturningZero() throws Throwable  {
      // Given the Complex number I and a scalar value of 0.0
      Complex arg0 = Complex.I;
      double scaler = 0.0;
      
      // When the complex number is multiplied by the scalar value
      Complex multiply = Complex.multiply(arg0, scaler);
      
      // Then the real and imaginary parts of the result should be both 0.0
      assertEquals(-0.0, multiply.im, 0.01);
      assertEquals(0.0, multiply.re, 0.01);
      
      // And the absolute value of the result should also be 0.0
      double abs = multiply.abs();
      assertEquals(0.0, abs, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTimesTakingDouble() throws Throwable  {
      // No Comments were added
      Complex complex = Complex.I;
      complex.I.times((-877.2));
      assertEquals((-877.2), complex.im, 0.01);
      assertEquals(877.2, complex.abs(), 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAbsReturningPositive() throws Throwable  {
      // Given a complex number with a real part of 1 and an imaginary part of 0
      Complex complex = new Complex(1, 0);
      
      // When the absolute value of the complex number is calculated
      double abs = complex.abs();
      
      // Then the absolute value should be 1
      assertEquals(1.0, abs, 0.01);
  }
}
