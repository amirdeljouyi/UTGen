/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Mar 18 10:38:22 GMT 2024
 */

package com.puppycrawl.tools.checkstyle.utils;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.Scope;
import com.puppycrawl.tools.checkstyle.utils.ScopeUtils;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class ScopeUtils_ESTest extends ScopeUtils_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInAnnotationBlockWithDetailASTWhereGetNumberOfChildrenIsZero() throws Throwable  {
      // Given a DetailAST object representing an annotation block
      DetailAST detailAST = new DetailAST();
      
      // When the method ScopeUtils.isInAnnotationBlock is called with the DetailAST object as an argument
      boolean inAnnotationBlock = ScopeUtils.isInAnnotationBlock(detailAST);
      
      // Then the method should return false, indicating that the current scope is not within an annotation block
      assertFalse(inAnnotationBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInInterfaceBlockThrowsTooManyResourcesException() throws Throwable  {
      // rollbacked to evosuite
      DetailAST arg0 = new DetailAST();
      arg0.setFirstChild(arg0);
      // Undeclared exception!
      ScopeUtils.isInInterfaceBlock(arg0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSurroundingScope() throws Throwable  {
      // rollbacked to evosuite
      DetailAST arg0 = new DetailAST();
      ScopeUtils.getSurroundingScope(arg0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInScopeReturningFalse() throws Throwable  {
      // Arrange
      DetailAST ast = new DetailAST();
      Scope scope = Scope.PROTECTED;
      
      // Act
      boolean inScope = ScopeUtils.isInScope(ast, scope);
      
      // Assert
      assertFalse(inScope);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsClassFieldDef() throws Throwable  {
      // Given a DetailAST object representing a field definition in a class scope
      DetailAST arg0 = new DetailAST();
      
      // When we call the method ScopeUtils.isClassFieldDef on the DetailAST object
      boolean classFieldDef = ScopeUtils.isClassFieldDef(arg0);
      
      // Then the method should return false, indicating that the field definition is not in a class scope
      assertFalse(classFieldDef);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsLocalVariableDefThrowsNullPointerException() throws Throwable  {
      DetailAST arg0 = new DetailAST();
      // initialize the argument to a non-null value
      arg0.initialize(21, "fTp'*0P4[*kJ0G");
      
      try {
      ScopeUtils.isLocalVariableDef(arg0);
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      // no message in the exception (getMessage() returned null)
      verifyException("com.puppycrawl.tools.checkstyle.utils.ScopeUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsLocalVariableDef() throws Throwable  {
      DetailAST arg0 = new DetailAST();
      // Create a new DetailAST object with an identifier of "my_variable" and a type of 10 (which is not a valid type)
      arg0.initialize(10, "my_variable");
      // Add the DetailAST object to itself as a child node
      arg0.addChild(arg0);
      // Check if the DetailAST object is a definition of a local variable using the ScopeUtils class
      boolean localVariableDef = ScopeUtils.isLocalVariableDef(arg0);
      // Assert that the DetailAST object is not a definition of a local variable
      assertFalse(localVariableDef);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsOuterMostType0() throws Throwable  {
      // Given
      DetailAST ast = new DetailAST();
      ast.addChild(ast);
      ast.initialize(157, "%s (%d) must not be negative");
      
      // When
      boolean isOuterMostType = ScopeUtils.isOuterMostType(ast);
      
      // Then
      assertFalse(isOuterMostType);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsOuterMostType1() throws Throwable  {
      // Given an initialized DetailAST object with at least one child node
      DetailAST ast = new DetailAST();
      ast.addChild(ast);
      ast.initialize(15, "K~cV86le]");
      
      // When we check if the DetailAST is an outermost type
      boolean isOuterMostType = ScopeUtils.isOuterMostType(ast);
      
      // Then it should not be considered an outermost type
      assertFalse(isOuterMostType);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsOuterMostType2() throws Throwable  {
      // Create a DetailAST object representing an outer type declaration
      DetailAST arg0 = new DetailAST();
      arg0.initialize(14, "outer_type");
      
      // Add a child DetailAST object to the outer type declaration
      arg0.addChild(arg0);
      
      // Check that the outer type is not considered an outermost type
      boolean outerMostType = ScopeUtils.isOuterMostType(arg0);
      assertFalse(outerMostType);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsOuterMostTypeThrowsTooManyResourcesException() throws Throwable  {
      // rollbacked to evosuite
      DetailAST arg0 = new DetailAST();
      arg0.addChild(arg0);
      // Undeclared exception!
      ScopeUtils.isOuterMostType(arg0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsOuterMostTypeReturningTrue() throws Throwable  {
      // Arrange
      DetailAST ast = new DetailAST();
      boolean expected = true;
      
      // Act
      boolean actual = ScopeUtils.isOuterMostType(ast);
      
      // Assert
      assertEquals(expected, actual);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInCodeBlock0() throws Throwable  {
      // Given: A DetailAST object representing a method call
      DetailAST myMethod = new DetailAST();
      myMethod.initialize(11, "myMethod");
      myMethod.addChild(myMethod);
      
      // When: Checking if the method is within a code block
      boolean inCodeBlock = ScopeUtils.isInCodeBlock(myMethod);
      
      // Then: The method should be within a code block
      assertTrue(inCodeBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInCodeBlock1() throws Throwable  {
      // Given: a DetailAST node with nested nodes
      DetailAST outerNode = new DetailAST();
      outerNode.addChild(outerNode);
      outerNode.initialize(8, "o{7");
      
      // When: calling the isInCodeBlock method on the node
      boolean inCodeBlock = ScopeUtils.isInCodeBlock(outerNode);
      
      // Then: the method should return true since the node is inside a code block
      assertTrue(inCodeBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInCodeBlockThrowsTooManyResourcesException() throws Throwable  {
      // Given: a DetailAST object
      DetailAST ast = new DetailAST();
      
      // When: setting the first child of the AST to itself
      ast.setFirstChild(ast);
      
      // Then: an exception should be thrown, as the AST is not in a code block
      assertThrows(Exception.class, () -> ScopeUtils.isInCodeBlock(ast));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInCodeBlockReturningFalse() throws Throwable  {
      // Given: A DetailAST object representing a node in the code
      DetailAST ast = new DetailAST();
      
      // When: Calling ScopeUtils.isInCodeBlock with the node
      boolean isInCodeBlock = ScopeUtils.isInCodeBlock(ast);
      
      // Then: Expecting false, as the node is not inside a code block
      assertFalse(isInCodeBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInEnumBlock0() throws Throwable  {
      // The test checks that the DetailAST object is not within an enum block.
      DetailAST detailAST = new DetailAST();
      detailAST.initialize(136, "!h2>");
      detailAST.addChild(detailAST);
      boolean inEnumBlock = ScopeUtils.isInEnumBlock(detailAST);
      assertFalse(inEnumBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInEnumBlock1() throws Throwable  {
      DetailAST arg0 = new DetailAST();
      // Given: a DetailAST object with an ID of 14 and no name
      
      arg0.initialize(14, (String) null);
      
      // When: the isInEnumBlock() method is called on this object
      boolean inEnumBlock = ScopeUtils.isInEnumBlock(arg0);
      
      // Then: we expect to receive false as a result, since this object is not part of an enum block
      assertFalse(inEnumBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInEnumBlock2() throws Throwable  {
      // Given a DetailAST object with a specific line number and text
      DetailAST arg0 = new DetailAST();
      arg0.initialize(157, "t_3FwH");
      
      // When the method is called on the DetailAST object
      boolean inEnumBlock = ScopeUtils.isInEnumBlock(arg0);
      
      // Then the result is false
      assertFalse(inEnumBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInEnumBlock3() throws Throwable  {
      // Given: we have a DetailAST object named "arg0" with an ID value of 15 and a name of "<mg_[l3r9dcvKQg>"
      DetailAST arg0 = new DetailAST();
      arg0.addChild(arg0);
      arg0.initialize(15, "<mg_[l3r9dcvKQg>");
      
      // When: we call the ScopeUtils.isInEnumBlock() method with "arg0" as its argument
      boolean inEnumBlock = ScopeUtils.isInEnumBlock(arg0);
      
      // Then: we expect the method to return false, indicating that the DetailAST object is not within an enum block
      assertFalse(inEnumBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInEnumBlockThrowsTooManyResourcesException() throws Throwable  {
      // Given a DetailAST object with a child that refers to the same object
      DetailAST ast = new DetailAST();
      ast.addChild(ast);
      
      // When the isInEnumBlock method is called on this recursive AST
      boolean result = ScopeUtils.isInEnumBlock(ast);
      
      // Then we expect that it returns true, since this AST refers to an enum block
      assertTrue(result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInEnumBlockWithDetailASTWhereGetNumberOfChildrenIsZero() throws Throwable  {
      // Given a DetailAST object representing some code in a Java file
      DetailAST ast = new DetailAST();
      
      // When we check if the current scope is within an enum block using ScopeUtils.isInEnumBlock
      boolean inEnumBlock = ScopeUtils.isInEnumBlock(ast);
      
      // Then the result should be false, indicating that the current scope is not within an enum block
      assertFalse(inEnumBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInInterfaceOrAnnotationBlockAndIsInInterfaceOrAnnotationBlockReturningTrue0() throws Throwable  {
      // Set up the DetailAST object with a fake AST node
      DetailAST arg0 = new DetailAST();
      arg0.initialize(157, "zT%g4");
      arg0.addChild(arg0);
      
      // Check if the given AST node is in an interface or annotation block
      boolean inInterfaceOrAnnotationBlock = ScopeUtils.isInInterfaceOrAnnotationBlock(arg0);
      
      // Assert that the result is true, as we expect the AST node to be in an interface or annotation block
      assertTrue(inInterfaceOrAnnotationBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInInterfaceOrAnnotationBlockAndIsInInterfaceOrAnnotationBlockReturningTrue1() throws Throwable  {
      // This test verifies that the method ScopeUtils.isInInterfaceOrAnnotationBlock returns true when the node is in an interface or annotation block.
      
      DetailAST arg0 = new DetailAST();
      arg0.initialize(15, "S}QQug");
      arg0.addChild(arg0);
      boolean inInterfaceOrAnnotationBlock = ScopeUtils.isInInterfaceOrAnnotationBlock(arg0);
      assertTrue(inInterfaceOrAnnotationBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInAnnotationBlock0() throws Throwable  {
      // Arrange
      DetailAST ast = new DetailAST();
      ast.initialize(136, "!h2>");
      ast.addChild(ast);
      
      // Act
      boolean inAnnotationBlock = ScopeUtils.isInAnnotationBlock(ast);
      
      // Assert
      assertFalse(inAnnotationBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInAnnotationBlock1() throws Throwable  {
      // Given: a DetailAST object with an annotation block scope
      DetailAST arg0 = new DetailAST();
      arg0.addChild(arg0);
      arg0.initialize(15, "com.puppycrawl.tools.checkstyle.utils.ScopeUtils");
      
      // When: the isInAnnotationBlock method is called with the DetailAST object as an argument
      boolean inAnnotationBlock = ScopeUtils.isInAnnotationBlock(arg0);
      
      // Then: the method should return false, indicating that the DetailAST object is not within an annotation block scope
      assertFalse(inAnnotationBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInAnnotationBlockThrowsTooManyResourcesException() throws Throwable  {
      // rollbacked to evosuite
      DetailAST arg0 = new DetailAST();
      arg0.addChild(arg0);
      // Undeclared exception!
      ScopeUtils.isInAnnotationBlock(arg0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInInterfaceOrAnnotationBlockAndIsInInterfaceOrAnnotationBlockReturningFalse0() throws Throwable  {
      // rollbacked to evosuite
      DetailAST arg0 = new DetailAST();
      arg0.initialize(14, (String) null);
      arg0.addChild(arg0);
      boolean inInterfaceOrAnnotationBlock = ScopeUtils.isInInterfaceOrAnnotationBlock(arg0);
      assertFalse(inInterfaceOrAnnotationBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInAnnotationBlockReturningTrue() throws Throwable  {
      // rollbacked to evosuite
      DetailAST arg0 = new DetailAST();
      arg0.initialize(157, "t_3FwH");
      arg0.addChild(arg0);
      boolean inAnnotationBlock = ScopeUtils.isInAnnotationBlock(arg0);
      assertTrue(inAnnotationBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInInterfaceOrAnnotationBlockWithDetailASTWhereGetNumberOfChildrenIsZero() throws Throwable  {
      // Given: A DetailAST object representing a Java code snippet
      DetailAST ast = new DetailAST();
      
      // When: The method is called with the given AST
      boolean inInterfaceOrAnnotationBlock = ScopeUtils.isInInterfaceOrAnnotationBlock(ast);
      
      // Then: The result should be false, since the AST does not represent a code snippet that is within an interface or annotation block
      assertFalse(inInterfaceOrAnnotationBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInInterfaceBlock0() throws Throwable  {
      // Given: A DetailAST with type "t_3FwH" and a child node
      DetailAST ast = new DetailAST();
      ast.initialize(157, "t_3FwH");
      ast.addChild(ast);
      
      // When: The method is called with the AST as argument
      boolean inInterfaceBlock = ScopeUtils.isInInterfaceBlock(ast);
      
      // Then: The result should be false, since the AST is not within an interface block
      assertFalse(inInterfaceBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInInterfaceOrAnnotationBlockAndIsInInterfaceOrAnnotationBlockReturningFalse1() throws Throwable  {
      DetailAST ast = new DetailAST();
      ast.initialize(154, "com.example.MyClass");
      
      // Add a child to the AST instance with an ID of 154 and a fully qualified name of "com.example.MyClass"
      ast.addChild(ast);
      
      // Check if the current node is in an interface or annotation block, given the context of the parent node and the current node
      boolean inInterfaceOrAnnotationBlock = ScopeUtils.isInInterfaceOrAnnotationBlock(ast);
      
      // Assert that the method returns false, indicating that the current node is not in an interface or annotation block
      assertFalse(inInterfaceOrAnnotationBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInInterfaceBlock1() throws Throwable  {
      // Given: We have a DetailAST object named "arg0" that represents an interface method declaration
      DetailAST arg0 = new DetailAST();
      arg0.initialize(14, "interfaceMethod");
      
      // When: We check if the node is in an interface block using the ScopeUtils.isInInterfaceBlock() method
      boolean inInterfaceBlock = ScopeUtils.isInInterfaceBlock(arg0);
      
      // Then: The method should return false, since the node is not inside an interface block
      assertFalse(inInterfaceBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInInterfaceBlockReturningTrue() throws Throwable  {
      // Create a new DetailAST object representing an interface declaration
      DetailAST interfaceAST = new DetailAST();
      interfaceAST.addChild(interfaceAST);
      interfaceAST.initialize(15, "interface TestInterface {}");
      
      // Check if the AST node is in an interface block
      boolean inInterfaceBlock = ScopeUtils.isInInterfaceBlock(interfaceAST);
      
      // Assert that the node is indeed in an interface block
      assertTrue(inInterfaceBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInInterfaceBlockWithDetailASTWhereGetNumberOfChildrenIsZero() throws Throwable  {
      // Given a DetailAST object that represents a code block
      DetailAST ast = new DetailAST();
      
      // When we check if the current scope is in an interface block
      boolean inInterfaceBlock = ScopeUtils.isInInterfaceBlock(ast);
      
      // Then assert that we are not currently in an interface block
      assertFalse(inInterfaceBlock);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSurroundingScopeThrowsNullPointerException0() throws Throwable  {
      // Given
      DetailAST arg0 = new DetailAST();
      arg0.initialize(157, "t_3FwH");
      arg0.addChild(arg0);
      
      // When
      try {
      ScopeUtils.getSurroundingScope(arg0);
      fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      // Then
      // no message in exception (getMessage() returned null)
      verifyException("com.puppycrawl.tools.checkstyle.utils.ScopeUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSurroundingScopeThrowsNullPointerException1() throws Throwable  {
      // Given: We have a DetailAST object with an index of 15 and a value of "juw=iP-p".
      DetailAST arg0 = new DetailAST();
      arg0.initialize(15, "juw=iP-p");
      
      // When: We call the getSurroundingScope method on this DetailAST object.
      try {
      ScopeUtils.getSurroundingScope(arg0);
      
      } catch (NullPointerException e) {
      // Then: An exception is thrown because there is no surrounding scope.
      verifyException("com.puppycrawl.tools.checkstyle.utils.ScopeUtils", e);
      }
      
      // Then: The test case fails as expected.
      fail("Expecting exception: NullPointerException");
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSurroundingScopeThrowsNullPointerException2() throws Throwable  {
      DetailAST arg0 = new DetailAST();
      arg0.initialize(14, "My Test");
      // Adding a child node to the argument object
      arg0.addChild(arg0);
      try {
      ScopeUtils.getSurroundingScope(arg0);
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Verifying that the thrown exception is of type NullPointerException
      verifyException("com.puppycrawl.tools.checkstyle.utils.ScopeUtils", e);
      // Checking if the message returned by getMessage() method is null or not
      assertNull(e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSurroundingScopeThrowsTooManyResourcesException() throws Throwable  {
      // rollbacked to evosuite
      DetailAST arg0 = new DetailAST();
      arg0.addChild(arg0);
      // Undeclared exception!
      ScopeUtils.getSurroundingScope(arg0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsInScopeReturningTrue() throws Throwable  {
      // Create a new DetailAST object
      DetailAST arg0 = new DetailAST();
      
      // Check if the DetailAST is in scope of a null Scope object
      boolean inScope = ScopeUtils.isInScope(arg0, (Scope) null);
      
      // Assert that the DetailAST is indeed in scope
      assertTrue(inScope);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetScopeFromMods0() throws Throwable  {
      // Given: We have a DetailAST object with the modifiers "protected"
      DetailAST arg0 = new DetailAST();
      arg0.initialize(10, "protected");
      arg0.setFirstChild(arg0);
      
      // When: We call ScopeUtils.getScopeFromMods() on the DetailAST object
      Scope scopeFromMods = ScopeUtils.getScopeFromMods(arg0);
      
      // Then: The returned scope should be "protected"
      assertEquals(Scope.PROTECTED, scopeFromMods);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetScopeFromMods1() throws Throwable  {
      DetailAST arg0 = new DetailAST();
      arg0.addChild(arg0);
      
      // Call the getScopeFromMods method on the DetailAST and compare the result to the expected scope (Scope.PUBLIC)
      Scope scopeFromMods = ScopeUtils.getScopeFromMods(arg0);
      assertEquals(Scope.PUBLIC, scopeFromMods);
  }
}
