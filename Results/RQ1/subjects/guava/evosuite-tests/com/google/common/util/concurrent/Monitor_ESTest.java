/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 15:06:02 GMT 2024
 */

package com.google.common.util.concurrent;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.util.concurrent.Monitor;
import java.util.concurrent.TimeUnit;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.lang.MockThread;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class Monitor_ESTest extends Monitor_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWaitForUninterruptiblyTaking3ArgumentsThrowsNullPointerException() throws Throwable  {
      // Given: A monitor instance and a null guard object
      Monitor monitor = new Monitor();
      TimeUnit arg2 = TimeUnit.MICROSECONDS;
      
      // When: Calling waitForUninterruptibly with the null guard object
      try {
      monitor.waitForUninterruptibly((Monitor.Guard) null, 0L, arg2);
      
      // Then: An exception should be thrown (NullPointerException)
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Verify that the expected exception is thrown
      verifyException("com.google.common.util.concurrent.Monitor", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWaitForUninterruptiblyTakingMonitor$GuardThrowsNullPointerException() throws Throwable  {
      Monitor monitor = new Monitor();
      
      // Given that we are waiting for an uninterruptible event using a null guard
      try {
      monitor.waitForUninterruptibly(null);
      
      // Then we expect to receive a NullPointerException
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      verifyException("com.google.common.util.concurrent.Monitor", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWaitForTaking3ArgumentsThrowsNullPointerException() throws Throwable  {
      Monitor monitor = new Monitor();
      TimeUnit arg2 = TimeUnit.MINUTES;
      
      // Given: A monitor and a time unit argument
      
      try {
      // When: The waitFor method is called with a null guard and a negative timeout value
      monitor.waitFor((Monitor.Guard) null, (-1L), arg2);
      
      // Then: An exception should be thrown
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // no message in exception (getMessage() returned null)
      verifyException("com.google.common.util.concurrent.Monitor", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWaitForTakingMonitor$GuardThrowsNullPointerException() throws Throwable  {
      Monitor monitor = new Monitor(true);
      
      // Given: A monitor with a guard that is not null
      
      try {
      
      // When: Calling waitFor() with a null guard
      
      monitor.waitFor((Monitor.Guard) null);
      
      // Then: An exception should be thrown
      
      fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      
      // Given: A monitor with a guard that is not null
      
      // When: Calling waitFor() with a null guard
      
      // Then: An exception should be thrown with the expected message
      
      verifyException("com.google.common.util.concurrent.Monitor", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTryEnterIfThrowsNullPointerException() throws Throwable  {
      // Given
      Monitor monitor = new Monitor();
      Monitor.Guard guard = null; // Undeclared exception!
      
      // When
      try {
      monitor.tryEnterIf(guard);
      
      // Then
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      // no message in exception (getMessage() returned null)
      verifyException("com.google.common.util.concurrent.Monitor", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHasWaitersThrowsNullPointerException() throws Throwable  {
      // Given a Monitor instance
      Monitor monitor = new Monitor();
      
      // When attempting to check if it has waiters without providing any guard object
      try {
      monitor.hasWaiters((Monitor.Guard) null);
      fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      //
      // Verify that the correct exception is thrown when no guard object is provided
      //
      verifyException("com.google.common.util.concurrent.Monitor", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterWhenUninterruptiblyTaking3ArgumentsThrowsNullPointerException() throws Throwable  {
      // Given: a monitor and a time unit
      Monitor monitor = new Monitor();
      TimeUnit arg2 = TimeUnit.NANOSECONDS;
      
      // When: we try to call enterWhenUninterruptibly with a null guard and a positive timeout
      try {
      monitor.enterWhenUninterruptibly((Monitor.Guard) null, 1046L, arg2);
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      // Then: we expect a NullPointerException to be thrown
      verifyException("com.google.common.util.concurrent.Monitor", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterWhenUninterruptiblyTakingMonitor$GuardThrowsNullPointerException() throws Throwable  {
      Monitor monitor = new Monitor(false);
      
      // Verify that entering the monitor with a null guard throws a NullPointerException
      try {
      monitor.enterWhenUninterruptibly((Monitor.Guard) null);
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      // Verify that the thrown exception is a NullPointerException and has no message
      verifyException("com.google.common.util.concurrent.Monitor", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterWhenTaking3ArgumentsThrowsNullPointerException() throws Throwable  {
      // No Comments were added
      Monitor monitor = new Monitor();
      TimeUnit arg2 = TimeUnit.MILLISECONDS;
      // Undeclared exception!
      try { 
        monitor.enterWhen((Monitor.Guard) null, (-2086L), arg2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.util.concurrent.Monitor", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterWhenTakingMonitor$GuardThrowsNullPointerException() throws Throwable  {
      // No Comments were added
      Monitor monitor = new Monitor(false);
      // Undeclared exception!
      try { 
        monitor.enterWhen((Monitor.Guard) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.util.concurrent.Monitor", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterIfInterruptiblyTaking3ArgumentsThrowsNullPointerException() throws Throwable  {
      // Given a monitor with interruptible mode set to true
      Monitor monitor = new Monitor(true);
      
      // And a null guard object
      TimeUnit arg2 = TimeUnit.NANOSECONDS;
      
      // When the enterIfInterruptibly method is called with a null guard and a valid timeout
      try {
      monitor.enterIfInterruptibly((Monitor.Guard) null, 0L, arg2);
      fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      // Then the method should throw a NullPointerException with a message indicating that the guard is null
      verifyException("com.google.common.util.concurrent.Monitor", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterIfInterruptiblyTakingMonitor$GuardThrowsNullPointerException() throws Throwable  {
      // Arrange
      Monitor monitor = new Monitor();
      
      // Act and assert (implicitly via the expected exception)
      try {
      monitor.enterIfInterruptibly((Monitor.Guard) null);
      } catch (NullPointerException e) {
      verifyException("com.google.common.util.concurrent.Monitor", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterIfTaking3ArgumentsThrowsNullPointerException() throws Throwable  {
      Monitor monitor = new Monitor(false);
      TimeUnit arg2 = TimeUnit.HOURS;
      
      // Given: a monitor instance with the lock held by another thread
      // When: trying to enter the monitor with a null guard object
      try {
      monitor.enterIf((Monitor.Guard) null, (-2281L), arg2);
      fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      // Then: the method should throw a NullPointerException with a meaningful message
      verifyException("com.google.common.util.concurrent.Monitor", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterIfTakingMonitor$GuardThrowsNullPointerException() throws Throwable  {
      // Given: A monitor and a null guard object
      Monitor monitor = new Monitor();
      
      try {
      // When: The enterIf method is called with the null guard object
      monitor.enterIf((Monitor.Guard) null);
      
      // Then: An exception should be thrown
      fail("Expecting exception: NullPointerException");
      
      } catch (NullPointerException e) {
      // Verify that the expected exception is thrown with no message
      verifyException("com.google.common.util.concurrent.Monitor", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsOccupiedByCurrentThreadReturningTrue() throws Throwable  {
      // No Comments were added
      Monitor monitor = new Monitor();
      monitor.tryEnter();
      monitor.isOccupiedByCurrentThread();
      assertFalse(monitor.isFair());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsFairReturningTrue() throws Throwable  {
      // Given a monitor object with fairness set to true
      Monitor monitor = new Monitor(true);
      
      // When the isFair method is called on the monitor object
      boolean fair = monitor.isFair();
      
      // Then the returned value should be true
      assertTrue(fair);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOccupiedDepthReturningPositive() throws Throwable  {
      // Given: A monitor object is created with fairness set to true.
      Monitor monitor = new Monitor(true);
      
      // When: The monitor is entered using the enterInterruptibly() method.
      monitor.enterInterruptibly();
      
      // Then: The occupied depth of the monitor should be 1.
      assertEquals(1, monitor.getOccupiedDepth());
      
      // And: The monitor should be fair.
      assertTrue(monitor.isFair());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTryEnter() throws Throwable  {
      // No Comments were added
      Monitor monitor = new Monitor(false);
      monitor.tryEnter();
      monitor.tryEnter();
      monitor.leave();
      assertFalse(monitor.isFair());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterTaking2ArgumentsWithZero() throws Throwable  {
      // Given: A monitor that is not fair and an argument for entering the monitor with a timeout of 0 seconds in seconds.
      Monitor monitor = new Monitor();
      TimeUnit arg1 = TimeUnit.SECONDS;
      
      // When: The enter method is called with the given arguments.
      boolean enter = monitor.enter(0L, arg1);
      
      // Then: The isFair method should return false and the enter method should return true.
      assertFalse(monitor.isFair());
      assertTrue(enter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterTaking2ArgumentsWithPositive() throws Throwable  {
      // Given a monitor with fairness set to true and entered with nanos unit
      Monitor monitor = new Monitor(true);
      TimeUnit arg1 = TimeUnit.NANOSECONDS;
      monitor.enter(3264L, arg1);
      
      // When the isFair() method is called
      boolean actual = monitor.isFair();
      
      // Then the fairness should be true
      assertTrue(actual);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterInterruptiblyTaking2Arguments() throws Throwable  {
      // Create a new monitor object
      Monitor monitor = new Monitor();
      
      // Set the time unit to seconds for clarity
      TimeUnit arg1 = TimeUnit.SECONDS;
      
      // Test that the monitor is not fair
      assertFalse(monitor.isFair());
      
      // Enter the monitor with a negative timeout, which should block indefinitely
      monitor.enterInterruptibly(-254L, arg1);
      
      // Assert that the thread has been interrupted
      assertTrue(Thread.currentThread().isInterrupted());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsOccupiedReturningTrue() throws Throwable  {
      // No Comments were added
      Monitor monitor = new Monitor();
      monitor.tryEnter();
      monitor.isOccupied();
      assertFalse(monitor.isFair());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsFairReturningFalse() throws Throwable  {
      // Given: The monitor object is created with a fairness policy of "false"
      Monitor monitor = new Monitor(false);
      
      // When: We call the "isFair()" method on the monitor object
      boolean fair = monitor.isFair();
      
      // Then: The value returned by "isFair()" should be false
      assertFalse(fair);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterTakingNoArguments() throws Throwable  {
      // Given: A monitor instance with fairness set to false
      Monitor monitor = new Monitor(false);
      
      // When: The monitor is entered
      monitor.enter();
      
      // Then: The monitor's fairness should be false
      assertFalse(monitor.isFair());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsOccupiedByCurrentThreadReturningFalse() throws Throwable  {
      // rollbacked to evosuite
      Monitor monitor = new Monitor();
      monitor.isOccupiedByCurrentThread();
      assertFalse(monitor.isFair());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEnterInterruptiblyTakingNoArguments() throws Throwable  {
      // Given a monitor object
      Monitor monitor = new Monitor();
      
      // When the monitor is entered interruptibly
      monitor.enterInterruptibly();
      
      // Then the monitor should not be fair
      assertFalse(monitor.isFair());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHasQueuedThreads() throws Throwable  {
      // Arrange
      Monitor monitor = new Monitor();
      
      // Act
      boolean hasQueuedThreads = monitor.hasQueuedThreads();
      
      // Assert
      assertFalse(monitor.isFair());
      assertFalse(hasQueuedThreads);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsOccupiedReturningFalse() throws Throwable  {
      // Given
      Monitor monitor = new Monitor();
      monitor.isOccupied();
      
      // When
      boolean isFair = monitor.isFair();
      
      // Then
      assertFalse(isFair);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetOccupiedDepthReturningZero() throws Throwable  {
      // Given: A monitor is created as an unfair monitor
      Monitor monitor = new Monitor(false);
      
      // When: The occupied depth of the monitor is retrieved
      int occupiedDepth = monitor.getOccupiedDepth();
      
      // Then: The occupied depth should be 0, since no thread has entered the monitor yet
      assertEquals(occupiedDepth, 0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHasQueuedThread() throws Throwable  {
      // Given: A monitor object with fairness set to false
      Monitor monitor = new Monitor(false);
      
      // And: A thread object that will be used as an argument for the hasQueuedThread method
      MockThread arg0 = new MockThread("");
      
      // When: The hasQueuedThread method is called with the given thread as an argument
      monitor.hasQueuedThread(arg0);
      
      // Then: The result of the method call should be false, since the monitor does not have any threads queued
      assertFalse(monitor.isFair());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetQueueLength() throws Throwable  {
      // Given
      Monitor monitor = new Monitor();
      
      // When
      int queueLength = monitor.getQueueLength();
      
      // Then
      assertFalse(monitor.isFair());
  }
}
