/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 14:38:50 GMT 2024
 */

package com.google.common.math;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.math.BigIntegerMath;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.util.LinkedList;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class BigIntegerMath_ESTest extends BigIntegerMath_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testListProductTaking3Arguments() throws Throwable  {
      // Given: A LinkedList of BigIntegers containing the values 1686
      LinkedList<BigInteger> arg0 = new LinkedList<>();
      arg0.add(BigInteger.valueOf(1686));
      
      // When: The listProduct method is called with an empty list and a number
      BigInteger listProduct = BigIntegerMath.listProduct(arg0, 1686, 1686);
      
      // Then: The result should be the product of all the numbers in the list, which is 1
      assertEquals((short)1, listProduct.shortValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFitsInLongReturningTrue() throws Throwable  {
      // Given a BigInteger value
      BigInteger arg0 = BigInteger.ZERO;
      
      // When we check if it fits in a long integer
      boolean fitsInLong = BigIntegerMath.fitsInLong(arg0);
      
      // Then the result should be true
      assertTrue(fitsInLong);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFitsInLongReturningFalse() throws Throwable  {
      // Given a value of BigInteger Math.SQRT2_PRECOMPUTED_BITS
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      
      // When the fitsInLong method is called with this value
      boolean fitsInLong = BigIntegerMath.fitsInLong(arg0);
      
      // Then the result should be false, as SQRT2_PRECOMPUTED_BITS is a large value that cannot fit in a long integer
      assertFalse(fitsInLong);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFactorialReturningBigIntegerWhereShortValueIsNegative() throws Throwable  {
      // Test that the factorial function returns the correct value for 8!
      BigInteger factorial = BigIntegerMath.factorial(8);
      assertEquals((short) (-25216), factorial.shortValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFactorialReturningBigIntegerWhereByteValueIsNegativeAndBigIntegerWhereShortValueIsPositive() throws Throwable  {
      // Test the factorial function with a byte value of 6
      BigInteger factorial = BigIntegerMath.factorial((byte)6);
      
      // Assert that the result is equal to 720 (short value)
      assertEquals((short)720, factorial.shortValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideReturningBigIntegerWhereByteValueIsZero() throws Throwable  {
      // No Comments were added
      BigInteger arg0 = BigIntegerMath.factorial(2205);
      BigInteger bigInteger = BigInteger.ZERO;
      BigInteger arg1 = bigInteger.flipBit(1295);
      RoundingMode arg2 = RoundingMode.HALF_EVEN;
      BigInteger divide = BigIntegerMath.divide(arg0, arg1, arg2);
      assertNotSame(divide, bigInteger);
      assertEquals((byte)0, divide.byteValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideReturningBigIntegerWhereByteValueIsPositive() throws Throwable  {
      // Given a large integer value
      BigInteger arg1 = BigIntegerMath.factorial(2205);
      
      // When we divide it by itself with rounding mode HALF_EVEN
      RoundingMode arg2 = RoundingMode.HALF_EVEN;
      BigInteger dividedValue = BigIntegerMath.divide(arg1, arg1, arg2);
      
      // Then the result should be 1
      assertEquals((byte)1, dividedValue.byteValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBinomialReturningBigIntegerWhereByteValueIsZero() throws Throwable  {
      // Given: A large number (1000000000) and an exponent (3)
      BigInteger binomial = BigIntegerMath.binomial(1000000000, 3);
      
      // When: The binomial coefficient is computed using the BigIntegerMath class
      BigInteger actual = BigIntegerMath.binomial(1000000000, 3);
      
      // Then: The result should be a short value with the expected value
      assertEquals((short) (-4608), binomial.shortValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBinomialReturningBigIntegerWhereByteValueIsNegative() throws Throwable  {
      // Test that the binomial coefficient C(10000, 47) is correct
      BigInteger binomial = BigIntegerMath.binomial(10000, 47);
      assertEquals((short)21120, binomial.shortValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBinomialReturningBigIntegerWhereByteValueIsPositive() throws Throwable  {
      // Test that the binomial coefficient calculation for 1181,1181 is correct.
      BigInteger arg0 = BigIntegerMath.binomial(1181, 1181);
      RoundingMode arg1 = RoundingMode.FLOOR;
      int log2 = BigIntegerMath.log2(arg0, arg1);
      assertEquals((byte)1, arg0.byteValue()); // Assert that the result is a byte with value 1.
      assertEquals(0, log2); // Assert that the logarithm base 2 of the result is 0.
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBinomialThrowsIllegalArgumentException() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        BigIntegerMath.binomial(5, 10);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // k (10) > n (5)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testListProductTakingList() throws Throwable  {
      // Given: A LinkedList of BigIntegers containing a single null element
      LinkedList<BigInteger> arg0 = new LinkedList<>();
      arg0.add((BigInteger) null);
      
      // When: The listProduct method is called on the LinkedList
      BigInteger listProduct = BigIntegerMath.listProduct(arg0);
      
      // Then: The result should be null, as the list contains a single null element
      assertNull(listProduct);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFactorial0() throws Throwable  {
      // Given a value for n (in this case, 128), compute its factorial using BigIntegerMath.factorial()
      BigInteger factorial = BigIntegerMath.factorial(128);
      
      // When computing the factorial of n
      byte result = factorial.byteValue();
      
      // Then assert that the result is equal to 0
      assertEquals((byte)0, result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFactorialReturningBigIntegerWhereByteValueIsPositive() throws Throwable  {
      // Calculate the factorial of 5 using the BigIntegerMath class
      BigInteger factorial = BigIntegerMath.factorial(5);
      
      // Assert that the result is equal to the expected value
      assertEquals((byte)120, factorial.byteValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSqrtReturningBigIntegerWhereByteValueIsPositive() throws Throwable  {
      // Calculate the square root of 34! using the HALF_EVEN rounding mode
      BigInteger arg0 = BigIntegerMath.factorial((byte) 34);
      RoundingMode arg1 = RoundingMode.HALF_EVEN;
      BigInteger sqrt = BigIntegerMath.sqrt(arg0, arg1);
      
      // Assert that the result is equal to 54 when converted to a byte value
      assertEquals((byte) 54, sqrt.byteValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSqrt0() throws Throwable  {
      // Given a BigInteger value for which we want to calculate the square root
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      
      // When we call the sqrt method with the given value and rounding mode HALF_UP
      RoundingMode arg1 = RoundingMode.HALF_UP;
      BigInteger sqrt = BigIntegerMath.sqrt(arg0, arg1);
      
      // Then we expect the result to be a short value of -4627
      assertEquals((short) (-4627), sqrt.shortValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSqrtWithBigIntegerWhereByteValueIsZeroAndBigIntegerWhereShortValueIsZero() throws Throwable  {
      // Given a large number 2922
      BigInteger input = BigIntegerMath.factorial(2922);
      
      // When we calculate its square root using the CEILING rounding mode
      RoundingMode roundingMode = RoundingMode.CEILING;
      BigInteger sqrt = BigIntegerMath.sqrt(input, roundingMode);
      
      // Then we expect the result to be -75
      assertEquals((byte) (-75), sqrt.byteValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDivideReturningBigIntegerWhereByteValueIsNegative() throws Throwable  {
      // No Comments were added
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      RoundingMode arg2 = RoundingMode.FLOOR;
      BigInteger arg1 = BigIntegerMath.sqrt(arg0, arg2);
      BigInteger divide = BigIntegerMath.divide(arg0, arg1, arg2);
      assertEquals((short) (-4627), divide.shortValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSqrt1() throws Throwable  {
      // Arrange
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      RoundingMode arg1 = RoundingMode.DOWN;
      
      // Act
      BigInteger sqrt = BigIntegerMath.sqrt(arg0, arg1);
      
      // Assert
      assertEquals((byte) (-20), sqrt.byteValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSqrtThrowsArithmeticException() throws Throwable  {
      // Given: A big integer representing the square root of 2 with a precomputed number of bits
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      // And: A rounding mode set to UNNECESSARY
      RoundingMode arg1 = RoundingMode.UNNECESSARY;
      try {
      // When: Calculating the square root of 2 with the precomputed number of bits and the UNNECESSARY rounding mode
      BigInteger result = BigIntegerMath.sqrt(arg0, arg1);
      // Then: An exception is thrown because the rounding was unnecessary
      fail("Expecting exception: ArithmeticException");
      } catch (ArithmeticException e) {
      // Verify that the expected exception is thrown
      verifyException("com.google.common.math.MathPreconditions", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSqrtReturningBigIntegerWhereByteValueIsZero() throws Throwable  {
      // Arrange
      BigInteger arg0 = BigInteger.ZERO;
      RoundingMode arg1 = RoundingMode.UP;
      
      // Act
      BigInteger sqrt = BigIntegerMath.sqrt(arg0, arg1);
      
      // Assert
      assertEquals((short) 0, sqrt.shortValue());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFactorialAndLog100() throws Throwable  {
      // Calculate the factorial of 2205 using BigIntegerMath and rounding mode HALF_EVEN.
      BigInteger arg0 = BigIntegerMath.factorial(2205);
      RoundingMode arg1 = RoundingMode.HALF_EVEN;
      
      // Calculate the logarithm of the factorial to base 10 using BigIntegerMath and rounding mode HALF_EVEN.
      int log10 = BigIntegerMath.log10(arg0, arg1);
      
      // Assert that the logarithm of the factorial is equal to 6417.
      assertEquals(6417, log10);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog100() throws Throwable  {
      // Given a number that is close to the square root of 2
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      
      // When computing its logarithm in base 10 with rounding mode HALF_EVEN
      RoundingMode arg1 = RoundingMode.HALF_EVEN;
      int log10 = BigIntegerMath.log10(arg0, arg1);
      
      // Then the result should be approximately 77
      assertEquals(77, log10);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog101() throws Throwable  {
      // Given a BigInteger "arg0" and a RoundingMode "arg1",
      // When the log10 method is called with these arguments,
      // Then the return value should be 77.
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      RoundingMode arg1 = RoundingMode.HALF_UP;
      int log10 = BigIntegerMath.log10(arg0, arg1);
      assertEquals(77, log10);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog102() throws Throwable  {
      // Given: a value for SQRT2_PRECOMPUTED_BITS and HALF_DOWN rounding mode
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      RoundingMode arg1 = RoundingMode.HALF_DOWN;
      
      // When: the log10 method is called with these arguments
      int log10 = BigIntegerMath.log10(arg0, arg1);
      
      // Then: the result should be 77
      assertEquals(77, log10);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog103() throws Throwable  {
      // Given a large number to calculate the logarithm of, and the rounding mode to use.
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      RoundingMode arg1 = RoundingMode.FLOOR;
      
      // When we call the log10 method with the given number and rounding mode.
      int log10 = BigIntegerMath.log10(arg0, arg1);
      
      // Then the result should be 77, which is the logarithm of the given number to base 10 with the specified rounding mode.
      assertEquals(77, log10);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog104() throws Throwable  {
      // Given a number that is the square root of 2, rounded down to an integer
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      RoundingMode arg1 = RoundingMode.DOWN;
      
      // When the log10 of this number is calculated with a rounding mode of "down"
      int log10 = BigIntegerMath.log10(arg0, arg1);
      
      // Then the result should be 77
      assertEquals(77, log10);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog10ThrowsArithmeticException() throws Throwable  {
      // Given: A big integer factorial of 77 is being calculated
      BigInteger arg0 = BigIntegerMath.factorial(77);
      
      // When: The log10 of the big integer is calculated with an undeclared exception expected
      RoundingMode arg1 = RoundingMode.UNNECESSARY;
      try {
      BigIntegerMath.log10(arg0, arg1);
      fail("Expecting exception: ArithmeticException");
      
      } catch(ArithmeticException e) {
      //
      // mode was UNNECESSARY, but rounding was necessary
      //
      verifyException("com.google.common.math.MathPreconditions", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFactorialAndLog101() throws Throwable  {
      BigInteger arg0 = BigIntegerMath.factorial((byte) 94);
      RoundingMode arg1 = RoundingMode.UP;
      int log10 = BigIntegerMath.log10(arg0, arg1);
      assertEquals(147, log10); // The returned value should be the log10 of the factorial of 94, rounded up to the nearest integer.
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog105() throws Throwable  {
      // No Comments were added
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      RoundingMode arg1 = RoundingMode.CEILING;
      int log10 = BigIntegerMath.log10(arg0, arg1);
      assertEquals(78, log10);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFactorialAndLog20() throws Throwable  {
      // Calculate the factorial of 34 using the BigIntegerMath class
      BigInteger arg0 = BigIntegerMath.factorial((byte)34);
      
      // Use the log2 method to calculate the logarithm base 2 of the factorial
      RoundingMode arg1 = RoundingMode.HALF_DOWN;
      int log2 = BigIntegerMath.log2(arg0, arg1);
      
      // Assert that the result is equal to 128
      assertEquals(128, log2);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog20() throws Throwable  {
      // Given a BigInteger value representing SQRT(2) with half-even rounding
      BigInteger sqrt2 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      
      // When we calculate the logarithm of this value with half-even rounding
      RoundingMode mode = RoundingMode.HALF_EVEN;
      int log2 = BigIntegerMath.log2(sqrt2, mode);
      
      // Then the result should be 256, which is the logarithm of SQRT(2) with half-even rounding
      assertEquals(256, log2);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFactorialAndLog21() throws Throwable  {
      // Given
      BigInteger arg0 = BigIntegerMath.factorial(2205);
      RoundingMode arg1 = RoundingMode.HALF_UP;
      
      // When
      int log2 = BigIntegerMath.log2(arg0, arg1);
      
      // Then
      assertEquals(21316, log2);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog21() throws Throwable  {
      // Given: A BigInteger value of 10 and a RoundingMode of HALF_DOWN
      BigInteger arg0 = BigInteger.TEN;
      RoundingMode arg1 = RoundingMode.HALF_DOWN;
      
      // When: The log2 function is called with the given arguments
      int log2 = BigIntegerMath.log2(arg0, arg1);
      
      // Then: The result of the log2 function should be 3
      assertEquals(3, log2);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog2ReturningZero() throws Throwable  {
      // Given: A positive integer and a rounding mode
      BigInteger input = BigInteger.ONE;
      RoundingMode roundingMode = RoundingMode.CEILING;
      
      // When: The log2 function is called with the input and rounding mode
      int actualOutput = BigIntegerMath.log2(input, roundingMode);
      
      // Then: The output should be 0, as the log2 of 1 with CEILING rounding is 0
      assertEquals(0, actualOutput);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog22() throws Throwable  {
      // Given
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      RoundingMode arg1 = RoundingMode.UP;
      
      // When
      int log2 = BigIntegerMath.log2(arg0, arg1);
      
      // Then
      assertEquals(257, log2);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog23() throws Throwable  {
      // Given a BigInteger value that represents the square root of 2
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      
      // When we calculate the logarithm of this value with a rounding mode of DOWN
      RoundingMode arg1 = RoundingMode.DOWN;
      int log2 = BigIntegerMath.log2(arg0, arg1);
      
      // Then the result should be 256
      assertEquals(256, log2);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLog2ThrowsArithmeticException() throws Throwable  {
      // No Comments were added
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      RoundingMode arg1 = RoundingMode.UNNECESSARY;
      // Undeclared exception!
      try { 
        BigIntegerMath.log2(arg0, arg1);
        fail("Expecting exception: ArithmeticException");
      
      } catch(ArithmeticException e) {
         //
         // mode was UNNECESSARY, but rounding was necessary
         //
         verifyException("com.google.common.math.MathPreconditions", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsPowerOfTwoReturningFalse() throws Throwable  {
      // Given a value that is not a power of two
      BigInteger arg0 = BigIntegerMath.SQRT2_PRECOMPUTED_BITS;
      
      // When we check if it is a power of two
      boolean powerOfTwo = BigIntegerMath.isPowerOfTwo(arg0);
      
      // Then the result should be false
      assertFalse(powerOfTwo);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsPowerOfTwoReturningTrue() throws Throwable  {
      // Given: a BigInteger value of 1
      BigInteger arg0 = BigInteger.ONE;
      
      // When: the isPowerOfTwo method is called with the above BigInteger value
      boolean powerOfTwo = BigIntegerMath.isPowerOfTwo(arg0);
      
      // Then: the result should be true, as 1 is a power of two
      assertTrue(powerOfTwo);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFactorial1() throws Throwable  {
      // Arrange
      BigInteger factorial = BigIntegerMath.factorial(47);
      
      // Act
      short result = factorial.shortValue();
      
      // Assert
      assertEquals((short)0, result);
  }
}
