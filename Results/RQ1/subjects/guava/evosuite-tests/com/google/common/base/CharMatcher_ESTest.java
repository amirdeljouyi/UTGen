/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 16:57:24 GMT 2024
 */

package com.google.common.base;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.base.CharMatcher;
import com.google.common.base.Predicates;
import com.google.common.base.SmallCharMatcher;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.util.BitSet;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class CharMatcher_ESTest extends CharMatcher_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesReturningTrue() throws Throwable  {
      // Given a CharMatcher object that matches any whitespace character
      CharMatcher noneOf = CharMatcher.noneOf(" \t\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680");
      
      // When the matches method is called with a character 'W'
      boolean matches = noneOf.matches('W');
      
      // Then the CharMatcher object should return false, as 'W' is not a whitespace character
      assertEquals("CharMatcher.anyOf(\"\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u0085\\u00A0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\").negate()", noneOf.toString());
      assertTrue(matches);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesReturningFalse() throws Throwable  {
      // Given a CharMatcher that matches any character that is not 'O'
      CharMatcher not = CharMatcher.isNot('O');
      
      // When we check if the matcher matches the character 'O'
      boolean matches = not.matches('O');
      
      // Then we expect the matcher to return false, since 'O' does not match the criteria defined by the matcher
      assertFalse(matches);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLastIndexInReturningZero() throws Throwable  {
      CharMatcher arg1 = CharMatcher.inRange('!', '!', "h");
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher("h", arg1);
      int lastIndexIn = charMatcher_NegatedFastMatcher.lastIndexIn("h");
      assertEquals(0, lastIndexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTakingCharSequenceReturningPositive() throws Throwable  {
      // Given: a CharMatcher object that matches ASCII characters
      CharMatcher charMatcher = CharMatcher.ASCII;
      
      // And: a CharBuffer containing a sequence of characters with non-ASCII and ASCII characters
      CharBuffer arg0 = CharBuffer.wrap((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      
      // When: the indexIn() method is called on the CharMatcher object with the CharBuffer as an argument
      int indexIn = charMatcher.indexIn((CharSequence) arg0);
      
      // Then: the indexIn() method returns 2, which is the index of the first non-ASCII character in the sequence of characters
      assertEquals(2, indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCountInReturningZero() throws Throwable  {
      // This test verifies that the CharMatcher correctly identifies digits in a string of characters
      // Set up a CharMatcher to match Java digits
      CharMatcher charMatcher = CharMatcher.JAVA_DIGIT;
      
      // Create a ByteBuffer and allocate enough space for 1470 characters
      ByteBuffer allocate = ByteBuffer.allocate(1470);
      
      // Convert the ByteBuffer to a CharBuffer
      CharBuffer arg0 = allocate.asCharBuffer();
      
      // Count the number of digits in the CharBuffer
      int countIn = charMatcher.countIn(arg0);
      
      // Assert that there are no digits in the string
      assertEquals(0, countIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testApplyReturningFalse() throws Throwable  {
      // Tests the "apply" method of the "inRange" CharMatcher
      // with a character that is within the specified range
      
      CharMatcher inRange = CharMatcher.inRange(' ', ' ');
      Character arg0 = Character.valueOf('\"');
      boolean apply = inRange.apply(arg0);
      assertFalse(apply);
      
      // This test ensures that the "inRange" CharMatcher
      // returns false for a character that is within the specified range);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking1And1ReturningEmptyString() throws Throwable  {
      // Given a CharMatcher inRange that matches all characters between 'M' and '~'
      CharMatcher inRange = CharMatcher.inRange('M', '~', "");
      
      // When we call replaceFrom on the empty string with the character 'u'
      String replacedString = inRange.replaceFrom("", 'u');
      
      // Then we expect an empty string to be returned
      assertEquals("", replacedString);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTaking2ArgumentsReturningZero() throws Throwable  {
      // Given a CharMatcher for letters between H and H
      CharMatcher arg1 = CharMatcher.inRange('H', 'H');
      
      // When a NegatedFastMatcher is created for the given CharMatcher
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher("7$/^9wC", arg1);
      
      // Then the NegatedFastMatcher should match the given string at index 0
      assertEquals(0, charMatcher_NegatedFastMatcher.indexIn((CharSequence) "L2geuV7Gl&~Si!%", (int) (byte)0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInRangeTaking3Arguments() throws Throwable  {
      // Test that the `inRange` matcher correctly identifies characters within a given range
      CharMatcher inRange = CharMatcher.inRange('M', 'M');
      CharBuffer arg0 = CharBuffer.allocate(244);
      int indexIn = inRange.indexIn((CharSequence) arg0, 4);
      assertEquals((-1), indexIn);
      // Assert that the matcher returns -1 when there are no characters within the range
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveFrom0() throws Throwable  {
      // Create a CharMatcher that matches upper case characters
      CharMatcher charMatcher = CharMatcher.JAVA_UPPER_CASE;
      
      // Remove all whitespace characters from the input string
      String removeFrom = charMatcher.WHITESPACE.removeFrom(" \t\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680");
      
      // Assert that the output is empty
      assertEquals("", removeFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsNotAndOrAndIsNotWithOtherChar0() throws Throwable  {
      // Given a CharMatcher that matches any character that is not '>',
      CharMatcher not = CharMatcher.isNot('>');
      
      // When we create a new CharMatcher by combining it with whitespace characters,
      CharMatcher arg0 = CharMatcher.WHITESPACE;
      CharMatcher or = not.or(arg0);
      
      // Then the resulting CharMatcher should be equal to the original one,
      assertSame(or, not);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimAndCollapseFromReturningNonEmptyString() throws Throwable  {
      // rollbacked to evosuite
      CharMatcher arg1 = CharMatcher.ASCII;
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher(")Wi*huDIZM6uz&do", arg1);
      String trimAndCollapseFrom = charMatcher_NegatedFastMatcher.JAVA_LETTER_OR_DIGIT.trimAndCollapseFrom(")Wi*huDIZM6uz&do", 'N');
      assertEquals(")N*N&", trimAndCollapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNegatedFastMatcherTakingCharMatcherAndCallsCollapseFrom() throws Throwable  {
      // Given: A CharMatcher that matches any letter in the Java language
      CharMatcher arg0 = CharMatcher.JAVA_LETTER;
      
      // When: We create a NegatedFastMatcher from the letter matcher
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher(arg0);
      
      // Then: We assert that the negated fast matcher collapses a string with any non-letter characters to a string with only letters
      String collapseFrom = charMatcher_NegatedFastMatcher.collapseFrom(".ZSQ`&74.g=XIL]", '.');
      assertEquals(".ZSQ.g.XIL.", collapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCollapseFrom0() throws Throwable  {
      // No Comments were added
      CharMatcher charMatcher = CharMatcher.ASCII;
      String collapseFrom = charMatcher.JAVA_ISO_CONTROL.collapseFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", 'n');
      assertEquals("\u2002\u3000n\u200A\u2005\u2000\u3000\u2029n\u3000\u2008\u2003\u205F\u3000\u1680n \u2006\u2001\u202F\u00A0n\u2009\u3000\u2004\u3000\u3000\u2028n\u2007\u3000", collapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimTrailingFromReturningNonEmptyString() throws Throwable  {
      // Test to ensure that the CharMatcher.JAVA_ISO_CONTROL matches all control characters in a string
      CharMatcher charMatcher = CharMatcher.JAVA_ISO_CONTROL;
      String testString = "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000";
      String trimTrailingFrom = charMatcher.trimTrailingFrom(testString);
      assertEquals("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", trimTrailingFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimTrailingFromReturningEmptyString() throws Throwable  {
      // Create a CharMatcher that matches any of the whitespace characters
      CharMatcher anyOf = CharMatcher.anyOf("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      
      // Trim the trailing whitespace from a string
      String trimTrailingFrom = anyOf.trimTrailingFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      
      // Assert that the result is an empty string
      assertEquals("", trimTrailingFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimLeadingFromReturningEmptyString() throws Throwable  {
      // Create a CharMatcher that matches any of the characters in "fA]G[syzt"
      CharMatcher anyOf = CharMatcher.anyOf("fA]G[syzt");
      
      // Use the trimLeadingFrom method to remove the leading characters from the string "fA]G[syzt"
      String trimLeadingFrom = anyOf.trimLeadingFrom("fA]G[syzt");
      
      // Assert that the result is an empty string
      assertEquals("", trimLeadingFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimFromAndTrimFromReturningNonEmptyString0() throws Throwable  {
      // Given a CharMatcher instance that matches any letter character in Java
      CharMatcher charMatcher = CharMatcher.JAVA_LETTER;
      
      // When the "trimFrom" method is called with a string containing letter characters
      String trimFrom = charMatcher.trimFrom("CharMatcher.JAVA_LETTER");
      
      // Then the returned string should be the part of the input string that does not contain any letter characters
      assertEquals(".JAVA_", trimFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimFromAndTrimFromReturningEmptyString0() throws Throwable  {
      // Create a CharMatcher that matches ASCII characters
      CharMatcher charMatcher = CharMatcher.ASCII;
      
      // Trim whitespace from the start and end of the string
      String trimmedString = charMatcher.trimFrom("A string with some whitespace at the start and end");
      
      // Assert that the trimmed string is empty
      assertEquals("", trimmedString);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking2CharSequencesReturningEmptyString() throws Throwable  {
      // Given a CharMatcher instance with the JAVA_DIGIT pattern
      CharMatcher charMatcher = CharMatcher.JAVA_DIGIT;
      
      // And a byte array containing some ASCII characters
      byte[] arg0 = new byte[0];
      
      // When we wrap the byte array in a ByteBuffer and then convert it to a CharBuffer
      ByteBuffer wrap = ByteBuffer.wrap(arg0);
      CharBuffer arg1 = wrap.asCharBuffer();
      
      // And we use the CharMatcher instance to replace all ASCII digits in the CharBuffer with empty strings
      String replaceFrom = charMatcher.ASCII.replaceFrom((CharSequence) arg1, (CharSequence) arg1);
      
      // Then the result should be an empty string
      assertEquals("", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking2CharSequencesWithNonNullAndNonNull() throws Throwable  {
      // Given
      CharMatcher charMatcher = CharMatcher.INVISIBLE;
      char[] arg0 = new char[1];
      arg0[0] = 'y';
      CharBuffer arg1 = CharBuffer.wrap(arg0);
      
      // When
      String replaceFrom = charMatcher.replaceFrom((CharSequence) arg1, (CharSequence) arg1);
      
      // Then
      assertEquals("y", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLastIndexInReturningPositive() throws Throwable  {
      // Given
      CharMatcher charMatcher = CharMatcher.ASCII;
      CharBuffer arg0 = CharBuffer.wrap((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      
      // When
      int lastIndexIn = charMatcher.lastIndexIn(arg0);
      
      // Then
      assertEquals(29, lastIndexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLastIndexInWithNonNull() throws Throwable  {
      // Given an empty CharBuffer containing only whitespace characters
      CharMatcher charMatcher = CharMatcher.BREAKING_WHITESPACE;
      CharBuffer arg0 = CharBuffer.allocate(0);
      
      // When the lastIndexIn method is called with the CharBuffer
      int lastIndexIn = charMatcher.ASCII.lastIndexIn(arg0);
      
      // Then the method should return -1, indicating that no whitespace character was found
      assertEquals((-1), lastIndexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking2CharSequences0() throws Throwable  {
      // rollbacked to evosuite
      CharMatcher charMatcher = CharMatcher.SINGLE_WIDTH;
      String replaceFrom = charMatcher.replaceFrom((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", (CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000\u1680\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAllOfAndMatchesAllOfWithCharSequenceWhereLengthIsPositive() throws Throwable  {
      // This test checks if the CharMatcher JAVA_LETTER matches all of the given string "hello world"
      CharMatcher charMatcher = CharMatcher.JAVA_LETTER;
      boolean matchesAllOf = charMatcher.matchesAllOf("hello world");
      assertFalse(matchesAllOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAllOfAndMatchesAllOfReturningTrue() throws Throwable  {
      // Given a CharMatcher that matches ASCII characters, and a ByteBuffer with 1595 bytes of data.
      CharMatcher charMatcher = CharMatcher.ANY;
      ByteBuffer allocate = ByteBuffer.allocate(1595);
      
      // When we check if the CharMatcher matches all of the characters in the ByteBuffer.
      boolean matchesAllOf = charMatcher.matchesAllOf(allocate.asCharBuffer());
      
      // Then we expect the method to return true, since all 1595 characters in the ByteBuffer are ASCII.
      assertTrue(matchesAllOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedInternal0() throws Throwable  {
      // Given a CharMatcher instance, "charMatcher"
      CharMatcher charMatcher = CharMatcher.WHITESPACE;
      
      // When the "precomputedInternal()" method is called on the CharMatcher instance
      CharMatcher precomputedInternal = charMatcher.precomputedInternal();
      
      // Then, a new CharMatcher instance is returned with the same behavior as the original instance
      assertEquals("WHITESPACE", precomputedInternal.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedInternal1() throws Throwable  {
      // rollbacked to evosuite
      BitSet arg0 = new BitSet(55539);
      SmallCharMatcher from = (SmallCharMatcher)SmallCharMatcher.from(arg0, "O/sX*Q]|]d#GgP>]az");
      CharMatcher.NegatedFastMatcher precomputedInternal = (CharMatcher.NegatedFastMatcher)from.precomputedInternal();
      assertNotNull(precomputedInternal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCountIn() throws Throwable  {
      // Given a CharMatcher that matches Java ISO control characters
      CharMatcher charMatcher = CharMatcher.JAVA_ISO_CONTROL;
      
      // When the countIn method is called with a string containing some control characters
      int countIn = charMatcher.countIn("\u0001\t \n\r");
      
      // Then the correct number of control characters should be counted
      assertEquals(5, countIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForPredicate() throws Throwable  {
      // Create a CharMatcher that matches invisible characters
      CharMatcher invisibleCharMatcher = CharMatcher.INVISIBLE;
      
      // Use the forPredicate method to create a new CharMatcher based on the given predicate
      CharMatcher forInvisibleChars = CharMatcher.forPredicate(invisibleCharMatcher);
      
      // Assert that the two matchers are the same instance (i.e., they refer to the same object)
      assertSame(forInvisibleChars, invisibleCharMatcher);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInRangeTaking2ArgumentsThrowsIllegalArgumentException() throws Throwable  {
      // Test that a CharMatcher throws an exception when constructed with invalid arguments
      try {
      // Attempt to create a CharMatcher with a lower bound that is greater than the upper bound
      CharMatcher.inRange('m', 'H');
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      // Verify that the exception was thrown as expected
      verifyException("com.google.common.base.Preconditions", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNoneOfAndPrecomputedInternal() throws Throwable  {
      // Test that noneOf() creates a CharMatcher that does not match any character in the given string
      CharMatcher noneOf = CharMatcher.noneOf(".ZSQ`&74.g=XIL]");
      CharMatcher precomputedInternal = noneOf.precomputedInternal();
      assertEquals("CharMatcher.anyOf(\"\\u0026\\u002E\\u002E\\u0034\\u0037\\u003D\\u0049\\u004C\\u0051\\u0053\\u0058\\u005A\\u005D\\u0060\\u0067\").negate()", precomputedInternal.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTakingCharSequenceAndNoneOf() throws Throwable  {
      // Test that CharMatcher.noneOf() correctly matches all whitespace characters
      CharMatcher noneOf = CharMatcher.noneOf("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      int indexIn = noneOf.indexIn((CharSequence) "CharMatcher.or(");
      assertEquals(0, indexIn); // Expect the match to start at index 0
      assertEquals("CharMatcher.anyOf(\"\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u0085\\u00A0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\").negate()", noneOf.toString()); // Expect the match to be the negation of the CharMatcher.anyOf() instance
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsNotAndOrAndIsNotWithOtherChar1() throws Throwable  {
      // Arrange
      CharMatcher not = CharMatcher.isNot('>');
      CharMatcher arg0 = CharMatcher.SINGLE_WIDTH;
      
      // Act
      CharMatcher or = not.or(arg0);
      
      // Assert
      assertFalse(or.equals((Object)arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAndAndIsNot() throws Throwable  {
      // Given a CharMatcher "not" that matches any character that is not 'N'
      CharMatcher not = CharMatcher.isNot('N');
      
      // And a CharMatcher "arg0" that matches any Java letter or digit
      CharMatcher arg0 = CharMatcher.JAVA_LETTER_OR_DIGIT;
      
      // When we create a new CharMatcher by applying the "and" operation on "not" and "arg0"
      CharMatcher and = not.and(arg0);
      
      // Then the resulting CharMatcher should match any character that is not 'N' and also matches any Java letter or digit
      assertEquals("CharMatcher.and(CharMatcher.isNot('\\u004E'), CharMatcher.JAVA_LETTER_OR_DIGIT)", and.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimAndCollapseFromWithNonNull() throws Throwable  {
      // Given: A CharMatcher object that matches any character that is not an 'h'
      CharMatcher not = CharMatcher.isNot('h');
      
      // When: The CharMatcher is applied to a CharBuffer that contains a string with mixed whitespace characters and some non-whitespace characters
      CharBuffer arg0 = CharBuffer.wrap((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      
      // Then: The trimAndCollapseFrom method is called on the CharBuffer with a character that is not present in the buffer, which should result in an empty string being returned.
      String trimAndCollapseFrom = not.trimAndCollapseFrom(arg0, 'h');
      assertEquals("", trimAndCollapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInRangeTaking3ArgumentsWithDigit() throws Throwable  {
      // Given a CharMatcher with the range of characters ' ' to '_'
      CharMatcher inRange = CharMatcher.inRange(' ', ' ');
      
      // And a precomputed internal CharMatcher that matches any character between 'K' and '6'
      CharMatcher precomputedInternal = inRange.precomputedInternal();
      
      // When we create an or operator with the first matcher and the second matcher
      CharMatcher or = precomputedInternal.or(CharMatcher.inRange('K', '6'));
      
      // Then the resulting CharMatcher should match any character between ' ' and '_' OR any character between 'K' and '6'
      assertEquals("CharMatcher.or(CharMatcher.is('\\u0020'), CharMatcher.inRange('K', '6'))", or.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInRangeTaking2Arguments() throws Throwable  {
      // Given two CharMatcher instances, arg0 and arg1, where arg0 is in the range of ' ' to ' ',
      // and arg1 is also in the range of ' ' to ' '.
      CharMatcher arg0 = CharMatcher.inRange(' ', ' ');
      CharMatcher arg1 = CharMatcher.inRange(' ', ' ');
      
      // When the method precomputedInternal() is called on both instances,
      // and the and operator is applied to both results,
      CharMatcher and0 = arg0.precomputedInternal().and(arg1);
      CharMatcher and1 = arg1.precomputedInternal().and(arg0);
      
      // Then the result of applying the and operator to both instances should be the same.
      assertSame(and0, and1);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAndAndIsAndIsNot() throws Throwable  {
      // Given two CharMatchers, arg0 and is, which both match the character '>'
      CharMatcher arg0 = CharMatcher.isNot('>');
      CharMatcher is = CharMatcher.is('>');
      
      // When we use the and method to combine them into a new CharMatcher
      CharMatcher and = is.and(arg0);
      
      // Then the resulting CharMatcher should not equal the original arg0 CharMatcher
      assertFalse(and.equals((Object)arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsAndOr() throws Throwable  {
      // Given: a CharMatcher that matches '<' and another one that also matches '<'
      CharMatcher arg0 = CharMatcher.is('<');
      
      // When: we call the or method on the two matchers
      CharMatcher or = arg0.or(arg0);
      
      // Then: the returned matcher should be the same as the original one, since it matches the same character
      assertSame(arg0, or);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCollapseFromAndIs() throws Throwable  {
      // Given a CharMatcher that matches a space character,
      // When the "collapseFrom" method is called with a string containing various whitespace characters,
      // Then the method should return a new string with all consecutive whitespace characters collapsed to a single space.
      
      CharMatcher is = CharMatcher.is('S');
      String collapseFrom = is.collapseFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", '>');
      assertEquals("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", collapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAllOfWithCharSequenceWhereLengthIsZero() throws Throwable  {
      // This test ensures that the "inRange" CharMatcher is functioning correctly by verifying that it matches all of a specific input string.
      CharMatcher inRange = CharMatcher.inRange('M', 'M', "");
      CharMatcher precomputed = inRange.NONE.precomputed();
      boolean matchesAllOf = precomputed.matchesAllOf("");
      assertTrue(matchesAllOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAllOf() throws Throwable  {
      // Given a character matcher that matches no characters
      CharMatcher charMatcher = CharMatcher.NONE;
      
      // When a character buffer of size 1023 is passed to the matcher
      CharBuffer arg0 = CharBuffer.allocate(1023);
      
      // Then the matcher should not match any characters in the buffer
      boolean matchesAllOf = charMatcher.matchesAllOf(arg0);
      assertFalse(matchesAllOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimAndCollapseFromWithCharSequenceWhereLengthIsZero() throws Throwable  {
      // Create a CharMatcher that matches any character
      CharMatcher charMatcher = CharMatcher.ANY;
      
      // Trim and collapse the characters in the input string
      String trimmedString = charMatcher.trimAndCollapseFrom("", 'K');
      
      // Assert that the output is the expected value
      assertEquals("", trimmedString);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCollapseFrom1() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_ISO_CONTROL;
      String collapseFrom = charMatcher.ANY.collapseFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", 'T');
      // Given a string with various whitespace characters
      assertEquals("T", collapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking2CharSequences1() throws Throwable  {
      // Create a CharMatcher for any letter
      CharMatcher charMatcher = CharMatcher.ANY;
      
      // Replace any letters in "CharMatcher.JAVA_LETTER" with "CharMatcher.ANY"
      String replaceFrom = charMatcher.replaceFrom((CharSequence) "CharMatcher.JAVA_LETTER", (CharSequence) "CharMatcher.ANY");
      
      // Assert that the result is equal to "CharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANY"
      assertEquals("CharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANY", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesNoneOfReturningTrue() throws Throwable  {
      // Given a CharMatcher "is" that matches any character 'r'
      CharMatcher is = CharMatcher.is('r');
      
      // When we apply the matcher to an empty CharBuffer
      CharBuffer arg0 = CharBuffer.allocate(0);
      boolean matchesNoneOf = is.ANY.matchesNoneOf(arg0);
      
      // Then we expect that the matcher does not match any character in the buffer
      assertTrue(matchesNoneOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAnyOfReturningTrue() throws Throwable  {
      // No Comments were added
      CharMatcher charMatcher = CharMatcher.ANY;
      boolean matchesAnyOf = charMatcher.matchesAnyOf("abc123#$%^&*()_+-=[]{}|:;'\"<>,./`~");
      assertTrue(matchesAnyOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTaking2Arguments() throws Throwable  {
      // Given: A CharMatcher and a CharBuffer with 10 characters
      CharMatcher charMatcher = CharMatcher.ANY;
      CharBuffer arg0 = CharBuffer.allocate(10);
      
      // When: The indexIn method is called with the CharBuffer and starting position of 10
      int indexIn = charMatcher.indexIn((CharSequence) arg0, 10);
      
      // Then: The method should return -1 since no match was found
      assertEquals(-1, indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTaking2ArgumentsReturningPositive() throws Throwable  {
      // Test that the CharMatcher.ANY matcher finds the first occurrence of any character in a string
      CharMatcher charMatcher = CharMatcher.ANY;
      int indexIn = charMatcher.indexIn((CharSequence) "hello world", 1);
      assertEquals(1, indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNegatedFastMatcherTaking2ArgumentsAndCallsIndexInTakingCharSequence() throws Throwable  {
      // rollbacked to evosuite
      CharMatcher arg1 = CharMatcher.ASCII;
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher(")Wi*huDIZM6uz&do", arg1);
      int indexIn = charMatcher_NegatedFastMatcher.ANY.indexIn((CharSequence) ")Wi*huDIZM6uz&do");
      assertEquals(0, indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRetainFromReturningEmptyString() throws Throwable  {
      // This test ensures that the CharMatcher.retainFrom method works as expected when used with a digit character.
      CharMatcher charMatcher = CharMatcher.DIGIT;
      String retainFrom = charMatcher.retainFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("", retainFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRetainFrom0() throws Throwable  {
      // Given a CharMatcher that matches digits
      CharMatcher charMatcher = CharMatcher.DIGIT;
      
      // When the "retainFrom" method is called with a string of digits
      String retainFrom = charMatcher.retainFrom("1234567890");
      
      // Then the returned string should contain only the digits from the original string
      assertEquals("1234567890", retainFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveFromAndRemoveFromReturningNonEmptyString() throws Throwable  {
      // Test that the ASCII character matcher removes all whitespace characters
      CharMatcher charMatcher = CharMatcher.ASCII;
      String removeFrom = charMatcher.BREAKING_WHITESPACE.removeFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("\u202F\u00A0\u2007", removeFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedInternalThrowsTooManyResourcesException() throws Throwable  {
      // rollbacked to evosuite
      CharMatcher charMatcher = CharMatcher.JAVA_LOWER_CASE;
      // Undeclared exception!
      charMatcher.precomputedInternal();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimLeadingFromWithNonNull() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.INVISIBLE;
      CharBuffer arg0 = CharBuffer.allocate(1023);
      String trimLeadingFrom = charMatcher.JAVA_DIGIT.trimLeadingFrom(arg0);
      // Given: We have a CharMatcher object and a CharBuffer with 1023 characters allocated
      // When: We call the trimLeadingFrom method on the CharMatcher object with the CharBuffer as an argument
      // Then: The method should return a String that contains the trimmed leading digits
      assertNotNull(trimLeadingFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTakingCharSequenceReturningNegative() throws Throwable  {
      CharMatcher not = CharMatcher.isNot('n');
      int indexIn = not.JAVA_LETTER_OR_DIGIT.indexIn((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      // Verify that the index of the first non-digit character is -1
      assertEquals((-1), indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNegatedFastMatcherTaking2ArgumentsAndCallsWithToString() throws Throwable  {
      // Given a CharMatcher instance
      CharMatcher arg1 = CharMatcher.WHITESPACE;
      
      // When creating a NegatedFastMatcher instance with a custom toString representation
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher("", arg1);
      
      // And when applying the withToString method
      CharMatcher withToString = charMatcher_NegatedFastMatcher.withToString("0D.:6=");
      
      // Then the return value should not be the same as the original NegatedFastMatcher instance
      assertNotSame(charMatcher_NegatedFastMatcher, withToString);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedAndInRangeTaking3ArgumentsAndCreatesNegatedFastMatcherTaking2Arguments() throws Throwable  {
      // Given a CharMatcher instance that matches any character in the range M-M, inclusive
      CharMatcher arg1 = CharMatcher.inRange('M', 'M', "");
      
      // When we create a NegatedFastMatcher using this CharMatcher as its argument
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher("", arg1);
      
      // And we precompute the negation of this NegatedFastMatcher
      CharMatcher precomputed = charMatcher_NegatedFastMatcher.precomputed();
      
      // Then the precomputed CharMatcher should match any character that is not in the range M-M, inclusive
      assertEquals("", precomputed.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedInternalThrowsTooManyResourcesExceptionAndForPredicate() throws Throwable  {
      // rollbacked to evosuite
      Predicates.ObjectPredicate arg0 = Predicates.ObjectPredicate.ALWAYS_TRUE;
      CharMatcher forPredicate = CharMatcher.forPredicate(arg0);
      // Undeclared exception!
      forPredicate.precomputedInternal();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToString() throws Throwable  {
      // Given a character matcher that matches breaking whitespace characters
      CharMatcher charMatcher = CharMatcher.BREAKING_WHITESPACE;
      
      // When the toString method is called on the character matcher
      String string = charMatcher.toString();
      
      // Then the resulting string should be "CharMatcher.BREAKING_WHITESPACE"
      assertEquals("CharMatcher.BREAKING_WHITESPACE", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking1And1() throws Throwable  {
      // Given a CharMatcher instance with ASCII characters
      CharMatcher charMatcher = CharMatcher.ASCII;
      
      // When the precomputedInternal method is called on the CharMatcher instance
      CharMatcher precomputedInternal = charMatcher.precomputedInternal();
      
      // Then the resulting CharMatcher instance should replace all ASCII characters with 'd'
      String replaceFrom = precomputedInternal.replaceFrom((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", 'd');
      assertEquals("\u2002\u3000d\u0085\u200A\u2005\u2000\u3000\u2029d\u3000\u2008\u2003\u205F\u3000\u1680dd\u2006\u2001\u202F\u00A0d\u2009\u3000\u2004\u3000\u3000\u2028d\u2007\u3000", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLastIndexInThrowsNullPointerException() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ANY;
      // Test that calling lastIndexIn() with null throws a NullPointerException
      try {
      charMatcher.ANY.lastIndexIn((CharSequence) null);
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Verify that the correct exception is thrown
      verifyException("com.google.common.base.CharMatcher$7", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAnd0() throws Throwable  {
      // This test verifies that the and method of the CharMatcher class returns a new CharMatcher instance
      // that matches any character that is matched by both the original matcher and the other matcher.
      CharMatcher arg0 = CharMatcher.JAVA_UPPER_CASE;
      CharMatcher and = arg0.ANY.and(arg0);
      assertSame(and, arg0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimFromAndTrimFromReturningEmptyString1() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.NONE;
      String trimmedString = charMatcher.trimFrom("  \t\r\n");
      assertEquals("", trimmedString);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOr0() throws Throwable  {
      // Given a CharMatcher instance
      CharMatcher charMatcher = CharMatcher.ANY;
      
      // When or method is called with the same object twice
      CharMatcher orResult = charMatcher.or(charMatcher);
      
      // Then the result should be the same object as the original one
      assertSame(orResult, charMatcher);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveFrom1() throws Throwable  {
      // Arrange
      CharMatcher charMatcher = CharMatcher.BREAKING_WHITESPACE;
      String removeFrom = charMatcher.ANY.removeFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      
      // Act
      String expectedResult = "";
      String actualResult = charMatcher.ANY.removeFrom(removeFrom);
      
      // Assert
      assertEquals(expectedResult, actualResult);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCountInWithNonNull() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_DIGIT;
      // Allocate a buffer with 28 characters
      CharBuffer arg0 = CharBuffer.allocate(28);
      int countIn = charMatcher.ANY.countIn(arg0);
      assertEquals(28, countIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking1And1WithOtherChar() throws Throwable  {
      // No Comments were added
      CharMatcher not = CharMatcher.isNot('(');
      String replaceFrom = not.ANY.replaceFrom((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", '(');
      assertEquals("((((((((((((((((((((((((((((((((", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimAndCollapseFrom() throws Throwable  {
      // Test that the CharMatcher.ANY char matcher trims and collapses from the input string correctly
      CharMatcher charMatcher = CharMatcher.ANY;
      String trimAndCollapseFrom = charMatcher.trimAndCollapseFrom("This is a sample sentence.", 'K');
      // Assert that the output of the trimAndCollapseFrom method is an empty string
      assertEquals("", trimAndCollapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTaking2ArgumentsWithCharSequenceWhereLengthIsPositive() throws Throwable  {
      // Given a CharMatcher that matches any character between 'i' and 'g'
      CharMatcher inRange = CharMatcher.inRange('i', 'g', "'h')");
      
      // When we search for the first occurrence of any character outside of the range in the given string
      int indexIn = inRange.NONE.indexIn((CharSequence) "'h')", 4);
      
      // Then we expect the result to be -1, since there are no characters outside of the range in the substring starting at index 4
      assertEquals((-1), indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAndAndIsNotAndIsNotWithOtherChar() throws Throwable  {
      // Given a CharMatcher that matches nothing and another CharMatcher that matches everything except for U+0012
      CharMatcher none = CharMatcher.NONE;
      CharMatcher notUPlus0012 = CharMatcher.isNot('\u0012');
      
      // When we use the "and" operator to combine them
      CharMatcher and = notUPlus0012.and(none);
      
      // Then we expect that the result is equivalent to the original CharMatcher
      assertSame(and, none);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAnyOfReturningFalse() throws Throwable  {
      // Test that a CharMatcher does not match any invisible characters.
      CharMatcher charMatcher = CharMatcher.INVISIBLE;
      boolean matchesAnyOf = charMatcher.NONE.matchesAnyOf("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertFalse(matchesAnyOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAnd1() throws Throwable  {
      // Given: We have a CharMatcher object, "arg0", that matches any character that is either a letter or a digit.
      CharMatcher arg0 = CharMatcher.JAVA_LETTER_OR_DIGIT;
      
      // When: We create a new CharMatcher object, "and", by combining "arg0" with the empty matcher using the "and" method.
      CharMatcher and = arg0.NONE.and(arg0);
      
      // Then: The result of the combination is not equal to the original "arg0" object, as we are combining two non-empty matchers.
      assertFalse(and.equals((Object)arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInRangeTaking3ArgumentsWithOtherChar() throws Throwable  {
      // No Comments were added
      CharMatcher inRange = CharMatcher.inRange('!', 'P', "%s");
      String replaceFrom = inRange.NONE.replaceFrom((CharSequence) "%s", 'P');
      assertEquals("%s", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimFromAndTrimFromReturningNonEmptyString1() throws Throwable  {
      // Given a CharMatcher instance, create a new CharMatcher that matches no characters.
      CharMatcher charMatcher = CharMatcher.DIGIT;
      
      // When the CharMatcher is used to trim a string containing whitespace and digits,
      String trimFrom = charMatcher.NONE.trimFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      
      // Then the resulting string should be empty.
      assertEquals("", trimFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCollapseFromReturningEmptyString() throws Throwable  {
      // Given a CharMatcher instance that matches the range of characters from M to M,
      CharMatcher inRange = CharMatcher.inRange('M', 'M', "");
      
      // When we call the NONE method on this matcher and pass an empty string as input,
      String collapseFrom = inRange.NONE.collapseFrom("", 'M');
      
      // Then the result should be an empty string.
      assertEquals("", collapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNegatedFastMatcherTakingCharMatcherAndCallsRemoveFrom() throws Throwable  {
      // Create a CharMatcher that matches any character
      CharMatcher arg0 = CharMatcher.ANY;
      
      // Create a NegatedFastMatcher for the above CharMatcher
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher(arg0);
      
      // Assert that the removeFrom method on the NegatedFastMatcher returns the expected result
      String removeFrom = charMatcher_NegatedFastMatcher.NONE.removeFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", removeFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimLeadingFrom() throws Throwable  {
      // Create a CharMatcher instance to match ASCII characters
      CharMatcher charMatcher = CharMatcher.ASCII;
      
      // Trim leading whitespace from the input string
      String trimmedInput = charMatcher.NONE.trimLeadingFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      
      // Assert that the trimmed string is equal to the expected output
      assertEquals("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", trimmedInput);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimTrailingFromThrowsNullPointerException() throws Throwable  {
      // rollbacked to evosuite
      CharMatcher inRange = CharMatcher.inRange('`', '`');
      CharMatcher negate = inRange.ANY.negate();
      // Undeclared exception!
      try { 
        negate.trimTrailingFrom((CharSequence) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.CharMatcher$8", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsNotAndOr() throws Throwable  {
      // Create a CharMatcher that matches any character that is not 'T'
      CharMatcher arg0 = CharMatcher.isNot('T');
      
      // Create another CharMatcher that matches any character that is not 'T', using the "or" method
      CharMatcher or = arg0.NONE.or(arg0);
      
      // Assert that the two matchers are equal, meaning they will match the same characters
      assertSame(arg0, or);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLastIndexInWithCharSequenceWhereLengthIsPositive() throws Throwable  {
      // Tests the CharMatcher.inRange method with an empty string as input
      CharMatcher inRange = CharMatcher.inRange('M', 'M', "");
      CharMatcher precomputed = inRange.NONE.precomputed();
      int lastIndexIn = precomputed.lastIndexIn("CharMatcher.ASCII");
      assertEquals(-1, lastIndexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTakingCharSequenceWithCharSequenceWhereLengthIsZero() throws Throwable  {
      // Given a CharMatcher instance that matches uppercase letters
      CharMatcher inRange = CharMatcher.inRange('M', 'M');
      
      // When we call precomputed() on the CharMatcher instance
      CharMatcher precomputed = inRange.NONE.precomputed();
      
      // Then the returned CharMatcher instance should not match any characters
      int indexIn = precomputed.indexIn((CharSequence) "");
      assertEquals((-1), indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNoneOfWithCharSequenceWhereLengthIsZero() throws Throwable  {
      // Given a CharMatcher that matches no characters
      CharMatcher matcher = CharMatcher.noneOf("");
      
      // When I call the indexIn method with an empty string
      int indexIn = matcher.indexIn((CharSequence) "");
      
      // Then the result should be -1, indicating that no character was found
      assertEquals(-1, indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsAndPrecomputedInternal() throws Throwable  {
      // No Comments were added
      CharMatcher is = CharMatcher.is('[');
      CharMatcher precomputedInternal = is.precomputedInternal();
      assertNotSame(precomputedInternal, is);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithToStringWithNull() throws Throwable  {
      // Given a CharMatcher instance with a non-null toString method
      CharMatcher charMatcher = CharMatcher.JAVA_ISO_CONTROL;
      CharMatcher withToString = charMatcher.withToString((String) null);
      
      // When the withToString method is called on the CharMatcher instance
      String actualResult = withToString.toString();
      
      // Then the toString method of the CharMatcher instance should return null
      assertNull(actualResult);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesNoneOfReturningFalse() throws Throwable  {
      // Given: a CharMatcher instance called "arg0" that matches ASCII characters
      CharMatcher arg0 = CharMatcher.ASCII;
      
      // And: a new CharMatcher instance created by calling the "and" method on "arg0" with "arg0" as an argument
      CharMatcher and = arg0.and(arg0);
      
      // When: the "matchesNoneOf" method is called on "and" with the string "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000" as an argument
      boolean matchesNoneOf = and.matchesNoneOf("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      
      // Then: the method should return false, as none of the characters in the string match any of the ASCII characters.
      assertFalse(matchesNoneOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNegate() throws Throwable  {
      // Test that the negation of a CharMatcher returns the original CharMatcher
      CharMatcher not = CharMatcher.isNot('N');
      CharMatcher negate = not.negate();
      assertFalse(negate.equals((Object)not));
      
      // This test ensures that the negation of a CharMatcher is equal to the original CharMatcher,
      // which means that the negation of a CharMatcher is equivalent to the original CharMatcher.
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsNotAndPrecomputedInternal() throws Throwable  {
      // Given a character matcher that matches any character except 't'
      CharMatcher not = CharMatcher.isNot('t');
      
      // When the precomputed internal method is called on this character matcher
      CharMatcher precomputedInternal = not.precomputedInternal();
      
      // Then the resulting character matcher should have a toString() value of "CharMatcher.isNot('\\u0074')"
      assertEquals("CharMatcher.isNot('t')", precomputedInternal.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedAndNegate() throws Throwable  {
      // rollbacked to evosuite
      CharMatcher charMatcher = CharMatcher.JAVA_ISO_CONTROL;
      CharMatcher negate = charMatcher.negate();
      CharMatcher precomputed = negate.precomputed();
      assertEquals("CharMatcher.JAVA_ISO_CONTROL.negate()", precomputed.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRetainFromAndNoneOfAndCreatesNegatedFastMatcherTaking2Arguments() throws Throwable  {
      // No Comments were added
      CharMatcher arg1 = CharMatcher.noneOf("CharMatcher.isNot('6').negate().negate().negate()");
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher("CharMatcher.isNot('6').negate().negate().negate()", arg1);
      String retainFrom = charMatcher_NegatedFastMatcher.retainFrom("CharMatcher.isNot('6').negate().negate().negate()");
      assertEquals("CharMatcher.anyOf(\"\\u0027\\u0027\\u0028\\u0028\\u0028\\u0028\\u0029\\u0029\\u0029\\u0029\\u002E\\u002E\\u002E\\u002E\\u0036\\u0043\\u004D\\u004E\\u0061\\u0061\\u0061\\u0061\\u0061\\u0063\\u0065\\u0065\\u0065\\u0065\\u0065\\u0065\\u0065\\u0067\\u0067\\u0067\\u0068\\u0068\\u0069\\u006E\\u006E\\u006E\\u006F\\u0072\\u0072\\u0073\\u0074\\u0074\\u0074\\u0074\\u0074\").negate()", arg1.toString());
      assertEquals("CharMatcher.isNot('6').negate().negate().negate()", retainFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNegatedFastMatcherTaking2ArgumentsAndCallsCountIn() throws Throwable  {
      // Given a CharMatcher object that matches no characters
      CharMatcher arg1 = CharMatcher.NONE;
      
      // When a new NegatedFastMatcher is created with the given character sequence and matcher
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher("5/P(8H4oZ7! (", arg1);
      
      // Then the countIn method of the NegatedFastMatcher object should return 13
      assertEquals(13, charMatcher_NegatedFastMatcher.countIn("5/P(8H4oZ7! ("));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNegatedFastMatcherTakingCharMatcherAndCallsMatchesAllOf() throws Throwable  {
      // Given a character matcher that matches any control character
      CharMatcher arg0 = CharMatcher.JAVA_ISO_CONTROL;
      
      // When the negated fast matcher is created with the character matcher
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher(arg0);
      
      // Then the matcher should not match any non-control characters
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithToStringAndNoneOf() throws Throwable  {
      // rollbacked to evosuite
      CharMatcher noneOf = CharMatcher.noneOf("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      noneOf.withToString("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("CharMatcher.anyOf(\"\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u0085\\u00A0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\").negate()", noneOf.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOr1() throws Throwable  {
      // Arrange
      CharMatcher arg0 = CharMatcher.ASCII;
      
      // Act
      CharMatcher or = arg0.or(arg0);
      
      // Assert
      assertEquals("CharMatcher.or(CharMatcher.ASCII, CharMatcher.ASCII)", or.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithToStringThrowsUnsupportedOperationException() throws Throwable  {
      // No Comments were added
      CharMatcher inRange = CharMatcher.inRange('i', 'g', "'h')");
      // Undeclared exception!
      try { 
        inRange.INVISIBLE.withToString("1yCGyW");
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.CharMatcher", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRetainFrom1() throws Throwable  {
      // Test that the CharMatcher.ASCII retains all ASCII characters and removes all non-ASCII characters
      CharMatcher charMatcher = CharMatcher.ASCII;
      String retainFrom = charMatcher.retainFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("\r\t \n", retainFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testApplyReturningTrue() throws Throwable  {
      // Given a CharMatcher instance with ASCII character set
      CharMatcher charMatcher = CharMatcher.JAVA_LETTER;
      
      // When a Character argument is passed to the apply method
      Character arg0 = new Character('_');
      boolean apply = charMatcher.ASCII.apply(arg0);
      
      // Then the result should be true, as the ASCII character set includes underscores
      assertTrue(apply);
  }
}
