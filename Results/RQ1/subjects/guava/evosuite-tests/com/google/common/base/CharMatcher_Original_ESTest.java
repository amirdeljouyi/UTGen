/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 16:57:30 GMT 2024
 */

package com.google.common.base;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.base.CharMatcher;
import com.google.common.base.Predicates;
import com.google.common.base.SmallCharMatcher;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.util.BitSet;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class CharMatcher_Original_ESTest extends CharMatcher_Original_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesReturningTrue() throws Throwable  {
      CharMatcher noneOf = CharMatcher.noneOf("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      boolean matches = noneOf.matches('W');
      assertEquals("CharMatcher.anyOf(\"\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u0085\\u00A0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\").negate()", noneOf.toString());
      assertTrue(matches);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesReturningFalse() throws Throwable  {
      CharMatcher not = CharMatcher.isNot('O');
      boolean matches = not.matches('O');
      assertFalse(matches);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTakingCharSequenceReturningPositive() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ASCII;
      CharBuffer arg0 = CharBuffer.wrap((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      int indexIn = charMatcher.indexIn((CharSequence) arg0);
      assertEquals(2, indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCountInReturningZero() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_DIGIT;
      ByteBuffer allocate = ByteBuffer.allocate(1470);
      CharBuffer arg0 = allocate.asCharBuffer();
      int countIn = charMatcher.countIn(arg0);
      assertEquals(0, countIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testApplyReturningFalse() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange(' ', ' ');
      Character arg0 = Character.valueOf('\"');
      boolean apply = inRange.apply(arg0);
      assertFalse(apply);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInRangeTaking3ArgumentsWithOtherChar() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange('&', '&', ":-p}0TiFa)>R\"[ra*");
      String removeFrom = inRange.removeFrom(":-p}0TiFa)>R\"[ra*");
      assertEquals(":-p}0TiFa)>R\"[ra*", removeFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTaking2ArgumentsReturningZero() throws Throwable  {
      CharMatcher arg1 = CharMatcher.inRange('H', 'H');
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher("7$/^9wC", arg1);
      int indexIn = charMatcher_NegatedFastMatcher.indexIn((CharSequence) "L2geuV7Gl&~Si!%", (int) (byte)0);
      assertEquals(0, indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInRangeTaking3ArgumentsAndIndexInTaking2Arguments() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange('M', 'M', "");
      CharBuffer arg0 = CharBuffer.allocate(244);
      int indexIn = inRange.indexIn((CharSequence) arg0, 4);
      assertEquals((-1), indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNegate0() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_ISO_CONTROL;
      CharMatcher negate = charMatcher.negate();
      assertFalse(negate.equals((Object)charMatcher));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveFrom0() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_UPPER_CASE;
      String removeFrom = charMatcher.WHITESPACE.removeFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("", removeFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsNotAndOrAndIsNotWithOtherChar0() throws Throwable  {
      CharMatcher not = CharMatcher.isNot('>');
      CharMatcher arg0 = CharMatcher.WHITESPACE;
      CharMatcher or = not.or(arg0);
      assertFalse(or.equals((Object)arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimAndCollapseFromWithNonNull() throws Throwable  {
      CharMatcher not = CharMatcher.isNot('h');
      CharBuffer arg0 = CharBuffer.wrap((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      String trimAndCollapseFrom = not.trimAndCollapseFrom(arg0, 'h');
      assertEquals("", trimAndCollapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimAndCollapseFromReturningNonEmptyString() throws Throwable  {
      CharMatcher arg1 = CharMatcher.ASCII;
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher(")Wi*huDIZM6uz&do", arg1);
      String trimAndCollapseFrom = charMatcher_NegatedFastMatcher.JAVA_LETTER_OR_DIGIT.trimAndCollapseFrom(")Wi*huDIZM6uz&do", 'N');
      assertEquals(")N*N&", trimAndCollapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNegatedFastMatcherTakingCharMatcherAndCallsCollapseFrom() throws Throwable  {
      CharMatcher arg0 = CharMatcher.JAVA_LETTER;
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher(arg0);
      String collapseFrom = charMatcher_NegatedFastMatcher.collapseFrom(".ZSQ`&74.g=XIL]", '.');
      assertEquals(".ZSQ.g.XIL.", collapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimTrailingFromReturningNonEmptyString() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_ISO_CONTROL;
      String trimTrailingFrom = charMatcher.trimTrailingFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", trimTrailingFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimTrailingFromReturningEmptyString() throws Throwable  {
      CharMatcher anyOf = CharMatcher.anyOf("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      String trimTrailingFrom = anyOf.trimTrailingFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("", trimTrailingFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimLeadingFromReturningEmptyString() throws Throwable  {
      CharMatcher anyOf = CharMatcher.anyOf("fA]G[syzt");
      String trimLeadingFrom = anyOf.trimLeadingFrom("fA]G[syzt");
      assertEquals("", trimLeadingFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimFromAndTrimFromReturningEmptyString0() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ASCII;
      String trimFrom = charMatcher.trimFrom("CharMatcher.ASCII");
      assertEquals("", trimFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking2CharSequencesWithNonNullAndNonNull() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.INVISIBLE;
      char[] arg0 = new char[1];
      CharBuffer arg1 = CharBuffer.wrap(arg0);
      String replaceFrom = charMatcher.replaceFrom((CharSequence) arg1, (CharSequence) arg1);
      assertEquals("\u0000", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking2CharSequencesReturningEmptyString() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_DIGIT;
      byte[] arg0 = new byte[0];
      ByteBuffer wrap = ByteBuffer.wrap(arg0);
      CharBuffer arg1 = wrap.asCharBuffer();
      String replaceFrom = charMatcher.ASCII.replaceFrom((CharSequence) arg1, (CharSequence) arg1);
      assertEquals("", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking1And1ReturningEmptyString() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange('M', '~', "");
      String replaceFrom = inRange.replaceFrom((CharSequence) "", 'u');
      assertEquals("", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCountIn() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_ISO_CONTROL;
      int countIn = charMatcher.countIn("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals(6, countIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLastIndexInReturningPositive() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ASCII;
      CharBuffer arg0 = CharBuffer.wrap((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      int lastIndexIn = charMatcher.lastIndexIn(arg0);
      assertEquals(29, lastIndexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLastIndexInWithNonNull() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.BREAKING_WHITESPACE;
      CharBuffer arg0 = CharBuffer.allocate(0);
      int lastIndexIn = charMatcher.ASCII.lastIndexIn(arg0);
      assertEquals((-1), lastIndexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking2CharSequences0() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.SINGLE_WIDTH;
      String replaceFrom = charMatcher.replaceFrom((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", (CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000\u1680\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000\u3000", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAllOfAndMatchesAllOfWithCharSequenceWhereLengthIsPositive() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_LETTER;
      boolean matchesAllOf = charMatcher.JAVA_ISO_CONTROL.matchesAllOf("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertFalse(matchesAllOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAllOfAndMatchesAllOfReturningTrue() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ANY;
      ByteBuffer allocate = ByteBuffer.allocate(1595);
      CharBuffer arg0 = allocate.asCharBuffer();
      boolean matchesAllOf = charMatcher.ASCII.matchesAllOf(arg0);
      assertTrue(matchesAllOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedInternal0() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.WHITESPACE;
      CharMatcher precomputedInternal = charMatcher.precomputedInternal();
      assertEquals("WHITESPACE", precomputedInternal.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedInternal1() throws Throwable  {
      BitSet arg0 = new BitSet(55539);
      SmallCharMatcher from = (SmallCharMatcher)SmallCharMatcher.from(arg0, "O/sX*Q]|]d#GgP>]az");
      SmallCharMatcher precomputedInternal = (SmallCharMatcher)from.precomputedInternal();
      assertNotNull(precomputedInternal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testForPredicate() throws Throwable  {
      CharMatcher arg0 = CharMatcher.INVISIBLE;
      CharMatcher forPredicate = CharMatcher.forPredicate(arg0);
      assertSame(forPredicate, arg0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInRangeTaking2ArgumentsThrowsIllegalArgumentException() throws Throwable  {
      // Undeclared exception!
      try { 
        CharMatcher.inRange('m', 'H');
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTakingCharSequenceAndNoneOf() throws Throwable  {
      CharMatcher noneOf = CharMatcher.noneOf("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      int indexIn = noneOf.indexIn((CharSequence) "CharMatcher.or(");
      assertEquals("CharMatcher.anyOf(\"\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u0085\\u00A0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\").negate()", noneOf.toString());
      assertEquals(0, indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsNotAndOrAndIsNotWithOtherChar1() throws Throwable  {
      CharMatcher not = CharMatcher.isNot('>');
      CharMatcher arg0 = CharMatcher.SINGLE_WIDTH;
      CharMatcher or = not.or(arg0);
      assertFalse(or.equals((Object)not));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAndAndIsNot() throws Throwable  {
      CharMatcher not = CharMatcher.isNot('N');
      CharMatcher arg0 = CharMatcher.JAVA_LETTER_OR_DIGIT;
      CharMatcher and = not.and(arg0);
      assertEquals("CharMatcher.and(CharMatcher.isNot('\\u004E'), CharMatcher.JAVA_LETTER_OR_DIGIT)", and.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLastIndexInReturningZero() throws Throwable  {
      CharMatcher not = CharMatcher.isNot('>');
      int lastIndexIn = not.lastIndexIn("h");
      assertEquals(0, lastIndexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInRangeTaking3ArgumentsWithDigit() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange(' ', ' ');
      CharMatcher precomputedInternal = inRange.precomputedInternal();
      CharMatcher arg0 = CharMatcher.inRange('K', '6', "mj");
      CharMatcher or = precomputedInternal.or(arg0);
      assertEquals("CharMatcher.or(CharMatcher.is('\\u0020'), mj)", or.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInRangeTaking2Arguments() throws Throwable  {
      CharMatcher arg0 = CharMatcher.inRange(' ', ' ');
      CharMatcher precomputedInternal = arg0.precomputedInternal();
      CharMatcher and = precomputedInternal.and(arg0);
      assertFalse(and.equals((Object)arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAndAndIsAndIsNot() throws Throwable  {
      CharMatcher arg0 = CharMatcher.isNot('>');
      CharMatcher is = CharMatcher.is('>');
      CharMatcher and = is.and(arg0);
      assertFalse(and.equals((Object)is));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCollapseFromAndIs() throws Throwable  {
      CharMatcher is = CharMatcher.is('S');
      String collapseFrom = is.collapseFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", '>');
      assertEquals("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", collapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAllOfWithCharSequenceWhereLengthIsZero() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange('M', 'M', "");
      CharMatcher precomputed = inRange.NONE.precomputed();
      boolean matchesAllOf = precomputed.matchesAllOf("");
      assertTrue(matchesAllOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAllOf() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.INVISIBLE;
      CharBuffer arg0 = CharBuffer.allocate(1023);
      boolean matchesAllOf = charMatcher.NONE.matchesAllOf(arg0);
      assertFalse(matchesAllOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimAndCollapseFromWithCharSequenceWhereLengthIsZero() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ANY;
      String trimAndCollapseFrom = charMatcher.trimAndCollapseFrom("", 'K');
      assertEquals("", trimAndCollapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCollapseFrom() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_ISO_CONTROL;
      String collapseFrom = charMatcher.ANY.collapseFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", 'T');
      assertEquals("T", collapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking2CharSequences1() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ANY;
      String replaceFrom = charMatcher.replaceFrom((CharSequence) "CharMatcher.ANY", (CharSequence) "CharMatcher.ANY");
      assertEquals("CharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANYCharMatcher.ANY", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesNoneOfReturningTrue() throws Throwable  {
      CharBuffer arg0 = CharBuffer.allocate(0);
      CharMatcher is = CharMatcher.is('r');
      boolean matchesNoneOf = is.ANY.matchesNoneOf(arg0);
      assertTrue(matchesNoneOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAnyOfReturningTrue() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ANY;
      boolean matchesAnyOf = charMatcher.matchesAnyOf("mj");
      assertTrue(matchesAnyOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTaking2Arguments() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ANY;
      CharBuffer arg0 = CharBuffer.allocate(4753);
      int indexIn = charMatcher.indexIn((CharSequence) arg0, 4753);
      assertEquals((-1), indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTaking2ArgumentsReturningPositive() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ANY;
      CharBuffer arg0 = CharBuffer.allocate(93);
      int indexIn = charMatcher.indexIn((CharSequence) arg0, 1);
      assertEquals(1, indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTakingCharSequence() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ANY;
      int indexIn = charMatcher.indexIn((CharSequence) "");
      assertEquals((-1), indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNegatedFastMatcherTaking2ArgumentsAndCallsIndexInTakingCharSequence() throws Throwable  {
      CharMatcher arg1 = CharMatcher.ASCII;
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher(")Wi*huDIZM6uz&do", arg1);
      int indexIn = charMatcher_NegatedFastMatcher.ANY.indexIn((CharSequence) ")Wi*huDIZM6uz&do");
      assertEquals(0, indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRetainFromReturningEmptyString() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.DIGIT;
      String retainFrom = charMatcher.retainFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("", retainFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedInternalThrowsTooManyResourcesException0() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.DIGIT;
      // Undeclared exception!
      charMatcher.precomputedInternal();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveFromAndRemoveFromReturningNonEmptyString() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ASCII;
      String removeFrom = charMatcher.BREAKING_WHITESPACE.removeFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("\u202F\u00A0\u2007", removeFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedInternalThrowsTooManyResourcesException1() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_LOWER_CASE;
      // Undeclared exception!
      charMatcher.precomputedInternal();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimLeadingFromWithNonNull() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.INVISIBLE;
      CharBuffer arg0 = CharBuffer.allocate(1023);
      String trimLeadingFrom = charMatcher.JAVA_DIGIT.trimLeadingFrom(arg0);
      assertNotNull(trimLeadingFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimFromAndTrimFromReturningNonEmptyString0() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_LETTER;
      String trimFrom = charMatcher.trimFrom("CharMatcher.JAVA_LETTER");
      assertEquals(".JAVA_", trimFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTakingCharSequenceAndIsNot() throws Throwable  {
      CharMatcher not = CharMatcher.isNot('n');
      int indexIn = not.JAVA_LETTER_OR_DIGIT.indexIn((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals((-1), indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedInternalThrowsTooManyResourcesExceptionAndForPredicate() throws Throwable  {
      Predicates.ObjectPredicate arg0 = Predicates.ObjectPredicate.ALWAYS_TRUE;
      CharMatcher forPredicate = CharMatcher.forPredicate(arg0);
      // Undeclared exception!
      forPredicate.precomputedInternal();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNegatedFastMatcherTaking2ArgumentsAndCallsWithToString() throws Throwable  {
      CharMatcher arg1 = CharMatcher.WHITESPACE;
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher("", arg1);
      CharMatcher withToString = charMatcher_NegatedFastMatcher.withToString("0D.:6=");
      assertNotSame(withToString, charMatcher_NegatedFastMatcher);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedAndInRangeTaking3ArgumentsAndCreatesNegatedFastMatcherTaking2Arguments() throws Throwable  {
      CharMatcher arg1 = CharMatcher.inRange('M', 'M', "");
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher("", arg1);
      CharMatcher precomputed = charMatcher_NegatedFastMatcher.precomputed();
      assertSame(charMatcher_NegatedFastMatcher, precomputed);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToString() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.BREAKING_WHITESPACE;
      String string = charMatcher.toString();
      assertEquals("CharMatcher.BREAKING_WHITESPACE", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking1And1() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ASCII;
      CharMatcher precomputedInternal = charMatcher.precomputedInternal();
      String replaceFrom = precomputedInternal.replaceFrom((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", 'd');
      assertEquals("\u2002\u3000d\u0085\u200A\u2005\u2000\u3000\u2029d\u3000\u2008\u2003\u205F\u3000\u1680dd\u2006\u2001\u202F\u00A0d\u2009\u3000\u2004\u3000\u3000\u2028d\u2007\u3000", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLastIndexInThrowsNullPointerException() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ANY;
      // Undeclared exception!
      try { 
        charMatcher.ANY.lastIndexIn((CharSequence) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.CharMatcher$7", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAnd0() throws Throwable  {
      CharMatcher arg0 = CharMatcher.JAVA_UPPER_CASE;
      CharMatcher and = arg0.ANY.and(arg0);
      assertSame(arg0, and);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimFromAndTrimFromReturningEmptyString1() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.NONE;
      String trimFrom = charMatcher.ANY.trimFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("", trimFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOr0() throws Throwable  {
      CharMatcher arg0 = CharMatcher.ANY;
      CharMatcher or = arg0.or(arg0);
      assertSame(arg0, or);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemoveFrom1() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.BREAKING_WHITESPACE;
      String removeFrom = charMatcher.ANY.removeFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("", removeFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCountInWithNonNull() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_DIGIT;
      CharBuffer arg0 = CharBuffer.allocate(28);
      int countIn = charMatcher.ANY.countIn(arg0);
      assertEquals(28, countIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedInternalThrowsTooManyResourcesException2() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ANY;
      // Undeclared exception!
      charMatcher.precomputedInternal();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTaking2ArgumentsWithCharSequenceWhereLengthIsPositive() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange('i', 'g', "'h')");
      int indexIn = inRange.NONE.indexIn((CharSequence) "'h')", 4);
      assertEquals((-1), indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAndAndIsNotAndIsNotWithOtherChar() throws Throwable  {
      CharMatcher arg0 = CharMatcher.NONE;
      CharMatcher not = CharMatcher.isNot('\u0012');
      CharMatcher and = not.and(arg0);
      assertSame(arg0, and);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesAnyOfReturningFalse() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.INVISIBLE;
      boolean matchesAnyOf = charMatcher.NONE.matchesAnyOf("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertFalse(matchesAnyOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAnd1() throws Throwable  {
      CharMatcher arg0 = CharMatcher.JAVA_LETTER_OR_DIGIT;
      CharMatcher and = arg0.NONE.and(arg0);
      assertFalse(and.equals((Object)arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimFromAndTrimFromReturningNonEmptyString1() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.DIGIT;
      String trimFrom = charMatcher.NONE.trimFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", trimFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCollapseFromReturningEmptyString() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange('M', 'M', "");
      String collapseFrom = inRange.NONE.collapseFrom("", 'M');
      assertEquals("", collapseFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNegatedFastMatcherTakingCharMatcherAndCallsRemoveFrom() throws Throwable  {
      CharMatcher arg0 = CharMatcher.ANY;
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher(arg0);
      String removeFrom = charMatcher_NegatedFastMatcher.NONE.removeFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", removeFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimLeadingFrom() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ASCII;
      String trimLeadingFrom = charMatcher.NONE.trimLeadingFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", trimLeadingFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTrimTrailingFromThrowsNullPointerException() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange('`', '`');
      CharMatcher negate = inRange.ANY.negate();
      // Undeclared exception!
      try { 
        negate.trimTrailingFrom((CharSequence) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.CharMatcher$8", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsNotAndOr() throws Throwable  {
      CharMatcher arg0 = CharMatcher.isNot('T');
      CharMatcher or = arg0.NONE.or(arg0);
      assertSame(arg0, or);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLastIndexInWithCharSequenceWhereLengthIsPositive() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange('M', 'M', "");
      CharMatcher precomputed = inRange.NONE.precomputed();
      int lastIndexIn = precomputed.lastIndexIn("CharMatcher.ASCII");
      assertEquals((-1), lastIndexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIndexInTakingCharSequenceAndInRangeTaking3ArgumentsAndPrecomputed() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange('M', 'M', "");
      CharMatcher precomputed = inRange.NONE.precomputed();
      int indexIn = precomputed.indexIn((CharSequence) "");
      assertEquals((-1), indexIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNegate1() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ASCII;
      CharMatcher negate = charMatcher.NONE.negate();
      assertFalse(negate.equals((Object)charMatcher));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsAndPrecomputedInternal() throws Throwable  {
      CharMatcher is = CharMatcher.is('[');
      CharMatcher precomputedInternal = is.precomputedInternal();
      assertNotSame(precomputedInternal, is);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithToStringWithNull() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_ISO_CONTROL;
      CharMatcher withToString = charMatcher.withToString((String) null);
      assertNotSame(withToString, charMatcher);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsNotAndNegate() throws Throwable  {
      CharMatcher not = CharMatcher.isNot('N');
      CharMatcher negate = not.negate();
      assertFalse(negate.equals((Object)not));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsNotAndPrecomputedInternal() throws Throwable  {
      CharMatcher not = CharMatcher.isNot('t');
      CharMatcher precomputedInternal = not.precomputedInternal();
      assertEquals("CharMatcher.isNot('\\u0074')", precomputedInternal.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRetainFromAndNoneOfAndCreatesNegatedFastMatcherTaking2Arguments() throws Throwable  {
      CharMatcher arg1 = CharMatcher.noneOf("CharMatcher.isNot('6').negate().negate().negate()");
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher("CharMatcher.isNot('6').negate().negate().negate()", arg1);
      String retainFrom = charMatcher_NegatedFastMatcher.retainFrom("CharMatcher.isNot('6').negate().negate().negate()");
      assertEquals("CharMatcher.anyOf(\"\\u0027\\u0027\\u0028\\u0028\\u0028\\u0028\\u0029\\u0029\\u0029\\u0029\\u002E\\u002E\\u002E\\u002E\\u0036\\u0043\\u004D\\u004E\\u0061\\u0061\\u0061\\u0061\\u0061\\u0063\\u0065\\u0065\\u0065\\u0065\\u0065\\u0065\\u0065\\u0067\\u0067\\u0067\\u0068\\u0068\\u0069\\u006E\\u006E\\u006E\\u006F\\u0072\\u0072\\u0073\\u0074\\u0074\\u0074\\u0074\\u0074\").negate()", arg1.toString());
      assertEquals("CharMatcher.isNot('6').negate().negate().negate()", retainFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNegatedFastMatcherTaking2ArgumentsAndCallsCountIn() throws Throwable  {
      CharMatcher arg1 = CharMatcher.NONE;
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher("5/P(8H4oZ7! (", arg1);
      int countIn = charMatcher_NegatedFastMatcher.countIn("5/P(8H4oZ7! (");
      assertEquals(13, countIn);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNegatedFastMatcherTakingCharMatcherAndCallsMatchesAllOf() throws Throwable  {
      CharMatcher arg0 = CharMatcher.JAVA_ISO_CONTROL;
      CharMatcher.NegatedFastMatcher charMatcher_NegatedFastMatcher = new CharMatcher.NegatedFastMatcher(arg0);
      boolean matchesAllOf = charMatcher_NegatedFastMatcher.matchesAllOf("QEh%)G;qSC3I{|0W*B1");
      assertTrue(matchesAllOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithToStringAndNoneOf() throws Throwable  {
      CharMatcher noneOf = CharMatcher.noneOf("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      noneOf.withToString("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("CharMatcher.anyOf(\"\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u0085\\u00A0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\").negate()", noneOf.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOr1() throws Throwable  {
      CharMatcher arg0 = CharMatcher.ASCII;
      CharMatcher or = arg0.ASCII.or(arg0);
      assertEquals("CharMatcher.or(CharMatcher.ASCII, CharMatcher.ASCII)", or.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrecomputedAndPrecomputed() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_ISO_CONTROL;
      CharMatcher precomputed = charMatcher.precomputed();
      assertEquals("CharMatcher.JAVA_ISO_CONTROL", precomputed.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWithToStringThrowsUnsupportedOperationException() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange('i', 'g', "'h')");
      // Undeclared exception!
      try { 
        inRange.INVISIBLE.withToString("1yCGyW");
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.CharMatcher", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRetainFrom() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.ASCII;
      String retainFrom = charMatcher.retainFrom("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertEquals("\r\u000B\t \f\n", retainFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchesNoneOfReturningFalse() throws Throwable  {
      CharMatcher arg0 = CharMatcher.ASCII;
      CharMatcher and = arg0.and(arg0);
      boolean matchesNoneOf = and.matchesNoneOf("\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000");
      assertFalse(matchesNoneOf);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsAndOr() throws Throwable  {
      CharMatcher arg0 = CharMatcher.is('<');
      CharMatcher or = arg0.or(arg0);
      assertSame(or, arg0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testApplyReturningTrue() throws Throwable  {
      CharMatcher charMatcher = CharMatcher.JAVA_LETTER;
      Character arg0 = new Character('_');
      boolean apply = charMatcher.ASCII.apply(arg0);
      assertTrue(apply);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testInRangeTaking3ArgumentsWithOtherCharAndNonEmptyString() throws Throwable  {
      CharMatcher inRange = CharMatcher.inRange('!', 'P', "%s");
      String replaceFrom = inRange.NONE.replaceFrom((CharSequence) "%s", 'P');
      assertEquals("%s", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReplaceFromTaking1And1WithOtherChar() throws Throwable  {
      CharMatcher not = CharMatcher.isNot('(');
      String replaceFrom = not.ANY.replaceFrom((CharSequence) "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680\t \u2006\u2001\u202F\u00A0\f\u2009\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", '(');
      assertEquals("((((((((((((((((((((((((((((((((", replaceFrom);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNoneOfAndPrecomputedInternal() throws Throwable  {
      CharMatcher noneOf = CharMatcher.noneOf(".ZSQ`&74.g=XIL]");
      CharMatcher precomputedInternal = noneOf.precomputedInternal();
      assertEquals("CharMatcher.anyOf(\"\\u0026\\u002E\\u002E\\u0034\\u0037\\u003D\\u0049\\u004C\\u0051\\u0053\\u0058\\u005A\\u005D\\u0060\\u0067\").negate()", precomputedInternal.toString());
  }
}
