/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Mar 18 16:09:25 GMT 2024
 */

package org.apache.commons.lang3.time;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;
import java.util.SimpleTimeZone;
import java.util.TimeZone;
import org.apache.commons.lang3.time.FastDateFormat;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.util.MockDate;
import org.evosuite.runtime.mock.java.util.MockGregorianCalendar;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class FastDateFormat_ESTest extends FastDateFormat_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesFastDateFormatTaking4Arguments() throws Throwable  {
      // rollbacked to evosuite
      SimpleTimeZone arg1 = new SimpleTimeZone(1345, "Europe/Berlin");
      Locale arg2 = Locale.GERMANY;
      MockDate arg3 = new MockDate(1345, 0, 1345, 2, 1345);
      FastDateFormat fastDateFormat = new FastDateFormat("dd-MMM-yyyy hh:mm:ss z", arg1, arg2, arg3);
      assertEquals(0, FastDateFormat.FULL);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseObjectReturningNull() throws Throwable  {
      // Given: We have a FastDateFormat instance and a date string in the format "dd/MM/yyyy"
      FastDateFormat instance = FastDateFormat.getInstance();
      String dateString = "01/05/2022";
      
      // When: We parse the date string using the FastDateFormat instance's parseObject method with a ParsePosition object initialized to 3
      ParsePosition arg1 = new ParsePosition(3);
      Object parseObject = instance.parseObject(dateString, arg1);
      
      // Then: The returned object should be null since the date string is in an invalid format
      assertNull(parseObject);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetInstanceTakingString() throws Throwable  {
      // Given a FastDateFormat instance with the pattern "?&49"
      FastDateFormat instance = FastDateFormat.getInstance("?&49");
      
      // When parsing the string "?&49" with the instance
      ParsePosition arg1 = new ParsePosition(0);
      Date parse = instance.parse("?&49", arg1);
      
      // Then we expect the parsed date to be equivalent to the expected date "Fri Feb 14 20:21:21 GMT 2014"
      assertEquals("Fri Feb 14 20:21:21 GMT 2014", parse.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetTimeZoneReturningTimeZoneWhereGetRawOffsetIsZero() throws Throwable  {
      // Given a SimpleTimeZone object with an offset of 0 and an ID of ""
      SimpleTimeZone simpleTimeZone = new SimpleTimeZone(0, "");
      
      // When the getDateInstance method is called with a style of 0 and the SimpleTimeZone object as a parameter
      FastDateFormat dateInstance = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone);
      
      // Then the resulting FastDateFormat instance should have a TimeZone that is the same as the SimpleTimeZone object
      assertSame(dateInstance.getTimeZone(), simpleTimeZone);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetTimeZoneReturningTimeZoneWhereGetRawOffsetIsNegative() throws Throwable  {
      // rollbacked to evosuite
      SimpleTimeZone arg1 = new SimpleTimeZone((-733), "");
      FastDateFormat dateInstance = FastDateFormat.getDateInstance(0, (TimeZone) arg1);
      TimeZone timeZone = dateInstance.getTimeZone();
      assertSame(timeZone, arg1);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetTimeInstanceTaking1And1AndGetTimeZone() throws Throwable  {
      // Create a custom time zone with an ID that includes non-ASCII characters
      SimpleTimeZone arg1 = new SimpleTimeZone(1, "u:b!a}I\u0002tr+sG>S`]", 1, 1, 1, 1, 1, 1, 1, 1);
      
      // Create a time instance with the custom time zone
      FastDateFormat timeInstance = FastDateFormat.getTimeInstance(1, (TimeZone) arg1);
      
      // Get the time zone of the created time instance
      TimeZone timeZone = timeInstance.getTimeZone();
      
      // Assert that the obtained time zone is the same as the custom one
      assertSame(timeZone, arg1);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFormatTakingCalendar() throws Throwable  {
      // Given a FastDateFormat instance and a MockGregorianCalendar object
      FastDateFormat instance = FastDateFormat.getInstance();
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      
      // When the format method is called with the Calendar argument
      String format = instance.format((Calendar) arg0);
      
      // Then the expected string "2/14/14 8:21 PM" should be returned
      assertEquals("2/14/14 8:21 PM", format);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateTimeInstanceTaking4Arguments() throws Throwable  {
      Locale locale = Locale.CHINESE;
      TimeZone timeZone = TimeZone.getTimeZone("Asia/Shanghai");
      FastDateFormat dateTimeInstance = FastDateFormat.getDateTimeInstance(0, 2, timeZone, locale);
      assertEquals(3, dateTimeInstance.getPattern().length()); // Assert that the pattern length is 3
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsReturningFalse() throws Throwable  {
      // Create a new FastDateFormat instance with the current date and time
      FastDateFormat instance = FastDateFormat.getInstance();
      
      // Check that the instance does not equal the string "2022-01-01"
      boolean equals = instance.equals("2022-01-01");
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsReturningTrue() throws Throwable  {
      // Given: A FastDateFormat instance is created with default settings
      FastDateFormat format = FastDateFormat.getInstance();
      
      // When: The equals method is called on the same instance of FastDateFormat
      boolean result = format.equals(format);
      
      // Then: The returned value should be true, indicating that the instance is equal to itself
      assertTrue(result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetInstanceTaking1And1AndGetInstanceTaking1And1AndGetInstanceTaking1And1ReturningNonNull0() throws Throwable  {
      // Given a specific time zone (America/New_York)
      TimeZone arg1 = TimeZone.getTimeZone("America/New_York");
      
      // When we create a FastDateFormat instance with the specified format and time zone
      FastDateFormat instance = FastDateFormat.getInstance("MM/dd/yyyy HH:mm:ss z", arg1);
      
      // Then the resulting FastDateFormat instance should have the expected SHORT format
      assertEquals(3, FastDateFormat.SHORT);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFormatTakingDate() throws Throwable  {
      // Given a FastDateFormat instance and a Date object representing August 16, 2021 at 1:40 AM
      FastDateFormat instance = FastDateFormat.getInstance();
      MockDate arg0 = new MockDate(1629078000000L);
      
      // When the format method is called with the Date object as an argument
      String format = instance.format((Date) arg0);
      
      // Then the output should be "8/16/21 1:40 AM"
      assertEquals("8/16/21 1:40 AM", format);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFormatTaking1And1AndFormatTaking1And1AndFormatTaking1And1ReturningStringBufferWhereLengthIsPositive0() throws Throwable  {
      FastDateFormat instance = FastDateFormat.getInstance();
      StringBuffer dateTimeBuffer = new StringBuffer();
      StringBuffer formattedDateTime = instance.format((long) 1598326400, dateTimeBuffer);
      assertEquals("1/19/70 11:58 AM", formattedDateTime.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFormatTakingLong() throws Throwable  {
      // Given a FastDateFormat instance with default settings
      FastDateFormat instance = FastDateFormat.getInstance();
      
      // When we format a long value 2 as a date-time string
      String formattedString = instance.format((long) 2);
      
      // Then the result should be "1/1/70 12:00 AM"
      assertEquals("1/1/70 12:00 AM", formattedString);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetTimeInstanceTaking3Arguments() throws Throwable  {
      // rollbacked to evosuite
      Locale arg2 = Locale.KOREA;
      FastDateFormat timeInstance = FastDateFormat.getTimeInstance(1, (TimeZone) null, arg2);
      assertEquals(0, FastDateFormat.FULL);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateTimeInstanceTaking2IntsAnd1AndGetDateTimeInstanceTaking2IntsAnd10() throws Throwable  {
      // rollbacked to evosuite
      FastDateFormat dateTimeInstance = FastDateFormat.getDateTimeInstance(2, 2, (TimeZone) null);
      assertEquals(3, FastDateFormat.SHORT);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFormatTaking3Arguments() throws Throwable  {
      // rollbacked to evosuite
      FastDateFormat instance = FastDateFormat.getInstance();
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      StringBuffer arg1 = new StringBuffer();
      FieldPosition arg2 = new FieldPosition(3);
      StringBuffer format = instance.format((Object) arg0, arg1, arg2);
      assertEquals("2/14/14 8:21 PM", format.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateInstanceTaking3Arguments() throws Throwable  {
      // rollbacked to evosuite
      Locale arg2 = Locale.TAIWAN;
      FastDateFormat dateInstance = FastDateFormat.getDateInstance(1, (TimeZone) null, arg2);
      assertEquals(1, FastDateFormat.LONG);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testApplyRules() throws Throwable  {
      // rollbacked to evosuite
      FastDateFormat instance = FastDateFormat.getInstance();
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      StringBuffer arg1 = new StringBuffer();
      StringBuffer applyRules = instance.applyRules(arg0, arg1);
      assertEquals(15, applyRules.length());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFailsToCreateFastDateFormatTaking3ArgumentsThrowsNullPointerException() throws Throwable  {
      SimpleTimeZone arg1 = new SimpleTimeZone(3, "Eastern Standard Time");
      FastDateFormat fastDateFormat = null;
      
      // Given: a null pattern is passed to the constructor
      String pattern = null;
      
      // When: the constructor is called with a null pattern
      try {
      fastDateFormat = new FastDateFormat(pattern, arg1, (Locale) null);
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Then: a NullPointerException is thrown
      assertEquals("getMessage() returned null", "", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetTimeInstanceTaking1And1AndGetTimeInstanceTaking1And1() throws Throwable  {
      // rollbacked to evosuite
      Locale arg1 = Locale.SIMPLIFIED_CHINESE;
      FastDateFormat timeInstance = FastDateFormat.getTimeInstance(1, arg1);
      assertEquals(1, FastDateFormat.LONG);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetInstanceTaking1And1AndGetInstanceTaking1And1AndGetInstanceTaking1And1ReturningNonNull1() throws Throwable  {
      // This test verifies that the getInstance method returns an instance of FastDateFormat with the given pattern and locale
      
      Locale arg1 = Locale.UK;
      FastDateFormat instance = FastDateFormat.getInstance("dd-MMM-yy", arg1);
      
      assertEquals(3, FastDateFormat.SHORT);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashCode() throws Throwable  {
      // Given a FastDateFormat instance
      FastDateFormat instance = FastDateFormat.getInstance();
      
      // When the hashCode method is called
      int hashCode = instance.hashCode();
      
      // Then the hash code should be non-zero
      assertNotEquals(0, hashCode);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateTimeInstanceTaking2IntsAnd1AndGetDateTimeInstanceTaking2IntsAnd11() throws Throwable  {
      // Given a Locale instance representing China (arg2)
      Locale arg2 = Locale.CHINA;
      
      // When creating a DateTimeFormatter instance using FastDateFormat
      FastDateFormat dateTimeInstance = FastDateFormat.getDateTimeInstance(0, 1, arg2);
      
      // Then the created DateTimeFormatter should have the full date and time format
      assertEquals(0, FastDateFormat.FULL);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFormatTaking1And1AndFormatTaking1And1AndFormatTaking1And1ReturningStringBufferWhereLengthIsPositive1() throws Throwable  {
      // Arrange
      FastDateFormat instance = FastDateFormat.getInstance();
      MockGregorianCalendar arg0 = new MockGregorianCalendar(1992, 5, 16, 0, 3);
      StringBuffer arg1 = new StringBuffer();
      
      // Act
      StringBuffer format = instance.format((Calendar) arg0, arg1);
      
      // Assert
      assertEquals(16, format.length());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateInstanceTakingInt() throws Throwable  {
      // No Comments were added
      FastDateFormat dateInstance = FastDateFormat.getDateInstance(0);
      assertEquals(2, FastDateFormat.MEDIUM);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFormatTaking1And1AndFormatTaking1And1AndFormatTaking1And1ReturningStringBufferWhereLengthIsPositive2() throws Throwable  {
      // Create a mock date with a year value that is negative
      MockDate arg0 = new MockDate(12, 31, 0, (-1534), 0);
      
      // Create an empty string buffer to store the formatted date
      StringBuffer arg1 = new StringBuffer("");
      
      // Format the date using the FastDateFormat instance
      StringBuffer format = FastDateFormat.getInstance().format((Date) arg0, arg1);
      
      // Assert that the returned value is the same as the input string buffer
      assertSame(arg1, format);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMaxLengthEstimate() throws Throwable  {
      // Given a FastDateFormat instance
      FastDateFormat instance = FastDateFormat.getInstance();
      
      // When we get the maximum length estimate for the instance
      int maxLengthEstimate = instance.getMaxLengthEstimate();
      
      // Then we expect the maximum length estimate to be 21 characters long
      assertEquals(21, maxLengthEstimate);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToString() throws Throwable  {
      // Given a FastDateFormat instance with a specific format and locale
      FastDateFormat instance = FastDateFormat.getInstance();
      
      // When we call toString() on the instance
      String string = instance.toString();
      
      // Then the resulting string should be the expected format and locale
      assertEquals("FastDateFormat[M/d/yy h:mm a,en,GMT]", string);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLocale() throws Throwable  {
      // Given a FastDateFormat instance
      FastDateFormat dateFormat = FastDateFormat.getInstance();
      
      // When I get the locale of the instance
      Locale currentLocale = dateFormat.getLocale();
      
      // Then the locale's variant should be an empty string
      assertEquals("", currentLocale.getVariant());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseObjectReturningNonNull() throws Throwable  {
      // Given a FastDateFormat instance
      FastDateFormat instance = FastDateFormat.getInstance();
      
      // And a parse position
      ParsePosition arg1 = new ParsePosition(0);
      
      // When parsing a date string with the instance
      Object parseObject = instance.parseObject("12/31/99 11:59 PM", arg1);
      
      // Then the parsed object should be equal to the expected value
      assertEquals("Fri Feb 14 20:21:21 GMT 2014", parseObject.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateTimeInstanceTaking2Arguments() throws Throwable  {
      // Given: A FastDateFormat object with a customized format pattern
      FastDateFormat dateTimeInstance = FastDateFormat.getDateTimeInstance(0, 0);
      
      // When: Parsing the input string using the FastDateFormat instance
      ParsePosition arg1 = new ParsePosition(0);
      Date parse = dateTimeInstance.parse("^aSvO'A8", arg1);
      
      // Then: Assert that the parsed value is null
      assertNull(parse);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPattern() throws Throwable  {
      // This test is to check that the correct pattern is being used for the FastDateFormat instance.
      FastDateFormat instance = FastDateFormat.getInstance();
      String pattern = instance.getPattern();
      assertEquals("M/d/yy h:mm a", pattern);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetTimeInstanceTakingIntAndParseTakingString() throws Throwable  {
      // Given a FastDateFormat object for time instance
      FastDateFormat timeInstance = FastDateFormat.getTimeInstance(0);
      
      // And a date string in the format of "11:59:59 PM GMT"
      String inputDateString = "11:59:59 PM GMT";
      
      // When parsing the date string using the FastDateFormat object
      Date parsedDate = timeInstance.parse(inputDateString);
      
      // Then the resulting Date object should represent the correct date
      assertEquals("Fri Feb 14 20:21:21 GMT 2014", parsedDate.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetDateInstanceTaking1And1AndGetInstanceTaking3Arguments() throws Throwable  {
      // Given
      Locale arg2 = Locale.ROOT;
      FastDateFormat dateInstance = FastDateFormat.getDateInstance(0, arg2);
      
      // When
      TimeZone arg1 = dateInstance.getTimeZone();
      FastDateFormat instance = FastDateFormat.getInstance("a", arg1, arg2);
      
      // Then
      assertEquals(3, FastDateFormat.SHORT);
  }
}
