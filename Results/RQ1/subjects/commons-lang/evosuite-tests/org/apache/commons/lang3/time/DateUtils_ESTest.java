/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Mar 18 17:11:54 GMT 2024
 */

package org.apache.commons.lang3.time;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.text.ParseException;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.TimeZone;
import org.apache.commons.lang3.time.DateUtils;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.util.MockCalendar;
import org.evosuite.runtime.mock.java.util.MockDate;
import org.evosuite.runtime.mock.java.util.MockGregorianCalendar;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class DateUtils_ESTest extends DateUtils_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncatedCompareToTaking2DatesAnd1ReturningPositive() throws Throwable  {
      // Test that the truncated compare to method returns the correct result
      // when comparing two dates with different precisions
      MockDate arg0 = new MockDate();
      Date arg1 = DateUtils.ceiling((Date) arg0, 1);
      int truncatedCompareTo = DateUtils.truncatedCompareTo((Date) arg0, arg1, 1);
      assertEquals(1, truncatedCompareTo);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncateTaking1And1ReturningCalendarWhereIsLenientIsFalse() throws Throwable  {
      // Given a calendar instance
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      
      // When the calendar is truncated to a specific date
      Calendar truncatedCalendar = DateUtils.truncate((Calendar) arg0, 0);
      
      // Then the resulting calendar should be equal to a new calendar instance with the same date but no time information
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=true,lenient=false,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=1,MONTH=0,WEEK_OF_YEAR=1,WEEK_OF_MONTH=1,DAY_OF_MONTH=1,DAY_OF_YEAR=1,DAY_OF_WEEK=4,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]", truncatedCalendar.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundTaking1And1ReturningCalendarWhereGetMinimalDaysInFirstWeekIsZero() throws Throwable  {
      // Given a calendar with a time value of 1392409281320 and minimal days in first week set to 0
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      arg0.setMinimalDaysInFirstWeek(0);
      
      // When the calendar is rounded to a resolution of 14 milliseconds
      Calendar round = DateUtils.round((Calendar) arg0, 14);
      
      // Then the returned calendar should not be equal to the original calendar
      assertNotSame(round, arg0);
      
      // And the string representation of the returned calendar should match the expected value
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=0,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=320,ZONE_OFFSET=0,DST_OFFSET=0]", round.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundTaking1And1ReturningCalendarWhereGetMinimalDaysInFirstWeekIsNegative() throws Throwable  {
      // No Comments were added
      MockGregorianCalendar arg0 = new MockGregorianCalendar(2, 2, 2);
      arg0.setMinimalDaysInFirstWeek((-729));
      Calendar round = DateUtils.round((Calendar) arg0, 13);
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=-62099049600000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=-729,ERA=1,YEAR=2,MONTH=2,WEEK_OF_YEAR=10,WEEK_OF_MONTH=1,DAY_OF_MONTH=2,DAY_OF_YEAR=61,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]", round.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundTaking1And1ReturningCalendarWhereGetFirstDayOfWeekIsNegative() throws Throwable  {
      // Given a Calendar instance with the first day of week set to -15
      Calendar arg0 = MockCalendar.getInstance();
      arg0.setFirstDayOfWeek((-15));
      
      // When rounding the Calendar instance with a precision of 0
      Calendar round = DateUtils.round(arg0, 0);
      
      // Then the rounded Calendar instance should have the same values as the original instance
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=-15,minimalDaysInFirstWeek=1,ERA=1,YEAR=1,MONTH=0,WEEK_OF_YEAR=1,WEEK_OF_MONTH=1,DAY_OF_MONTH=1,DAY_OF_YEAR=1,DAY_OF_WEEK=4,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]", round.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateStrictlyTaking2Arguments() throws Throwable  {
      // rollbacked to evosuite
      String[] arg1 = new String[2];
      arg1[0] = "";
      Date parseDateStrictly = DateUtils.parseDateStrictly("", arg1);
      assertEquals("Fri Feb 14 20:21:21 GMT 2014", parseDateStrictly.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateTaking3Arguments() throws Throwable  {
      // rollbacked to evosuite
      Locale arg1 = Locale.PRC;
      String[] arg2 = new String[6];
      arg2[0] = "<";
      Date parseDate = DateUtils.parseDate("<", arg1, arg2);
      assertEquals("Fri Feb 14 20:21:21 GMT 2014", parseDate.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameDayTaking2DatesReturningFalse() throws Throwable  {
      // Arrange
      MockDate mockDate = new MockDate(274, 274, 274);
      Date inputDate = DateUtils.ceiling((Date) mockDate, 0);
      
      // Act
      boolean sameDay = DateUtils.isSameDay(inputDate, (Date) mockDate);
      
      // Assert
      assertEquals("Sat Jan 01 00:00:00 GMT 1", inputDate.toString());
      assertFalse(sameDay);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInSecondsTaking1And1ReturningZeroAndGetFragmentInSecondsTaking1And10() throws Throwable  {
      // Given a date with the year 1716 and month/day as (-1)
      MockDate mockDate = new MockDate(1716, -1, -1);
      
      // When the method getFragmentInSeconds is called on the date object with a fragment of 12 seconds
      long fragmentInSeconds = DateUtils.getFragmentInSeconds((Date) mockDate, 12);
      
      // Then the result should be 0L, as the given date does not have any fragments of 12 seconds
      assertEquals(0L, fragmentInSeconds);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInSecondsTaking1And1ReturningPositiveAndGetFragmentInSecondsTaking1And10() throws Throwable  {
      // Arrange
      MockDate mockDate = new MockDate(285, 285, 852, 285, 1);
      
      // Act
      long fragmentInSeconds = DateUtils.getFragmentInSeconds((Date) mockDate, 1);
      
      // Assert
      assertEquals(3531660L, fragmentInSeconds);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInSecondsTaking1And1ReturningZeroAndGetFragmentInSecondsTaking1And11() throws Throwable  {
      // Create a mock Gregorian calendar with some test data
      MockGregorianCalendar mockCal = new MockGregorianCalendar();
      mockCal.set(2022, 5, 13, 14, 30);
      
      // Call the method being tested
      long fragmentInSeconds = DateUtils.getFragmentInSeconds((Calendar) mockCal, 13);
      
      // Verify the result
      assertEquals(0L, fragmentInSeconds);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInSecondsTaking1And1ReturningPositiveAndGetFragmentInSecondsTaking1And11() throws Throwable  {
      // Given a MockGregorianCalendar instance
      MockGregorianCalendar calendar = new MockGregorianCalendar();
      
      // When we get the fragment in seconds of the Calendar instance
      long fragmentInSeconds = DateUtils.getFragmentInSeconds((Calendar) calendar, 1);
      
      // Then we assert that the value is equal to a specific value
      assertEquals(3874881L, fragmentInSeconds);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInMinutesTaking1And1ReturningZeroAndGetFragmentInMinutesTaking1And10() throws Throwable  {
      // Set up the test data
      MockGregorianCalendar calendar = new MockGregorianCalendar();
      
      // Execute the method under test
      long fragmentInMinutes = DateUtils.getFragmentInMinutes(calendar, 14);
      
      // Verify the results
      assertEquals(0L, fragmentInMinutes);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInMillisecondsTaking1And1ReturningZeroAndGetFragmentInMillisecondsTaking1And10() throws Throwable  {
      // Given a date with year, month, day, hour, and minute set to -1
      MockGregorianCalendar mockGregorianCalendar = new MockGregorianCalendar(-1, 8, -1, -1, 217);
      
      // When the getGregorianChange method is called on this date
      Date arg0 = mockGregorianCalendar.getGregorianChange();
      
      // Then the fragment in milliseconds is equal to 0L
      long fragmentInMilliseconds = DateUtils.getFragmentInMilliseconds(arg0, 14);
      assertEquals(0L, fragmentInMilliseconds);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInMillisecondsTaking1And1ReturningPositiveAndGetFragmentInMillisecondsTaking1And10() throws Throwable  {
      // Set up a mock GregorianCalendar object with a specific date and time
      MockGregorianCalendar calendar = new MockGregorianCalendar();
      calendar.set(2022, Calendar.JANUARY, 1, 10, 30, 0); // January 1, 2022, 10:30 AM
      
      // Call the getFragmentInMilliseconds method with a Calendar object and a fragment of 12 (which represents hours)
      long fragmentInMilliseconds = DateUtils.getFragmentInMilliseconds((Calendar) calendar, 12);
      
      // Assert that the result is equal to 21320 milliseconds (corresponding to 12 hours)
      assertEquals(21320L, fragmentInMilliseconds);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInHoursTaking1And1ReturningPositiveAndGetFragmentInHoursTaking1And10() throws Throwable  {
      // Test that DateUtils.getFragmentInHours returns the correct number of hours for a given date
      String[] arg2 = new String[1];
      arg2[0] = "";
      Date arg0 = DateUtils.parseDateStrictly("", (Locale) null, arg2);
      long fragmentInHours = DateUtils.getFragmentInHours(arg0, 1);
      assertEquals(1076L, fragmentInHours);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInHoursTaking1And1ReturningZeroAndGetFragmentInHoursTaking1And10() throws Throwable  {
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      arg0.set(2023, 2, 13); // March 13th, 2023
      long fragmentInHours = DateUtils.getFragmentInHours((Calendar) arg0, 13);
      assertEquals(0L, fragmentInHours);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInDaysTaking1And1AndGetFragmentInDaysTaking1And1AndGetFragmentInDaysTaking1And1ReturningPositive() throws Throwable  {
      MockGregorianCalendar calendar = new MockGregorianCalendar();
      long fragmentInDays = DateUtils.getFragmentInDays(calendar, 2);
      assertEquals(14L, fragmentInDays);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCeilingTaking1And1ReturningCalendarWhereGetFirstDayOfWeekIsNegative() throws Throwable  {
      // Given a MockGregorianCalendar with specific fields set
      MockGregorianCalendar arg0 = new MockGregorianCalendar(2, 2, 2, 2, 2);
      arg0.setFirstDayOfWeek((-3584));
      
      // When we ceil the calendar to a specific unit (in this case 2)
      Calendar ceiling = DateUtils.ceiling((Calendar) arg0, 2);
      
      // Then the result should be a MockGregorianCalendar with the correct fields set
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=-3584,minimalDaysInFirstWeek=1,ERA=1,YEAR=2,MONTH=3,WEEK_OF_YEAR=9,WEEK_OF_MONTH=1,DAY_OF_MONTH=1,DAY_OF_YEAR=60,DAY_OF_WEEK=4,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]", ceiling.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddSeconds() throws Throwable  {
      // Given a date object "arg0"
      MockDate arg0 = new MockDate();
      
      // When adding 812 seconds to the date object
      Date addSeconds = DateUtils.addSeconds(arg0, 812);
      
      // Then the resulting date object should be equivalent to "Fri Feb 14 20:34:53 GMT 2014"
      assertEquals("Fri Feb 14 20:34:53 GMT 2014", addSeconds.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And10() throws Throwable  {
      // Given a calendar object with the date set to 4-04-2004 04:04:04
      MockGregorianCalendar arg0 = new MockGregorianCalendar(2004, 3, 4, 4, 4, 4);
      
      // When the iterator is called on the calendar object with a date of 4-04-2004 04:04:04
      DateUtils.iterator((Calendar) arg0, 4);
      
      // Then assert that the toString method returns the expected value for the calendar object
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=-62030433356000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=4,MONTH=4,WEEK_OF_YEAR=19,WEEK_OF_MONTH=2,DAY_OF_MONTH=4,DAY_OF_YEAR=125,DAY_OF_WEEK=1,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=4,HOUR_OF_DAY=4,MINUTE=4,SECOND=4,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And11() throws Throwable  {
      // No Comments were added
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      DateUtils.iterator((Calendar) arg0, 3);
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=320,ZONE_OFFSET=0,DST_OFFSET=0]", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And12() throws Throwable  {
      // Given a MockGregorianCalendar object
      MockGregorianCalendar calendar = new MockGregorianCalendar();
      
      // When iterating over the dates using DateUtils.iterator()
      Iterator<Calendar> dateIterator = DateUtils.iterator((Calendar) calendar, 1);
      
      // Then assert that an iterator was returned
      assertNotNull(dateIterator);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameDayTaking2CalendarsReturningTrue() throws Throwable  {
      // No Comments were added
      MockGregorianCalendar arg1 = new MockGregorianCalendar();
      boolean sameDay = DateUtils.isSameDay((Calendar) arg1, (Calendar) arg1);
      assertTrue(sameDay);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncatedCompareToTaking2CalendarsAnd1() throws Throwable  {
      // rollbacked to evosuite
      MockGregorianCalendar arg1 = new MockGregorianCalendar(2001, 2, 3, 4, 5);
      int truncatedCompareTo = DateUtils.truncatedCompareTo((Calendar) arg1, (Calendar) arg1, 2);
      assertEquals(0, truncatedCompareTo);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncatedCompareToTaking2DatesAnd1ReturningZero() throws Throwable  {
      // Setup
      MockDate arg1 = new MockDate();
      
      // Execute
      int truncatedCompareTo = DateUtils.truncatedCompareTo((Date) arg1, (Date) arg1, 1);
      
      // Verify
      assertEquals(0, truncatedCompareTo);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNext() throws Throwable  {
      // rollbacked to evosuite
      Locale arg0 = Locale.CHINESE;
      Calendar arg1 = MockCalendar.getInstance(arg0);
      DateUtils.DateIterator dateUtils_DateIterator = new DateUtils.DateIterator(arg1, arg1);
      // Undeclared exception!
      try { 
        dateUtils_DateIterator.next();
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.lang3.time.DateUtils$DateIterator", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncatedEqualsTaking2DatesAnd1ReturningFalse() throws Throwable  {
      // Given a date with day, month and year values of 274, 274, 274
      MockDate arg1 = new MockDate(274, 274, 274);
      
      // When comparing the date to another date with the same values but in a different object
      MockDate arg0 = new MockDate();
      boolean truncatedEquals = DateUtils.truncatedEquals((Date) arg0, (Date) arg1, 5);
      
      // Then the dates are not equal because of the difference in the number of milliseconds
      assertFalse(truncatedEquals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncatedEqualsTaking2CalendarsAnd1ReturningFalse() throws Throwable  {
      // Set up the test fixture
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      
      // Truncate the calendar to the day level (i.e., remove the time part)
      Calendar arg1 = DateUtils.truncate((Calendar) arg0, 2);
      
      // Check that the truncated calendar is equal to the original calendar, up to the day level
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=1,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]", arg1.toString());
      
      // Check that the truncated calendar is not equal to the original calendar, up to the day level
      assertFalse(DateUtils.truncatedEquals((Calendar) arg0, arg1, 2));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInDaysTaking1And1AndGetFragmentInDaysTaking1And1AndGetFragmentInDaysTaking1And1ReturningZero() throws Throwable  {
      // Test the getFragmentInDays method with a date that is 14 days in the future
      MockDate arg0 = new MockDate();
      long fragmentInDays = DateUtils.getFragmentInDays((Date) arg0, 14);
      assertEquals(0L, fragmentInDays);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInMinutesTaking1And1ReturningZeroAndGetFragmentInMinutesTaking1And11() throws Throwable  {
      // Given a Date object that represents the current date
      MockDate mockCurrentDate = new MockDate(883, 883, 883);
      
      // When the fragment in minutes is calculated using the getFragmentInMinutes method
      long fragmentInMinutes = DateUtils.getFragmentInMinutes((Date) mockCurrentDate, 13);
      
      // Then the fragment should be zero
      assertEquals(0L, fragmentInMinutes);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInSecondsTaking1And1ThrowsIllegalArgumentException0() throws Throwable  {
      // Arrange
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      
      try {
      // Act
      DateUtils.getFragmentInSeconds((Calendar) arg0, 10);
      
      // Assert
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the correct exception was thrown
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInSecondsTaking1And1ThrowsIllegalArgumentException1() throws Throwable  {
      // Given a mock Gregorian calendar object
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      
      // When we try to get the fragment in seconds with an unsupported fragment (9)
      try {
      DateUtils.getFragmentInSeconds((Calendar) arg0, 9);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Then we expect the method to throw an IllegalArgumentException because the fragment is not supported
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInDaysTaking1And1ThrowsIllegalArgumentException0() throws Throwable  {
      // This test case verifies that a IllegalArgumentException is thrown when the fragment is not supported.
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      
      try {
      DateUtils.getFragmentInDays((Calendar) arg0, 8);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // The fragment 8 is not supported. This is expected to throw an IllegalArgumentException.
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInMinutesTaking1And1ReturningPositiveAndGetFragmentInMinutesTaking1And10() throws Throwable  {
      // No Comments were added
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      long fragmentInMinutes = DateUtils.getFragmentInMinutes((Calendar) arg0, 5);
      assertEquals(1221L, fragmentInMinutes);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInHoursTaking1And1ThrowsIllegalArgumentException() throws Throwable  {
      // Arrange
      MockDate arg0 = new MockDate(2143);
      
      // Act and Assert
      try {
      DateUtils.getFragmentInHours((Date) arg0, 4);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // The fragment 4 is not supported
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInDaysTaking1And1ThrowsIllegalArgumentException1() throws Throwable  {
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      // Undeclared exception!
      try {
      DateUtils.getFragmentInDays((Calendar) arg0, 3);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      // The fragment 3 is not supported
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInDaysTaking1And1WithNull() throws Throwable  {
      // Test for DateUtils.getFragmentInDays with a null calendar throws IllegalArgumentException
      try {
      DateUtils.getFragmentInDays((Calendar) null, 27);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // The date must not be null
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInSecondsTaking1And1ThrowsIllegalArgumentExceptionAndGetFragmentInSecondsTaking1And1() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.getFragmentInSeconds((Date) null, 2013);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And1ThrowsIllegalArgumentExceptionAndIteratorTaking1And10() throws Throwable  {
      // Test that an IllegalArgumentException is thrown when using an invalid range style in DateUtils.iterator()
      Calendar mockCalendar = MockCalendar.getInstance();
      try {
      // Try to create an iterator for a date range using a negative number as the last day of the range
      DateUtils.iterator((Object) mockCalendar, (-1039));
      
      // Assert that no exception was thrown
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the correct exception was thrown
      verifyException("org.apache.commons.lang3.time.DateUtils", e);
      
      // Assert that the message of the exception is what we expect
      assertEquals("Range style -1039 is not valid.", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And1ThrowsClassCastException() throws Throwable  {
      // Test that we can't iterate a date using the incorrect locale fr_FR
      Locale arg0 = Locale.FRANCE;
      try {
      DateUtils.iterator((Object) arg0, 2104533975);
      fail("Expecting exception: ClassCastException");
      } catch(ClassCastException e) {
      // We expect an exception since we are trying to iterate a date using the incorrect locale fr_FR.
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And1WithNullAndIteratorTaking1And1ThrowsIllegalArgumentException0() throws Throwable  {
      // Undeclared exception!
      try {
      DateUtils.iterator((Object) null, (-365));
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      //
      // The date must not be null
      //
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And13() throws Throwable  {
      // Given: We have a GregorianCalendar instance called "arg0"
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      
      // When: We use the DateUtils.iterator method to create an iterator over a sequence of 4 dates starting from the current date
      Iterator<Calendar> iterator = DateUtils.iterator((Calendar) arg0, 4);
      
      // Then: The resulting iterator should not be null
      assertNotNull(iterator);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And1AndIteratorTaking1And1AndIteratorTaking1And1ReturningNonNull0() throws Throwable  {
      // Given a MockDate object representing March 1st, 2003
      MockDate mockDate = new MockDate(3, 1, 2003);
      
      // When creating an iterator for the date with a step of 3 months
      Iterator<Calendar> iterator = DateUtils.iterator((Date) mockDate, 3);
      
      // Then assert that the iterator is not null
      assertNotNull(iterator);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And1ThrowsIllegalArgumentExceptionAndIteratorTaking1And11() throws Throwable  {
      // rollbacked to evosuite
      MockGregorianCalendar arg0 = new MockGregorianCalendar(2015, 12, 31, 23, 59, 59);
      // Undeclared exception!
      try { 
        DateUtils.iterator((Calendar) arg0, 1000);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The range style 1000 is not valid.
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And14() throws Throwable  {
      // Set up the calendar object with a specific date and time
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      arg0.set(2014, 1, 14, 8, 21, 21); // March 14th, 2014 at 8:21 AM
      
      // Use the DateUtils.iterator() method to iterate over the calendar object and set the fields
      DateUtils.iterator((Calendar) arg0, 6);
      
      // Assert that the expected fields are set on the calendar object
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=320,ZONE_OFFSET=0,DST_OFFSET=0]", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And15() throws Throwable  {
      // Given: A mock Gregorian calendar with a specific date and time
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      
      // When: Iterating over the dates in the calendar with a specified interval of 5 days
      Iterator<Calendar> iterator = DateUtils.iterator((Calendar) arg0, 5);
      
      // Then: The iterator should not be null
      assertNotNull(iterator);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And16() throws Throwable  {
      // Create a mock Gregorian calendar for December 31, 1995
      MockGregorianCalendar arg0 = new MockGregorianCalendar(1995, 12, 31);
      
      // Call the iterator method on the calendar with a period of two days
      DateUtils.iterator((Calendar) arg0, 2);
      
      // Check that the resulting string representation of the calendar matches our expectations
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=false,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=?,YEAR=1995,MONTH=12,WEEK_OF_YEAR=?,WEEK_OF_MONTH=?,DAY_OF_MONTH=31,DAY_OF_YEAR=?,DAY_OF_WEEK=?,DAY_OF_WEEK_IN_MONTH=?,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=0,MILLISECOND=?,ZONE_OFFSET=?,DST_OFFSET=?]", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And1WithNullAndIteratorTaking1And1ThrowsIllegalArgumentException1() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.iterator((Calendar) null, 5);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And1ThrowsIllegalArgumentExceptionAndIteratorTaking1And12() throws Throwable  {
      // Test that an exception is thrown when trying to iterate over a null date
      try {
      DateUtils.iterator((Date) null, 1);
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      // Verify that the correct exception was thrown
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCeilingTaking1And1ReturningCalendarWhereGetFirstDayOfWeekIsPositive() throws Throwable  {
      // rollbacked to evosuite
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      Calendar ceiling = DateUtils.ceiling((Calendar) arg0, 9);
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392422400000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=15,DAY_OF_YEAR=46,DAY_OF_WEEK=7,DAY_OF_WEEK_IN_MONTH=3,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]", ceiling.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCeilingTaking1And1AndCeilingTaking1And1() throws Throwable  {
      // Set up the mock date for testing
      MockDate mockDate = new MockDate(2137);
      
      // Call the ceiling method with a 9-day interval
      Date ceiling = DateUtils.ceiling(mockDate, 9);
      
      // Assert that the resulting date is correct
      assertEquals("Thu Jan 01 12:00:00 GMT 1970", ceiling.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCeilingTaking1And10() throws Throwable  {
      // rollbacked to evosuite
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      Date ceiling = DateUtils.ceiling((Object) arg0, 1001);
      assertEquals("Sun Feb 16 00:00:00 GMT 2014", ceiling.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCeilingTaking1And11() throws Throwable  {
      // Given a GregorianCalendar object with the date set to July 30, 2010 at 12:34 PM
      MockGregorianCalendar arg0 = new MockGregorianCalendar(2010, 6, 30, 12, 34);
      
      // When the ceiling method is called with a time unit of 1001 (milliseconds)
      Date ceiling = DateUtils.ceiling((Object) arg0, 1001);
      
      // Then the resulting date should be July 1, 2010 at 12:34 AM, rounded up to the nearest millisecond
      assertEquals("Thu Jul 01 00:00:00 GMT 2010", ceiling.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncateTaking1And1AndTruncateTaking1And1AndTruncateTaking1And1ReturningNonNull0() throws Throwable  {
      // Test that DateUtils.truncate() returns a date truncated to 12-hour format
      MockDate arg0 = new MockDate();
      Date truncate = DateUtils.truncate((Date) arg0, 12);
      assertEquals("Fri Feb 14 20:21:00 GMT 2014", truncate.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCeilingTaking1And1ThrowsIllegalArgumentException() throws Throwable  {
      // Given: A Date object with the value of 1747L and a unit of 1642 (which is not supported)
      MockDate arg0 = new MockDate(1747L);
      try {
      // When: Trying to ceil the date with an unsupported unit
      DateUtils.ceiling((Object) arg0, 1642);
      } catch(IllegalArgumentException e) {
      // Then: An IllegalArgumentException is thrown indicating that the field is not supported
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And1ThrowsArithmeticException() throws Throwable  {
      MockDate arg0 = new MockDate(280000000, 280000000, 280000000);
      // Tests whether an arithmetic exception is thrown when calculating the next month for a date with a large calendar value.
      try {
      DateUtils.iterator((Date) arg0, 4);
      fail("Expecting exception: ArithmeticException");
      } catch(ArithmeticException e) {
      // Asserts that an arithmetic exception is thrown when calculating the next month for a date with a large calendar value.
      assertTrue(e instanceof ArithmeticException);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCeilingTaking1And1ThrowsClassCastException() throws Throwable  {
      // Given: An object argument 'arg0' that is not a valid date type
      Object arg0 = new Object();
      
      // When: The method is called with an invalid date type as the first argument
      DateUtils.ceiling(arg0, 173);
      
      // Then: A ClassCastException should be thrown indicating that the method cannot find the ceiling of a non-date type
      try {
      fail("Expecting exception: ClassCastException");
      } catch (ClassCastException e) {
      //
      // Could not find ceiling of for type: class java.lang.Object
      //
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCeilingTaking1And1WithNull() throws Throwable  {
      // Test that the DateUtils.ceiling() method throws an IllegalArgumentException when passed a null date
      try {
      // Undeclared exception!
      DateUtils.ceiling((Object) null, 2578);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // The date must not be null
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCeilingTaking1And1ThrowsIllegalArgumentExceptionAndCeilingTaking1And10() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.ceiling((Calendar) null, 4);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCeilingTaking1And1ThrowsIllegalArgumentExceptionAndCeilingTaking1And11() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.ceiling((Date) null, (-1336));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncateTaking1And1ThrowsClassCastException() throws Throwable  {
      Object arg0 = new Object(); // Undeclared exception!
      
      try {
      DateUtils.truncate(arg0, 20);
      fail("Expecting exception: ClassCastException");
      } catch(ClassCastException e) {
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncateTaking1And1AndTruncateTaking1And1AndTruncateTaking1And1ReturningNonNull1() throws Throwable  {
      // rollbacked to evosuite
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      Date truncate = DateUtils.truncate((Object) arg0, 1001);
      assertEquals("Fri Feb 14 00:00:00 GMT 2014", truncate.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncateTaking1And1WithNullAndNegative() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.truncate((Object) null, (-2128));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncateTaking1And1ThrowsIllegalArgumentException() throws Throwable  {
      MockDate mockDate = new MockDate();
      // Given: a date object and an invalid field value (499)
      try {
      DateUtils.truncate((Object)mockDate, 499);
      // When: the truncate method is called with the invalid field value
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Then: a IllegalArgumentException should be thrown
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncateTaking1And1ThrowsIllegalArgumentExceptionAndTruncateTaking1And10() throws Throwable  {
      // Verify that passing null as the date parameter throws an IllegalArgumentException
      try {
      DateUtils.truncate((Calendar) null, (-4875));
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // The date must not be null
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncateTaking1And1ThrowsIllegalArgumentExceptionAndTruncateTaking1And11() throws Throwable  {
      // Undeclared exception!
      try {
      // Truncate a date with a negative time zone offset (2884 minutes)
      DateUtils.truncate((Date) null, (-2884));
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      //
      // The date must not be null
      //
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundTaking1And10() throws Throwable  {
      // rollbacked to evosuite
      MockGregorianCalendar arg0 = new MockGregorianCalendar(2, 2, 2, 2, 2);
      Date round = DateUtils.round((Object) arg0, 1001);
      assertEquals("Thu Mar 02 00:00:00 GMT 2", round.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundTaking1And11() throws Throwable  {
      // Given a date object with the value "Fri Feb 14 20:21:21 GMT 2014"
      MockDate arg0 = new MockDate();
      
      // When the round() method is called on this date object, rounding it to the nearest day (14th of February)
      Date round = DateUtils.round((Object) arg0, 14);
      
      // Then the resulting date should be "Fri Feb 14 20:21:21 GMT 2014"
      assertEquals("Fri Feb 14 20:21:21 GMT 2014", round.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundTaking1And1ThrowsIllegalArgumentExceptionAndRoundTaking1And1AndRoundTaking1And1WithNull0() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.round((Object) null, (-735));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundTaking1And1ThrowsClassCastException() throws Throwable  {
      // rollbacked to evosuite
      Locale arg0 = Locale.PRC;
      // Undeclared exception!
      try { 
        DateUtils.round((Object) arg0, 1001);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // Could not round zh_CN
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundTaking1And1ThrowsIllegalArgumentExceptionAndRoundTaking1And1AndRoundTaking1And1WithNull1() throws Throwable  {
      // When a null calendar is passed to the round method
      try {
      DateUtils.round((Calendar) null, 1);
      fail("Expecting exception: IllegalArgumentException");
      } catch (IllegalArgumentException e) {
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundTaking1And1ThrowsIllegalArgumentExceptionAndRoundTaking1And1AndRoundTaking1And1WithNull2() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.round((Date) null, (-2609));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundTaking1And1AndRoundTaking1And1() throws Throwable  {
      // Setup
      MockDate arg0 = new MockDate((-119151112946000L));
      
      // Execute
      Date round = DateUtils.round((Date) arg0, 11);
      
      // Verify
      assertEquals("Wed Apr 18 05:00:00 GMT 1807", round.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetYearsThrowsIllegalArgumentException() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.setYears((Date) null, 0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateStrictlyTaking2ArgumentsThrowsNullPointerException() throws Throwable  {
      // No Comments were added
      String[] arg1 = new String[2];
      arg1[0] = "(}X8ZZ";
      // Undeclared exception!
      try { 
        DateUtils.parseDateStrictly("(}X8ZZ", arg1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateTaking2ArgumentsThrowsParseException() throws Throwable  {
      // rollbacked to evosuite
      String[] arg1 = new String[1];
      arg1[0] = "";
      try { 
        DateUtils.parseDate("Y?I~ZZ", arg1);
        fail("Expecting exception: ParseException");
      
      } catch(ParseException e) {
         //
         // Unable to parse the date: Y?I~ZZ
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateStrictlyTaking2ArgumentsWithNull() throws Throwable  {
      // Undeclared exception!
      try {
      /*
      * The following line of code throws an IllegalArgumentException because the Date and Patterns are null.
      */
      DateUtils.parseDateStrictly((String) null, (String[]) null);
      /*
      * This assertion is expected to fail since a NullPointerException was thrown by the previous line of code.
      */
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      /*
      * Verifies that the exception is an instance of IllegalArgumentException, which is expected.
      */
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameLocalTimeAndTruncateTaking1And10() throws Throwable  {
      // Given a GregorianCalendar object with a specific date and time
      MockGregorianCalendar calendar = new MockGregorianCalendar(2, 2, 2);
      
      // When the calendar is truncated to the given field
      Calendar truncatedCalendar = DateUtils.truncate((Calendar) calendar, 2);
      
      // Then the calendar's time should be truncated to the given field
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2,MONTH=2,WEEK_OF_YEAR=9,WEEK_OF_MONTH=1,DAY_OF_MONTH=1,DAY_OF_YEAR=61,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]", truncatedCalendar.toString());
      
      // And the calendar's time should not be the same as before
      boolean sameLocalTime = DateUtils.isSameLocalTime(calendar, truncatedCalendar);
      assertFalse(sameLocalTime);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameLocalTime0() throws Throwable  {
      // Given two GregorianCalendars, arg0 and arg1, representing different dates in the past
      MockGregorianCalendar arg0 = new MockGregorianCalendar((-201), (-201), (-2420), 1410, 0);
      MockGregorianCalendar arg1 = new MockGregorianCalendar(1410, 13, (-1));
      
      // When we check if they have the same local time
      boolean sameLocalTime = DateUtils.isSameLocalTime(arg0, arg1);
      
      // Then we expect that they do not have the same local time
      assertFalse(sameLocalTime);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameLocalTimeAndTruncateTaking1And11() throws Throwable  {
      // Set up the calendar with a specific date and time
      MockGregorianCalendar arg0 = new MockGregorianCalendar(2, 2, 2, 2, 2);
      
      // Truncate the calendar to a specific field
      Calendar arg1 = DateUtils.truncate((Calendar) arg0, 2);
      
      // Check if the truncated calendar has the same local time as the original one
      boolean sameLocalTime = DateUtils.isSameLocalTime(arg0, arg1);
      
      // Assert that the truncated calendar does not have the same local time as the original one
      assertFalse(sameLocalTime);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameLocalTime1() throws Throwable  {
      // Given two dates with different local times
      MockGregorianCalendar date1 = new MockGregorianCalendar((-201), (-2420), (-201), 0, 1410, (-201));
      MockGregorianCalendar date2 = new MockGregorianCalendar(1410, 13, 11);
      
      // When we compare the two dates for local time equality
      boolean sameLocalTime = DateUtils.isSameLocalTime(date1, date2);
      
      // Then we expect the comparison to return false
      assertFalse(sameLocalTime);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameLocalTimeReturningTrue() throws Throwable  {
      // Given two GregorianCalendars with the same local time and date
      MockGregorianCalendar arg1 = new MockGregorianCalendar(0, 1410, (-201), 0, 1410, (-201));
      MockGregorianCalendar arg2 = new MockGregorianCalendar(0, 1410, (-201), 0, 1410, (-201));
      
      // When we call isSameLocalTime with these arguments
      boolean sameLocalTime = DateUtils.isSameLocalTime(arg1, arg2);
      
      // Then the method should return true, indicating that the two calendars have the same local time and date
      assertTrue(sameLocalTime);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameLocalTimeThrowsIllegalArgumentException() throws Throwable  {
      // Test that DateUtils.isSameLocalTime throws an IllegalArgumentException when called with null date
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      // Expecting exception because date parameter is null
      try {
      DateUtils.isSameLocalTime(arg0, (Calendar) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the correct exception is thrown
      verifyException("org.apache.commons.lang3.time.DateUtils", e);
      // Verify that the expected message is included in the exception
      assertTrue(e.getMessage().contains("date parameter must not be null"));}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameLocalTimeWithNull() throws Throwable  {
      // Test that an IllegalArgumentException is thrown when either date is null
      try {
      DateUtils.isSameLocalTime((Calendar) null, (Calendar) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      //
      // The date must not be null
      //
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameInstantTaking2CalendarsReturningFalse() throws Throwable  {
      // Given two Calendar instances, one representing the current date and time,
      // and the other representing a specific date and time in the future.
      Calendar now = MockCalendar.getInstance();
      MockGregorianCalendar futureDate = new MockGregorianCalendar(2023, 5, 14);
      
      // When we compare these two Calendar instances using DateUtils.isSameInstant(),
      // we expect the method to return false since the current date and time is not the same
      // as the future date and time.
      boolean sameInstant = DateUtils.isSameInstant(now, (Calendar) futureDate);
      
      // Then we assert that the returned value is false, which means that the two Calendar
      // instances do not represent the same instant in time.
      assertFalse(sameInstant);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameInstantTaking2CalendarsThrowsIllegalArgumentException() throws Throwable  {
      // No Comments were added
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      // Undeclared exception!
      try { 
        DateUtils.isSameInstant((Calendar) arg0, (Calendar) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameInstantTaking2CalendarsReturningTrue() throws Throwable  {
      // Given a Calendar object and the same calendar object passed as an argument
      Calendar arg1 = MockCalendar.getInstance();
      boolean sameInstant = DateUtils.isSameInstant(arg1, arg1);
      
      // When we call isSameInstant with the same calendar object
      // Then it should return true
      assertTrue(sameInstant);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameInstantTaking2CalendarsWithNull() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.isSameInstant((Calendar) null, (Calendar) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameInstantTaking2DatesReturningTrue() throws Throwable  {
      // No Comments were added
      MockDate arg1 = new MockDate();
      boolean sameInstant = DateUtils.isSameInstant((Date) arg1, (Date) arg1);
      assertTrue(sameInstant);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameInstantTaking2DatesThrowsIllegalArgumentException() throws Throwable  {
      // rollbacked to evosuite
      MockDate arg0 = new MockDate();
      // Undeclared exception!
      try { 
        DateUtils.isSameInstant((Date) arg0, (Date) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameInstantTaking2DatesWithNull() throws Throwable  {
      // Test that an exception is thrown when the date is null
      try {
      DateUtils.isSameInstant((Date) null, (Date) null);
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // The date must not be null
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundTaking1And1ReturningCalendarWhereGetMinimalDaysInFirstWeekIsPositive() throws Throwable  {
      // Create a MockGregorianCalendar object with the date set to March 15, 2022
      MockGregorianCalendar arg1 = new MockGregorianCalendar(2022, 2, 15);
      
      // Round the Calendar object to the nearest two-day interval
      Calendar roundedDate = DateUtils.round((Calendar) arg1, 2);
      
      // Determine if the rounded date is on the same day as the original date
      boolean sameDay = DateUtils.isSameDay(roundedDate, (Calendar) arg1);
      
      // Assert that the rounded date is not on the same day as the original date
      assertFalse(sameDay);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameDayTaking2Calendars0() throws Throwable  {
      // rollbacked to evosuite
      MockGregorianCalendar arg0 = new MockGregorianCalendar(2015, 7, 16);
      MockGregorianCalendar arg1 = new MockGregorianCalendar(2014, 10, 24);
      boolean sameDay = DateUtils.isSameDay((Calendar) arg0, (Calendar) arg1);
      assertFalse(sameDay);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameDayTaking2Calendars1() throws Throwable  {
      // Set up the test data
      MockGregorianCalendar cal1 = new MockGregorianCalendar((-201), (-201), (-2420), 1410, 0);
      MockGregorianCalendar cal2 = new MockGregorianCalendar();
      
      // Execute the method under test
      boolean sameDay = DateUtils.isSameDay((Calendar) cal1, (Calendar) cal2);
      
      // Verify the results
      assertFalse(sameDay);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameDayTaking2CalendarsThrowsIllegalArgumentException() throws Throwable  {
      Calendar testCalendar = MockCalendar.getInstance();
      // Given: A calendar object is created
      
      try {
      DateUtils.isSameDay(testCalendar, (Calendar) null);
      // When: We call the method with a null value for the second argument
      
      fail("Expecting exception: IllegalArgumentException");
      
      } catch (IllegalArgumentException e) {
      // Then: An IllegalArgumentException is thrown
      
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameDayTaking2CalendarsWithNull() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.isSameDay((Calendar) null, (Calendar) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameDayTaking2DatesThrowsIllegalArgumentException() throws Throwable  {
      MockDate arg0 = new MockDate();
      // Check that passing null as a date argument throws an IllegalArgumentException
      try {
      DateUtils.isSameDay((Date) arg0, (Date) null);
      fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
      //
      // The date must not be null
      //
      verifyException("org.apache.commons.lang3.time.DateUtils", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameDayTaking2DatesReturningTrue() throws Throwable  {
      // Set up the test with two equal dates.
      MockDate arg1 = new MockDate();
      
      // Call the method and get the result.
      boolean sameDay = DateUtils.isSameDay((Date) arg1, (Date) arg1);
      
      // Verify that the result is true.
      assertTrue(sameDay);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsSameDayTaking2DatesWithNull() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.isSameDay((Date) null, (Date) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetMilliseconds() throws Throwable  {
      // No Comments were added
      String[] arg2 = new String[1];
      arg2[0] = "";
      Date arg0 = DateUtils.parseDateStrictly("", (Locale) null, arg2);
      Date setMilliseconds = DateUtils.setMilliseconds(arg0, (-835));
      assertNotSame(arg0, setMilliseconds);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncatedEqualsTaking2DatesAnd1ReturningTrue() throws Throwable  {
      // Given: we have two dates that are 5 days apart
      MockDate date1 = new MockDate(1989, 10, 14);
      MockDate date2 = new MockDate(1989, 10, 19);
      
      // When: we compare the two dates with truncatedEquals() method
      boolean truncatedEquals = DateUtils.truncatedEquals((Date) date1, (Date) date2, 5);
      
      // Then: the method returns true as the two dates are within 5 days of each other
      assertTrue(truncatedEquals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInMinutesTaking1And1ThrowsIllegalArgumentException() throws Throwable  {
      // Create a mock Gregorian calendar object
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      
      // Try to get the fragment in minutes for an unsupported fragment (1222)
      try {
      DateUtils.getFragmentInMinutes((Calendar) arg0, 1222);
      } catch(IllegalArgumentException e) {
      // Verify that the exception is thrown because of the unsupported fragment
      assertEquals("Unsupported fragment: " + 1222, e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInHoursTaking1And1ReturningPositiveAndGetFragmentInHoursTaking1And11() throws Throwable  {
      // Given a GregorianCalendar instance representing June 5, 2001 at 3:36 AM (negative timezone offset)
      MockGregorianCalendar arg0 = new MockGregorianCalendar(6, 5, 2001, 3, (-3603));
      
      // When the method getFragmentInHours is called with the Calendar instance and a fragment size of 1 hour
      long fragmentInHours = DateUtils.getFragmentInHours((Calendar) arg0, 1);
      
      // Then the result should be 7742L (the number of hours since January 1, 1970, 0:00 UTC)
      assertEquals(7742L, fragmentInHours);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetSeconds() throws Throwable  {
      // Given a date in 1997, December 25th
      MockDate arg0 = new MockDate(1997, 12, 25);
      
      // When we set the seconds to zero using DateUtils.setSeconds()
      Date setSeconds = DateUtils.setSeconds(arg0, 0);
      
      // Then we expect the date to be December 25th, 1997 at 0:00:00 GMT+3898
      assertEquals("Tue Jan 25 00:00:00 GMT 3898", setSeconds.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTruncatedEqualsTaking2CalendarsAnd1ReturningTrue() throws Throwable  {
      // Given the two calendar objects arg1 and arg2
      Calendar arg1 = MockCalendar.getInstance();
      Calendar arg2 = MockCalendar.getInstance();
      
      // When we compare them using DateUtils.truncatedEquals with a tolerance of 0
      boolean truncatedEquals = DateUtils.truncatedEquals(arg1, arg2, 0);
      
      // Then the method should return true since they are equal
      assertTrue(truncatedEquals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesDateUtilsTakingNoArguments() throws Throwable  {
      // Given: A DateUtils instance
      DateUtils dateUtils = new DateUtils();
      
      // When: Calling the MILLIS_PER_HOUR constant
      Long expectedResult = 3600000L;
      Long actualResult = DateUtils.MILLIS_PER_HOUR;
      
      // Then: The result should be equal to 1 hour in milliseconds
      assertEquals(expectedResult, actualResult);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddSecondsThrowsIllegalArgumentException() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.addSeconds((Date) null, 4);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The date must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddDays() throws Throwable  {
      // Set up some mock data for the test
      MockGregorianCalendar mockGregorianCalendar = new MockGregorianCalendar(2, 2, 2, 2, 2);
      Date arg0 = mockGregorianCalendar.getGregorianChange();
      Date arg1 = DateUtils.addDays(arg0, 13);
      
      // Call the method being tested and compare the results to what is expected
      int truncatedCompareTo = DateUtils.truncatedCompareTo(arg0, arg1, 2);
      assertEquals("Thu Oct 28 00:00:00 GMT 1582", arg1.toString());
      assertEquals((-1), truncatedCompareTo);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetDays() throws Throwable  {
      // Given: A date with the year 2155 and a day of the week (Monday)
      MockDate arg0 = new MockDate(2155);
      
      // When: The date is set to the next day
      Date setDays = DateUtils.setDays(arg0, 2);
      
      // Then: The date should be Thursday January 01, 1970
      assertEquals("Thu Jan 01 00:00:02 GMT 1970", setDays.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddWeeks() throws Throwable  {
      // Given a date with some initial value
      MockDate arg0 = new MockDate((-119151112946000L));
      
      // When we call the addWeeks method with an argument of 6 weeks
      Date result = DateUtils.addWeeks(arg0, 6);
      
      // Then we expect the result to be a date corresponding to "Wed May 30 04:37:34 GMT 1807"
      assertEquals("Wed May 30 04:37:34 GMT 1807", result.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInMinutesTaking1And1ReturningPositiveAndGetFragmentInMinutesTaking1And11() throws Throwable  {
      // Given a date with year, month, day and hour
      MockDate mockDate = new MockDate(1, 71, 32, 608, 608);
      
      // When we call getFragmentInMinutes with the date and a fragment type of HOURS
      long fragmentInMinutes = DateUtils.getFragmentInMinutes((Date) mockDate, 1);
      
      // Then the result should be the number of minutes in an hour
      assertEquals(37088L, fragmentInMinutes);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddYears() throws Throwable  {
      MockDate currentDate = new MockDate();
      // Add 2,191 years to the current date
      Date futureDate = DateUtils.addYears(currentDate, 2191);
      // Assert that the future date is the expected value
      assertEquals("Fri Feb 14 20:21:21 GMT 2014", futureDate.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddMonths() throws Throwable  {
      // Given a date of January 1st, 2010
      Date arg0 = new Date(1262304000000L);
      
      // When adding 1288 months to the date
      Date addMonths = DateUtils.addMonths(arg0, 1288);
      
      // Then the resulting date should be February 14th, 2014
      assertEquals("Fri Feb 14 20:21:21 GMT 2014", addMonths.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetMinutes() throws Throwable  {
      // rollbacked to evosuite
      String[] arg1 = new String[5];
      arg1[0] = "([-+][0-9][0-9]):([0-9][0-9])$";
      Date arg0 = DateUtils.parseDate("([-+][0-9][0-9]):([0-9][0-9])$", arg1);
      Date setMinutes = DateUtils.setMinutes(arg0, (-2766));
      assertTrue(setMinutes.equals((Object)arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInMillisecondsTaking1And1ReturningZeroAndGetFragmentInMillisecondsTaking1And11() throws Throwable  {
      // Given a GregorianCalendar object with year 2022, month 2 (February), day 2, and hour 12
      MockGregorianCalendar calendar = new MockGregorianCalendar(2022, 2, 2);
      
      // When we call the getFragmentInMilliseconds() method with the Calendar object and a fragment value of 12
      long fragmentInMilliseconds = DateUtils.getFragmentInMilliseconds((Calendar) calendar, 12);
      
      // Then the returned value should be 0L (i.e., the fragment is not considered in the calculation)
      assertEquals(0L, fragmentInMilliseconds);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddMinutes() throws Throwable  {
      // Set up the test data
      MockDate mockDate = new MockDate((-119151112946000L));
      
      // Perform the operation we want to test
      Date addMinutes = DateUtils.addMinutes(mockDate, (-824));
      
      // Verify the results
      assertEquals("Tue Apr 17 14:53:34 GMT 1807", addMinutes.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetMonths() throws Throwable  {
      // Set the current date to May 12th, 2021 at 10:30:45 AM
      MockDate arg0 = new MockDate(2021, 5, 12, 10, 30, 45);
      
      // Set the number of months to add to the current date
      int numMonths = 6;
      
      // Use the DateUtils.setMonths() method to set the number of months to add to the current date
      Date setMonths = DateUtils.setMonths(arg0, numMonths);
      
      // Assert that the resulting date is equal to May 12th, 3921 at 10:30:45 AM
      assertEquals("Sun Jun 12 10:30:45 GMT 3921", setMonths.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testParseDateStrictlyTaking2ArgumentsThrowsIllegalArgumentException() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        DateUtils.parseDateStrictly("2022-01-01", (String[]) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Date and Patterns must not be null
         //
         verifyException("org.apache.commons.lang3.time.DateUtils", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInMillisecondsTaking1And1ReturningPositiveAndGetFragmentInMillisecondsTaking1And11() throws Throwable  {
      // Given
      MockDate arg0 = new MockDate((-119151112946000L));
      
      // When
      long fragmentInMilliseconds = DateUtils.getFragmentInMilliseconds(arg0, 2);
      
      // Then
      assertEquals(1485454000L, fragmentInMilliseconds);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInSecondsTaking1And1ThrowsIllegalArgumentException2() throws Throwable  {
      // MockGregorianCalendar is a mock object for testing purposes only
      MockGregorianCalendar arg0 = new MockGregorianCalendar();
      
      // Test that an IllegalArgumentException is thrown when trying to get the fragment in seconds of a Calendar instance with an unsupported fragment
      try {
      DateUtils.getFragmentInSeconds((Calendar) arg0, 7); // Call the method with an unsupported fragment (7)
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // Verify that the expected exception is thrown
      verifyException("org.apache.commons.lang3.time.DateUtils", e);
      
      // Check that the exception message contains the expected information about the unsupported fragment
      assertTrue(e.getMessage().contains("Unsupported fragment: 7"));}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddHours() throws Throwable  {
      // Arrange
      MockGregorianCalendar mockGregorianCalendar = new MockGregorianCalendar(2, 2, 2, 2, 2);
      Date inputDate = mockGregorianCalendar.getGregorianChange();
      
      // Act
      Date result = DateUtils.addHours(inputDate, 2);
      
      // Assert
      assertEquals("Fri Oct 15 02:00:00 GMT 1582", result.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetHours() throws Throwable  {
      // Given a date with the value "Fri Jan 18 12:34:56 GMT+0"
      MockDate arg0 = new MockDate((-62099308800000L));
      
      // When setting the hours to 11 using DateUtils.setHours()
      Date setHours = DateUtils.setHours(arg0, 11);
      
      // Then the resulting date should have a string representation of "Mon Feb 27 00:00:00 GMT+0"
      assertEquals("Mon Feb 27 00:00:00 GMT+0", setHours.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFragmentInHoursTaking1And1ReturningZeroAndGetFragmentInHoursTaking1And11() throws Throwable  {
      // Given: a date with year 2155 and a unit of hours
      MockDate arg0 = new MockDate(2155);
      long fragmentInHours = DateUtils.getFragmentInHours((Date) arg0, 6);
      
      // When: the method "getFragmentInHours" is called with this date and a unit of hours
      long result = fragmentInHours;
      
      // Then: the method should return the number of hours between the start of the day and the given date, which is equal to 0 in this case
      assertEquals(0L, result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddMilliseconds() throws Throwable  {
      // Test that adding a negative number of milliseconds to a Date object returns a different Date object
      MockDate arg1 = new MockDate();
      Date arg0 = DateUtils.addMilliseconds(arg1, (-22));
      boolean sameInstant = DateUtils.isSameInstant(arg0, (Date) arg1);
      assertFalse(sameInstant);
      
      // Test that the resulting Date object has the correct string representation
      assertEquals("Fri Feb 14 20:21:21 GMT 2014", arg0.toString());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRemove() throws Throwable  {
      // rollbacked to evosuite
      Locale arg0 = Locale.ITALY;
      Calendar arg1 = MockCalendar.getInstance(arg0);
      DateUtils.DateIterator dateUtils_DateIterator = new DateUtils.DateIterator(arg1, arg1);
      // Undeclared exception!
      try { 
        dateUtils_DateIterator.remove();
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.lang3.time.DateUtils$DateIterator", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHasNext() throws Throwable  {
      // Arrange
      TimeZone defaultTimeZone = TimeZone.getDefault();
      Calendar calendar = MockCalendar.getInstance(defaultTimeZone);
      DateUtils.DateIterator dateIterator = new DateUtils.DateIterator(calendar, calendar);
      
      // Act
      boolean hasNext = dateIterator.hasNext();
      
      // Assert
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392322881320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=13,DAY_OF_YEAR=44,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=320,ZONE_OFFSET=0,DST_OFFSET=0]", calendar.toString());
      assertTrue(hasNext); // check that the iterator has a next value
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIteratorTaking1And1AndIteratorTaking1And1AndIteratorTaking1And1ReturningNonNull1() throws Throwable  {
      // rollbacked to evosuite
      MockDate arg0 = new MockDate(1, 1, 1, 1, 1);
      Iterator<?> iterator = DateUtils.iterator((Object) arg0, 1);
      assertNotNull(iterator);
  }
}
