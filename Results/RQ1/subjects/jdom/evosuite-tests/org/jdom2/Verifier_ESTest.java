/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 19 19:20:08 GMT 2024
 */

package org.jdom2;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.jdom2.Attribute;
import org.jdom2.AttributeType;
import org.jdom2.Element;
import org.jdom2.EntityRef;
import org.jdom2.Namespace;
import org.jdom2.Text;
import org.jdom2.Verifier;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class Verifier_ESTest extends Verifier_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckURI0() throws Throwable  {
      // Given a URI with a percent sign that is not followed by two hexadecimal digits
      String uri = ":59_/TPN??JN%C";
      
      // When the checkURI method is called with this URI
      String checkURI = Verifier.checkURI(uri);
      
      // Then the method should return null, indicating that the URI is invalid
      assertNull(checkURI);
      
      // And an error message should be returned explaining that the percent sign must be followed by exactly two hexadecimal digits
      assertEquals("Percent signs in URIs must be followed by exactly two hexadecimal digits.", checkURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLWhitespaceReturningFalse() throws Throwable  {
      // No Comments were added
      boolean xMLWhitespace = Verifier.isXMLWhitespace('C');
      assertFalse(xMLWhitespace);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDecodeSurrogatePairReturningNegative() throws Throwable  {
      // No Comments were added
      int decodeSurrogatePair = Verifier.decodeSurrogatePair('r', 'r');
      assertEquals((-56497038), decodeSurrogatePair);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking1And1AndCheckNamespaceCollisionTaking1And10() throws Throwable  {
      // Given
      Namespace namespace = Namespace.NO_NAMESPACE;
      Element element = new Element("VQFS", namespace);
      
      // When
      String result = Verifier.checkNamespaceCollision(namespace, element);
      
      // Then
      assertNull(result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckElementNameReturningNull() throws Throwable  {
      // Check if the element name is null when passing a valid entity reference
      String checkElementName = Verifier.checkElementName("org.jdom2.EntityRef");
      assertNull(checkElementName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckAttributeNameReturningNull() throws Throwable  {
      // Check that the method returns null for a valid attribute name
      String checkAttributeName = Verifier.checkAttributeName("age");
      assertNull(checkAttributeName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLWhitespace0() throws Throwable  {
      // This test verifies that the 'isXMLWhitespace' method correctly identifies newline characters as whitespace
      boolean xMLWhitespace = Verifier.isXMLWhitespace('\n');
      assertTrue(xMLWhitespace);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLWhitespace1() throws Throwable  {
      // Test that a carriage return character is considered XML whitespace
      boolean actualResult = Verifier.isXMLWhitespace('\r');
      assertTrue(actualResult);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLWhitespace2() throws Throwable  {
      // No Comments were added
      boolean xMLWhitespace = Verifier.isXMLWhitespace('\t');
      assertTrue(xMLWhitespace);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLNameStartCharacterReturningFalse() throws Throwable  {
      // Test that the character '^' is not a valid XML name start character
      boolean xMLNameStartCharacter = Verifier.isXMLNameStartCharacter('^');
      assertFalse(xMLNameStartCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLNameStartCharacterWithOtherChar() throws Throwable  {
      // Check if the character ':' is a valid XML name start character
      boolean xMLNameStartCharacter = Verifier.isXMLNameStartCharacter(':');
      assertTrue(xMLNameStartCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLNameStartCharacter() throws Throwable  {
      // No Comments were added
      boolean xMLNameStartCharacter = Verifier.isXMLNameStartCharacter('L');
      assertTrue(xMLNameStartCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLNameCharacter() throws Throwable  {
      // No Comments were added
      boolean xMLNameCharacter = Verifier.isXMLNameCharacter('M');
      assertTrue(xMLNameCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLNameCharacterReturningFalse() throws Throwable  {
      // Test if '@' is a valid XML name character
      boolean xMLNameCharacter = Verifier.isXMLNameCharacter('@');
      assertFalse(xMLNameCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLNameCharacterWithOtherChar() throws Throwable  {
      // Test that the Verifier.isXMLNameCharacter() method returns true for a colon character (':')
      boolean xMLNameCharacter = Verifier.isXMLNameCharacter(':');
      assertTrue(xMLNameCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsURICharacterReturningTrue() throws Throwable  {
      // No Comments were added
      boolean uRICharacter = Verifier.isURICharacter('$');
      assertTrue(uRICharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsURICharacterReturningFalse() throws Throwable  {
      // Test if a '#' character is a valid URI character
      // The test is checking that the character '#' is not considered a valid URI character
      boolean isValidURICharacter = Verifier.isURICharacter('#');
      assertFalse(isValidURICharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsHexDigitReturningFalse() throws Throwable  {
      // Test that the method returns true for a hexadecimal digit character
      boolean hexDigit = Verifier.isHexDigit('a');
      assertTrue(hexDigit);
      
      // Test that the method returns false for a non-hexadecimal digit character
      hexDigit = Verifier.isHexDigit('g');
      assertFalse(hexDigit);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsHexDigit0() throws Throwable  {
      // Tests that a character is considered a hexadecimal digit if it is an uppercase letter A-F
      boolean hexDigit = Verifier.isHexDigit('A');
      assertTrue(hexDigit);
      
      // Tests that a character is not considered a hexadecimal digit if it is a lowercase letter a-f
      boolean notHexDigit = Verifier.isHexDigit('a');
      assertFalse(notHexDigit);
      
      // Tests that a character is not considered a hexadecimal digit if it is a letter other than A-F or a-f
      boolean notHexDigit2 = Verifier.isHexDigit('Z');
      assertFalse(notHexDigit2);
      
      // Tests that a character is not considered a hexadecimal digit if it is a number
      boolean notHexDigit3 = Verifier.isHexDigit('1');
      assertFalse(notHexDigit3);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsHexDigitWithDigit() throws Throwable  {
      // Test that Verifier.isHexDigit() returns true for a hexadecimal digit character
      boolean hexDigit = Verifier.isHexDigit('1');
      assertTrue(hexDigit); // Assert that the method returns true for a valid hexadecimal digit character
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckXMLNameReturningNull() throws Throwable  {
      // The method checkXMLName is called with the argument "Tmns".
      String checkXMLName = Verifier.checkXMLName("Tmns");
      
      // Asserts that the returned value is null, indicating that the name is invalid.
      assertNull(checkXMLName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckXMLName() throws Throwable  {
      // Arrange
      String xmlName = ":GTjpe&";
      
      // Act
      String checkXMLName = Verifier.checkXMLName(xmlName);
      
      // Assert
      assertEquals("XML names cannot contain the character \"&\"", checkXMLName);
      assertNotNull(checkXMLName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test0() throws Throwable  {
      EntityRef entityRef = null;
      try {
      entityRef = new EntityRef("&W+`X0", " with an attribute namespace prefix on the element", "&W+`X0");
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // This is expected, as &W+`X0 is not a legal XML name.
      verifyException("org.jdom2.EntityRef", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterAndIsXMLPublicIDCharacterWithOtherChar0() throws Throwable  {
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter(' ');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterWithDigit() throws Throwable  {
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('7');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterAndIsXMLPublicIDCharacterWithOtherChar1() throws Throwable  {
      // Test that a character is considered as XML Public ID Character
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('@');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacter() throws Throwable  {
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('p');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking11And1AndCheckNamespaceCollisionTaking11And10() throws Throwable  {
      // Given a namespace and a list of objects with the same namespace
      Namespace arg0 = Namespace.XML_NAMESPACE;
      LinkedList<Object> arg1 = new LinkedList<>();
      arg1.add((Object) arg0);
      
      // When we check for namespace collisions using the Verifier method
      String checkNamespaceCollision = Verifier.checkNamespaceCollision(arg0, (List<?>) arg1, (-570));
      
      // Then we expect the result to be null, as there are no other namespaces with the same value in the list
      assertNull(checkNamespaceCollision);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking11And1ReturningNonEmptyStringAndCheckNamespaceCollisionTaking11And10() throws Throwable  {
      // Given a Namespace object with the prefix "org.jdom2.Verifier"
      Namespace verifierNamespace = Namespace.getNamespace("org.jdom2.Verifier");
      
      // And an Attribute object with the value "'@XJyYZ"
      Attribute attribute = new Attribute("org.jdom2.Verifier", "'@XJyYZ");
      
      // When the method Verifier.checkNamespaceCollision is called with the Namespace object and the List of namespaces in scope
      String collisionMessage = Verifier.checkNamespaceCollision(verifierNamespace, attribute.getNamespacesInScope(), 35);
      
      // Then the message "The namespace prefix "" collides with an additional namespace declared by the element" should be returned
      assertNotNull(collisionMessage);
      assertEquals("The namespace prefix \"\" collides with an additional namespace declared by the element", collisionMessage);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking11And1WithNull() throws Throwable  {
      // Test that checkNamespaceCollision returns null when passed a null input
      Namespace arg0 = Namespace.XML_NAMESPACE;
      String checkNamespaceCollision = Verifier.checkNamespaceCollision(arg0, (List<?>) null, (-115));
      assertNull(checkNamespaceCollision);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking11And1AndCheckNamespaceCollisionTaking11And11() throws Throwable  {
      // Given a new attribute "q"
      Attribute arg0 = new Attribute("q", "q");
      
      // When we check if the namespace collision exists between this attribute and an element with ID 540
      String checkNamespaceCollision = Verifier.checkNamespaceCollision(arg0, (Element) null, 540);
      
      // Then the method should return null as there is no collision
      assertNull(checkNamespaceCollision);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking2NamespacesReturningNonEmptyString() throws Throwable  {
      // Given two namespaces with a conflicting prefix
      Namespace ns1 = Namespace.getNamespace("&9,h?l");
      Namespace ns2 = Namespace.getNamespace("URIs cannot contain 0x5d");
      
      // When we check for namespace collision
      String result = Verifier.checkNamespaceCollision(ns1, ns2);
      
      // Then we expect the method to return a non-null value and the error message
      assertNotNull(result);
      assertEquals("The namespace prefix \"\" collides", result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking2Namespaces0() throws Throwable  {
      // Given: Two objects of the same type with the same namespace value
      Namespace arg1 = Namespace.XML_NAMESPACE;
      Namespace arg2 = Namespace.XML_NAMESPACE;
      
      // When: We call Verifier.checkNamespaceCollision() with these two objects as arguments
      String checkNamespaceCollision = Verifier.checkNamespaceCollision(arg1, arg2);
      
      // Then: The method should return null since there is no collision
      assertNull(checkNamespaceCollision);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckCharacterDataReturningNonEmptyString() throws Throwable  {
      // Given: A string that contains illegal XML characters
      String illegalXmlCharacters = "This string contains illegal XML characters (<&>)";
      
      // When: We pass the string to the Verifier class's checkCharacterData method
      String checkCharacterData = Verifier.checkCharacterData(illegalXmlCharacters);
      
      // Then: The method should return an error message indicating that a null is not a legal XML value
      assertEquals("A null is not a legal XML value", checkCharacterData);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsAllXMLWhitespaceReturningFalse() throws Throwable  {
      // No Comments were added
      boolean allXMLWhitespace = Verifier.isAllXMLWhitespace("abc");
      assertFalse(allXMLWhitespace);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsAllXMLWhitespaceReturningTrue() throws Throwable  {
      // Tests that a string containing only whitespace characters is considered to be XML whitespace
      boolean allXMLWhitespace = Verifier.isAllXMLWhitespace("\t\n\r");
      assertTrue(allXMLWhitespace);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test1() throws Throwable  {
      // No Comments were added
      String normalizeString = Text.normalizeString("URL percent encoding errors must be corrected.");
      assertEquals("URL percent encoding errors must be corrected.", normalizeString);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLDigitReturningTrue() throws Throwable  {
      // Test that Verifier.isXMLDigit() returns true for a valid XML digit character
      boolean xMLDigit = Verifier.isXMLDigit('0');
      assertTrue(xMLDigit);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLDigitReturningFalse() throws Throwable  {
      // Given: We have a method isXMLDigit that takes a character as input and returns true if the character is a digit in the XML schema.
      // When: We pass the character 'a' to the method.
      boolean xMLDigit = Verifier.isXMLDigit('a');
      // Then: The method should return false, since 'a' is not a digit in the XML schema.
      assertFalse(xMLDigit);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLExtender0() throws Throwable  {
      // No Comments were added
      boolean xMLExtender = Verifier.isXMLExtender('<');
      assertFalse(xMLExtender);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLExtender1() throws Throwable  {
      // Test that the character '\uFF3B' is not considered an XML extender
      boolean xMLExtender = Verifier.isXMLExtender('\uFF3B');
      assertFalse(xMLExtender);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLCombiningChar() throws Throwable  {
      // Given: We have a method called isXMLCombiningChar that takes a character as input and returns true if it is an XML combining character.
      // When: We pass the carriage return character ('\r') to the method.
      boolean xMLCombiningChar = Verifier.isXMLCombiningChar('\r');
      
      // Then: The method should return false because the carriage return character is not an XML combining character.
      assertFalse(xMLCombiningChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLLetterReturningTrue() throws Throwable  {
      // Test that the Verifier.isXMLLetter() method returns true for a valid XML letter character
      boolean xMLLetter = Verifier.isXMLLetter('a');
      assertTrue(xMLLetter);
      
      // The 'a' is a valid XML letter because it satisfies the following conditions:
      // 1. It is an ASCII letter (0x41 - 0x5A or 0x61 - 0x7A)
      // 2. It is not a digit (0x30 - 0x39)
      // 3. It is not a dash (-) or underscore (_) character
      assertTrue(Verifier.isXMLLetter('a'), "The 'a' character should be considered an XML letter");
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLLetterReturningFalse() throws Throwable  {
      // No Comments were added
      boolean xMLLetter = Verifier.isXMLLetter('_');
      assertFalse(xMLLetter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLLetterOrDigitReturningTrue() throws Throwable  {
      // Check if the given character is a letter or digit according to XML specification
      boolean xmlLetterOrDigit = Verifier.isXMLLetterOrDigit('q');
      
      // Assert that the given character is indeed a letter or digit
      assertTrue(xmlLetterOrDigit);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLLetterOrDigitReturningFalse() throws Throwable  {
      // rollbacked to evosuite
      boolean xMLLetterOrDigit = Verifier.isXMLLetterOrDigit(' ');
      assertFalse(xMLLetterOrDigit);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckProcessingInstructionTarget0() throws Throwable  {
      // Given
      String processingInstruction = ": ";
      
      // When
      String result = Verifier.checkProcessingInstructionTarget(processingInstruction);
      
      // Then
      assertEquals("XML names cannot contain the character \" \"", result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLCharacterAndIsXMLCharacterReturningFalse0() throws Throwable  {
      // Given: We have a method isXMLCharacter() that takes an integer as input and returns true if it is a valid XML character, and false otherwise.
      // When: The method is called with the argument 29, which is not a valid XML character.
      // Then: The method should return false, indicating that 29 is not a valid XML character.
      boolean xMLCharacter = Verifier.isXMLCharacter(29);
      assertFalse(xMLCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLCharacterAndIsXMLCharacterReturningTrue0() throws Throwable  {
      // No Comments were added
      boolean xMLCharacter = Verifier.isXMLCharacter(65536);
      assertTrue(xMLCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLCharacterAndIsXMLCharacterReturningFalse1() throws Throwable  {
      // No Comments were added
      boolean xMLCharacter = Verifier.isXMLCharacter(10549237);
      assertFalse(xMLCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLCharacterAndIsXMLCharacterReturningTrue1() throws Throwable  {
      // No Comments were added
      boolean xMLCharacter = Verifier.isXMLCharacter('A');
      assertTrue(xMLCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsLowSurrogate() throws Throwable  {
      // Test that a high surrogate character is not considered a low surrogate
      boolean highSurrogate = Verifier.isHighSurrogate('\uD800');
      assertFalse(highSurrogate);
      
      // Test that a low surrogate character is considered a low surrogate
      boolean lowSurrogate = Verifier.isLowSurrogate('\uDC00');
      assertTrue(lowSurrogate);
      
      // Test that a non-surrogate character is not considered a low surrogate
      boolean nonSurrogate = Verifier.isLowSurrogate('a');
      assertFalse(nonSurrogate);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsHighSurrogateReturningTrue() throws Throwable  {
      // Test to verify that the Verifier is able to identify a high surrogate character
      boolean highSurrogate = Verifier.isHighSurrogate('\uD800');
      assertTrue(highSurrogate);
      // The "\uD800" represents a high surrogate character
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsHighSurrogateReturningFalse() throws Throwable  {
      // Given a character that is a high surrogate, we expect the method to return true
      boolean highSurrogate = Verifier.isHighSurrogate('\uDC00');
      assertTrue(highSurrogate);
      
      // When we call the method with a low surrogate, we expect it to return false
      boolean lowSurrogate = Verifier.isHighSurrogate('\uDE8F');
      assertFalse(lowSurrogate);
      
      // Then we check that the method returns true for a character that is neither a high nor a low surrogate
      char nonSurrogate = 'a';
      boolean notASurrogate = Verifier.isHighSurrogate(nonSurrogate);
      assertFalse(notASurrogate);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsHexDigit1() throws Throwable  {
      // Test that a letter character is considered a hexadecimal digit
      boolean hexDigit = Verifier.isHexDigit('a');
      assertTrue(hexDigit);
      
      // Check that other characters are not considered hexadecimal digits
      assertFalse(Verifier.isHexDigit('z'));
      assertFalse(Verifier.isHexDigit('A'));
      assertFalse(Verifier.isHexDigit('Z'));
      assertFalse(Verifier.isHexDigit(' '));
      assertFalse(Verifier.isHexDigit('!'));
      
      // Check that the method works for all hexadecimal digits (0-9, a-f)
      for (char c = '0'; c <= '9'; c++) {
      assertTrue(Verifier.isHexDigit(c));
      }
      for (char c = 'a'; c <= 'f'; c++) {
      assertTrue(Verifier.isHexDigit(c));
      }
      
      // Check that the method returns false for non-hexadecimal digits
      assertFalse(Verifier.isHexDigit('g'));
      assertFalse(Verifier.isHexDigit('G'));
      assertFalse(Verifier.isHexDigit('z'));
      assertFalse(Verifier.isHexDigit('Z'));
      assertFalse(Verifier.isHexDigit(' '));
      assertFalse(Verifier.isHexDigit('!'));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsHexDigitWithOtherChar() throws Throwable  {
      // No Comments were added
      boolean hexDigit = Verifier.isHexDigit('\u000B');
      assertFalse(hexDigit);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckURI1() throws Throwable  {
      // No Comments were added
      String checkURI = Verifier.checkURI("Q%B=#T7AQ.`52:LbJJ");
      assertEquals("Percent signs in URIs must be followed by exactly two hexadecimal digits.", checkURI);
      assertNotNull(checkURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckURI2() throws Throwable  {
      // Arrange
      String uri = "6w%~{*'0Z[";
      
      // Act
      String checkURI = Verifier.checkURI(uri);
      
      // Assert
      assertNotNull(checkURI);
      assertEquals("Percent signs in URIs must be followed by exactly two hexadecimal digits.", checkURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckURI3() throws Throwable  {
      // No Comments were added
      String checkURI = Verifier.checkURI("0x%04x is not a legal XML character");
      assertNotNull(checkURI);
      assertEquals("URIs cannot contain 0x20", checkURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckURIWithEmptyString() throws Throwable  {
      // No Comments were added
      String checkURI = Verifier.checkURI("");
      assertNull(checkURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckURIReturningNull() throws Throwable  {
      // Check if the input URI is valid and return null if it is not
      String checkURI = Verifier.checkURI("https://www.example.com");
      assertNull(checkURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckURIWithNull() throws Throwable  {
      // Check if passing a null value to the Verifier.checkURI() method returns a null value.
      // Arrange
      String checkURI = Verifier.checkURI((String) null);
      
      // Act
      assertNull(checkURI);
      
      // Assert
      // Check that the returned value is null, which means that the method did not perform any validation on the input parameter.
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckXMLNameWithEmptyString() throws Throwable  {
      // Test to ensure that XML names cannot be empty
      String checkXMLName = Verifier.checkXMLName("");
      assertEquals("XML names cannot be empty", checkXMLName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckXMLNameWithNull() throws Throwable  {
      // Check that a null input returns an error message
      String checkXMLName = Verifier.checkXMLName(null);
      assertEquals("XML names cannot be null", checkXMLName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckSystemLiteralReturningNonEmptyString() throws Throwable  {
      // Given a system literal with both single and double quotes
      String systemLiteral = "Qk\"L8;'U^%4~T8;G";
      
      // When the system literal is checked for correctness
      String checkSystemLiteral = Verifier.checkSystemLiteral(systemLiteral);
      
      // Then the result should indicate that the system literal cannot contain both single and double quotes
      assertEquals("System literals cannot simultaneously contain both single and double quotes.", checkSystemLiteral);
      
      // And the result should not be null
      assertNotNull(checkSystemLiteral);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckSystemLiteral0() throws Throwable  {
      String checkSystemLiteral = Verifier.checkSystemLiteral("7eB(YGl[S9-z'PCB|Fc");
      // This test checks that the method returns null when passed a string that contains an invalid system literal
      assertNull(checkSystemLiteral);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckSystemLiteralWithNull() throws Throwable  {
      // No Comments were added
      String checkSystemLiteral = Verifier.checkSystemLiteral((String) null);
      assertNull(checkSystemLiteral);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckSystemLiteral1() throws Throwable  {
      // Given: A String variable "checkSystemLiteral" contains a string value "This is a string".
      String checkSystemLiteral = Verifier.checkSystemLiteral("This is a string");
      
      // When: The method "checkSystemLiteral()" is called on the String object with the parameter "This is a string".
      assertNull(checkSystemLiteral);
      
      // Then: The method should return null, as the input string does not contain any system-specific literals.
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckPublicIDReturningNonEmptyString() throws Throwable  {
      String input = " 'D;Y)iQ:-4[>;4";
      
      // When the method checkPublicID is called with this string as input
      String result = Verifier.checkPublicID(input);
      
      // Then the method should return a message indicating that the character is not legal in public IDs
      assertEquals("[ is not a legal character in public IDs", result);
      
      // And the method should not return null
      assertNotNull(result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckPublicIDWithNull() throws Throwable  {
      // Check that a null input returns a null value
      String checkPublicID = Verifier.checkPublicID((String) null);
      assertNull(checkPublicID);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterAndIsXMLPublicIDCharacterWithOtherChar2() throws Throwable  {
      // This test case is written to ensure that the Verifier.isXMLPublicIDCharacter() method returns true when passed the tab character as an argument.
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('\t');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterAndIsXMLPublicIDCharacterWithOtherChar3() throws Throwable  {
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('\r');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterAndIsXMLPublicIDCharacterWithOtherChar4() throws Throwable  {
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('\n');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterAndIsXMLPublicIDCharacterWithOtherChar5() throws Throwable  {
      // No Comments were added
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('%');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterAndIsXMLPublicIDCharacterWithOtherChar6() throws Throwable  {
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('_');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterAndIsXMLPublicIDCharacterWithOtherChar7() throws Throwable  {
      // No Comments were added
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('$');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterAndIsXMLPublicIDCharacterWithOtherChar8() throws Throwable  {
      // No Comments were added
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('#');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterAndIsXMLPublicIDCharacterWithOtherChar9() throws Throwable  {
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('=');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterAndIsXMLPublicIDCharacterWithOtherChar10() throws Throwable  {
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('!');
      assertTrue(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsXMLPublicIDCharacterReturningFalse() throws Throwable  {
      boolean xMLPublicIDCharacter = Verifier.isXMLPublicIDCharacter('\uFFF4');
      assertFalse(xMLPublicIDCharacter);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckPublicID() throws Throwable  {
      String checkPublicID = Verifier.checkPublicID("0x0023 is not a legal XML character");
      assertNull(checkPublicID);
      
      // The test asserts that the method returns null, which means that the given input (a string containing an invalid character) does not satisfy the method's requirements.
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckCommentData0() throws Throwable  {
      // Given a string that ends with a hyphen, verify that it returns a non-null value.
      String input = "-";
      String checkCommentData = Verifier.checkCommentData(input);
      
      // Then the function should return an error message indicating that the comment data cannot end with a hyphen.
      assertNotNull(checkCommentData);
      assertEquals("Comment data cannot end with a hyphen.", checkCommentData);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckCommentData1() throws Throwable  {
      // Given a string containing a comment with double hyphens
      String input = "<!-- Hello, World! -->";
      
      // When the checkCommentData method is called with this string as an argument
      String checkCommentData = Verifier.checkCommentData(input);
      
      // Then the method should return a message indicating that comments cannot contain double hyphens (--)
      assertEquals("Comments cannot contain double hyphens (--)", checkCommentData);
      
      // And the method should not return null
      assertNotNull(checkCommentData);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckCommentDataWithNull() throws Throwable  {
      // No Comments were added
      String checkCommentData = Verifier.checkCommentData((String) null);
      assertNotNull(checkCommentData);
      assertEquals("A null is not a legal XML value", checkCommentData);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckCommentDataReturningNull() throws Throwable  {
      // No Comments were added
      String checkCommentData = Verifier.checkCommentData("Hello World!");
      assertNull(checkCommentData);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckProcessingInstructionDataReturningNull() throws Throwable  {
      // Check that the processing instruction data is valid
      String checkProcessingInstructionData = Verifier.checkProcessingInstructionData("<!DOCTYPE html><html lang=\"en\"><head><title>Title</title></head><body><p>Hello, world!</p></body></html>");
      // Assert that the processing instruction data is null, indicating it is valid
      assertNull(checkProcessingInstructionData);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckProcessingInstructionData() throws Throwable  {
      // Given a processing instruction string that contains a "?>" sequence
      String piString = "<?pi target=\"http://example.com\"?>";
      
      // When the string is passed to the checkProcessingInstructionData method
      String checkProcessingInstructionData = Verifier.checkProcessingInstructionData(piString);
      
      // Then the method should return a non-null value indicating that the processing instruction is invalid
      assertNotNull(checkProcessingInstructionData);
      
      // And the returned message should indicate that the processing instruction cannot contain the string "?>"
      assertEquals("Processing instructions cannot contain the string \"?>\"", checkProcessingInstructionData);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckProcessingInstructionDataWithNull() throws Throwable  {
      // No Comments were added
      String checkProcessingInstructionData = Verifier.checkProcessingInstructionData((String) null);
      assertEquals("A null is not a legal XML value", checkProcessingInstructionData);
      assertNotNull(checkProcessingInstructionData);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckProcessingInstructionTargetReturningNull() throws Throwable  {
      // Test that a processing instruction with a valid target name is returned as null.
      String checkProcessingInstructionTarget = Verifier.checkProcessingInstructionTarget("XML-stylesheet");
      assertNull(checkProcessingInstructionTarget);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckProcessingInstructionTarget1() throws Throwable  {
      // Check that the target of a processing instruction cannot contain colons
      String checkProcessingInstructionTarget = Verifier.checkProcessingInstructionTarget("Ptfw:cF");
      assertNotNull(checkProcessingInstructionTarget);
      assertEquals("Invalid processing instruction target", checkProcessingInstructionTarget);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckProcessingInstructionTarget2() throws Throwable  {
      // Check that processing instructions cannot have a target of "xml" in any combination of case.
      String checkProcessingInstructionTarget = Verifier.checkProcessingInstructionTarget("xml");
      assertNotNull(checkProcessingInstructionTarget);
      
      // Assert that the target is not equal to "xml" or "XML", as these are reserved targets and should not be used.
      assertEquals("Processing instructions cannot have a target of \"xml\" in any combination of case.", checkProcessingInstructionTarget, "<?xml ... ?>");
      
      // Assert that the target is not equal to "xml" or "XML", as these are reserved targets and should not be used.
      assertNotEquals("Processing instructions cannot have a target of \"xml\" in any combination of case.", checkProcessingInstructionTarget, "<?XML ... ?>");
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking1And10() throws Throwable  {
      // Given
      Namespace xmlNamespace = Namespace.XML_NAMESPACE;
      Attribute tmnsAttribute = new Attribute("Tmns", "Tmns", xmlNamespace);
      
      // When
      String checkNamespaceCollision = Verifier.checkNamespaceCollision(xmlNamespace, tmnsAttribute);
      
      // Then
      assertNull(checkNamespaceCollision);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking1And11() throws Throwable  {
      // Test that verifying namespace collision returns null when there is no collision
      Namespace arg0 = Namespace.NO_NAMESPACE; // The first namespace to check for collisions
      Attribute arg1 = new Attribute("VQFe", "VQFe", arg0); // A second attribute with the same name but different namespace
      String checkNamespaceCollision = Verifier.checkNamespaceCollision(arg0, arg1);
      assertNull(checkNamespaceCollision); // Assert that the collision is null, which means there is no collision
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking11And1WithZero() throws Throwable  {
      // Given
      Element element = new Element("Qer", "Qer", "Qer");
      
      // When
      Element attr1 = element.setAttribute("Qer", "Qer");
      Namespace ns0 = Namespace.NO_NAMESPACE;
      String collision = Verifier.checkNamespaceCollision(ns0, attr1, 0);
      
      // Then
      assertNull(collision);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking11And1ReturningNonEmptyStringAndCheckNamespaceCollisionTaking11And11() throws Throwable  {
      // Given
      Element element = new Element("K");
      Namespace namespace = Namespace.getNamespace("K");
      
      // When
      String actualResult = Verifier.checkNamespaceCollision(namespace, element, 2100);
      
      // Then
      assertNotNull(actualResult);
      assertEquals("The namespace prefix \"\" collides with the element namespace prefix", actualResult);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking11And1ThrowsNullPointerException() throws Throwable  {
      // Test that a null element throws a NullPointerException when checking for namespace collisions
      Attribute arg0 = new Attribute("xOQP73y", "xOQP73y");
      Namespace namespace = Namespace.XML_NAMESPACE;
      arg0.namespace = namespace;
      
      try {
      Verifier.checkNamespaceCollision(arg0, null, 468);
      fail("Expected exception not thrown");
      } catch (NullPointerException e) {
      // No message in exception (getMessage() returned null)
      verifyException("org.jdom2.Verifier", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking1And1ReturningNonEmptyString() throws Throwable  {
      // Given a namespace with a specific prefix and URL
      Namespace ns1 = Namespace.getNamespace("org.jdom2.Verifier", "https://www.example.com/");
      
      // And a namespace with the same prefix but a different URL
      Namespace ns2 = Namespace.getNamespace("org.jdom2.Verifier", "https://www.example.com/test");
      
      // When we check for namespace collision between these two namespaces
      String result = Verifier.checkNamespaceCollision(ns1, ns2);
      
      // Then the method should return a non-null value indicating that there is a collision
      assertNotNull(result);
      
      // And the returned value should be a descriptive message indicating that the namespace prefix collides with an attribute namespace prefix on the element
      assertEquals("The namespace prefix \"org.jdom2.Verifier\" collides with an attribute namespace prefix on the element", result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking2Namespaces1() throws Throwable  {
      // Given
      Namespace noNamespace = Namespace.NO_NAMESPACE;
      Namespace xmlNamespace = Namespace.XML_NAMESPACE;
      
      // When
      String result = Verifier.checkNamespaceCollision(noNamespace, xmlNamespace);
      
      // Then
      assertNull(result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceURI0() throws Throwable  {
      // No Comments were added
      String checkNamespaceURI = Verifier.checkNamespaceURI("\n");
      assertNotNull(checkNamespaceURI);
      assertEquals("Namespace URIs cannot begin with white-space", checkNamespaceURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceURI1() throws Throwable  {
      // Test that the method returns a null value when given a valid namespace URI
      String checkNamespaceURI = Verifier.checkNamespaceURI("http://www.example.com/");
      assertNull(checkNamespaceURI);
      
      // Test that the method throws an IllegalArgumentException when given a namespace URI with a hyphen at the beginning
      try {
      Verifier.checkNamespaceURI("-9.ccN.1_f;+kZQ17,(");
      fail("Expected IllegalArgumentException to be thrown");
      } catch (IllegalArgumentException e) {
      assertEquals("Namespace URIs cannot begin with a hyphen (-)", e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceURI2() throws Throwable  {
      // Given a string that contains a dollar sign ($) at the beginning
      String inputString = "$qtkc_EL=%xG/(5[3l0";
      
      // When the checkNamespaceURI method is called with this string
      String result = Verifier.checkNamespaceURI(inputString);
      
      // Then assert that the returned value is null, as it should not be a valid namespace URI
      assertNull(result);
      
      // And assert that an error message is returned, indicating that namespace URIs cannot begin with a dollar sign ($)
      assertEquals("Namespace URIs cannot begin with a dollar sign ($)", result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceURI3() throws Throwable  {
      // Test that a namespace URI cannot begin with a number
      String checkNamespaceURI = Verifier.checkNamespaceURI("6w%~{*'0Z[");
      assertNotNull(checkNamespaceURI);
      // Assert that the namespace URI is not null and that it contains an error message
      assertEquals("Namespace URIs cannot begin with a number", checkNamespaceURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceURIWithEmptyString() throws Throwable  {
      // No Comments were added
      String checkNamespaceURI = Verifier.checkNamespaceURI("");
      assertNull(checkNamespaceURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceURIReturningNull() throws Throwable  {
      // Check that the method returns null when passed a valid namespace URI
      String checkNamespaceURI = Verifier.checkNamespaceURI("http://www.example.com");
      assertNull(checkNamespaceURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceURIWithNull() throws Throwable  {
      // Given a null value for the namespace URI
      String checkNamespaceURI = Verifier.checkNamespaceURI((String) null);
      
      // When the method is called with the null input
      assertNull(checkNamespaceURI);
      
      // Then, the method should return null as output
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespacePrefixReturningNonEmptyString() throws Throwable  {
      // Given the input value "xmlns"
      String inputValue = "xmlns";
      
      // When the method Verifier.checkNamespacePrefix() is called with the input value
      String checkNamespacePrefix = Verifier.checkNamespacePrefix(inputValue);
      
      // Then the output should be the result of the method call, which in this case is a non-null string
      assertNotNull(checkNamespacePrefix);
      
      // And the output string should contain the error message "Namespace prefixes cannot begin with \"xml\" in any combination of case"
      assertEquals("Namespace prefixes cannot begin with \"xml\" in any combination of case", checkNamespacePrefix);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespacePrefix0() throws Throwable  {
      // Check that the namespace prefix is valid
      String checkNamespacePrefix = Verifier.checkNamespacePrefix("tmns");
      
      // Assert that the prefix is null, indicating that it is not a valid namespace
      assertNull(checkNamespacePrefix);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespacePrefix1() throws Throwable  {
      // Test that the checkNamespacePrefix method returns null when given an invalid namespace prefix
      String checkNamespacePrefix = Verifier.checkNamespacePrefix("xM53N0D-");
      assertNull(checkNamespacePrefix);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespacePrefix2() throws Throwable  {
      // GIVEN a namespace with the prefix "Xqc_"
      String namespace = "http://example.com/Xqc_";
      // WHEN the method checkNamespacePrefix is called with the prefix
      String checkNamespacePrefix = Verifier.checkNamespacePrefix("Xqc_");
      // THEN it should return null as the prefix is not in the namespace
      assertNull(checkNamespacePrefix);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespacePrefixWithNull() throws Throwable  {
      // Test the case where the namespace prefix is null
      String checkNamespacePrefix = Verifier.checkNamespacePrefix((String) null);
      assertNull(checkNamespacePrefix);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckCDATASectionWithNonEmptyString() throws Throwable  {
      // No Comments were added
      String checkCDATASection = Verifier.checkCDATASection("<![CDATA[]]>");
      assertNotNull(checkCDATASection);
      assertEquals("CDATA cannot internally contain a CDATA ending delimiter (]]>)", checkCDATASection);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckCDATASectionReturningNull() throws Throwable  {
      // Check if the method returns null when given an empty string as input
      String checkCDATASection = Verifier.checkCDATASection("");
      assertNull(checkCDATASection);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckCharacterDataReturningNull() throws Throwable  {
      // This test is checking that the "Verifier.checkCharacterData()" method returns null when passed an empty string.
      String checkCharacterData = Verifier.checkCharacterData("");
      assertNull(checkCharacterData);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckCDATASectionWithNull() throws Throwable  {
      // Given: A string variable 'checkCDATASection' with a null value
      String checkCDATASection = Verifier.checkCDATASection((String) null);
      
      // When: The 'checkCDATASection' variable is passed to the 'Verifier.checkCDATASection()' method
      assertNotNull(checkCDATASection);
      
      // Then: The method should return a string indicating that a null value is not a legal XML value
      assertEquals("A null is not a legal XML value", checkCDATASection);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckAttributeNameReturningNonEmptyString() throws Throwable  {
      // No Comments were added
      String checkAttributeName = Verifier.checkAttributeName("xmlns");
      assertEquals("An Attribute name may not be \"xmlns\"; use the Namespace class to manage namespaces", checkAttributeName);
      assertNotNull(checkAttributeName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test2() throws Throwable  {
      // rollbacked to evosuite
      // Undeclared exception!
      try { 
        Namespace.getNamespace("XML name 'Cannot add null content' cannot contain the character \u201C\"\u201D", "XML name 'Cannot add null content' cannot contain the character \u201C\"\u201D");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The name \"XML name 'Cannot add null content' cannot contain the character \u201C\"\u201D\" is not legal for JDOM/XML Namespace prefixs: XML name 'XML name 'Cannot add null content' cannot contain the character \u201C\"\u201D' cannot contain the character \"\u201D\".
         //
         verifyException("org.jdom2.Namespace", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void test3() throws Throwable  {
      Element element = null;
      try {
      element = new Element("1234-1987");
      fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
      // This block is executed if the constructor throws an IllegalArgumentException.
      verifyException("org.jdom2.Element", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckElementNameWithNull() throws Throwable  {
      // Arrange
      String elementName = null;
      
      // Act
      String checkElementName = Verifier.checkElementName(elementName);
      
      // Assert
      assertEquals("XML names cannot be null", checkElementName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDecodeSurrogatePairReturningPositive() throws Throwable  {
      // No Comments were added
      int decodeSurrogatePair = Verifier.decodeSurrogatePair('\uFFF5', '\uFFF5');
      assertEquals(10549237, decodeSurrogatePair);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking1And1AndCheckNamespaceCollisionTaking1And11() throws Throwable  {
      // Given a new attribute "Hq" with type ENTITIES
      AttributeType arg2 = AttributeType.ENTITIES;
      Attribute arg0 = new Attribute("Hq", "Hq", arg2);
      
      // When the method checkNamespaceCollision is called on the attribute and an element as null argument
      String checkNamespaceCollision = Verifier.checkNamespaceCollision(arg0, (Element) null);
      
      // Then assert that the method returns null, indicating no collision was found
      assertNull(checkNamespaceCollision);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking11And1WithPositive() throws Throwable  {
      // Arrange
      Namespace namespaceNoName = Namespace.NO_NAMESPACE;
      Element elementJ = new Element("J", namespaceNoName);
      elementJ.addNamespaceDeclaration(namespaceNoName);
      
      // Act
      String checkNamespaceCollision = Verifier.checkNamespaceCollision(namespaceNoName, elementJ, 34);
      
      // Assert
      assertNull(checkNamespaceCollision);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckElementNameWithEmptyString() throws Throwable  {
      // Test that an error is returned when the element name is empty
      String checkElementName = Verifier.checkElementName("");
      assertEquals("XML names cannot be empty", checkElementName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckNamespaceCollisionTaking1And1AndCheckNamespaceCollisionTaking1And12() throws Throwable  {
      // rollbacked to evosuite
      Namespace arg0 = Namespace.XML_NAMESPACE;
      String checkNamespaceCollision = Verifier.checkNamespaceCollision(arg0, (List<?>) null);
      assertNull(checkNamespaceCollision);
  }
}
