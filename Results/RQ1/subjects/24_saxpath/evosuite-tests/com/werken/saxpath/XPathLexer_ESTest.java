/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 20 23:35:39 GMT 2024
 */

package com.werken.saxpath;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import com.werken.saxpath.Token;
import com.werken.saxpath.XPathLexer;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class XPathLexer_ESTest extends XPathLexer_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRelationalOperatorReturningTokenWhereGetTokenTypeIsPositive() throws Throwable  {
      // Create a new instance of the XPathLexer with a valid input string
      XPathLexer xPathLexer = new XPathLexer(">G2cN'`QiDkp$:&1]+E");
      
      // Call the relationalOperator() method and assert that it returns an instance of Token
      Token relationalOperator = xPathLexer.relationalOperator();
      assertNotNull(relationalOperator);
      
      // Assert that the returned token has the expected type (9) and text (">")
      assertEquals(9, relationalOperator.getTokenType());
      assertEquals(">", relationalOperator.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLiteral() throws Throwable  {
      // Given a XPathLexer instance with an invalid input string
      XPathLexer lexer = new XPathLexer(">G2cN'`QiD/p$:&1]+E");
      
      // When the literal method is called on the lexer
      Token token = lexer.literal();
      
      // Then the method should return null
      assertNull(token);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsIdentifierStartCharReturningTrue() throws Throwable  {
      // Create an instance of XPathLexer with a given input string
      XPathLexer xPathLexer = new XPathLexer("~}zgR^V@3,");
      
      // Check if the given character is a valid identifier start char
      boolean identifierStartChar = xPathLexer.isIdentifierStartChar('G');
      
      // Assert that the result is true (i.e., the character is a valid identifier start char)
      assertTrue(identifierStartChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsIdentifierStartCharReturningFalse() throws Throwable  {
      // No Comments were added
      XPathLexer xPathLexer = new XPathLexer("eB|~,\"s|^*eL4>E");
      boolean identifierStartChar = xPathLexer.isIdentifierStartChar('0');
      assertFalse(identifierStartChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsIdentifierCharReturningTrue() throws Throwable  {
      // Given a valid input string "[ (", and an instance of the XPathLexer class
      XPathLexer lexer = new XPathLexer("[ (");
      
      // When we call the isIdentifierChar method with 'z' as input, expecting to get true as output
      boolean identifierChar = lexer.isIdentifierChar('z');
      
      // Then assert that the output is indeed true
      assertTrue(identifierChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsIdentifierCharReturningFalse() throws Throwable  {
      // Given a XPath lexer and a slash character '/'
      XPathLexer xPathLexer = new XPathLexer();
      char slash = '/';
      
      // When the method is called with the slash character as an argument
      boolean identifierChar = xPathLexer.isIdentifierChar(slash);
      
      // Then the method should return false, as '/' is not a valid identifier character in XPath
      assertFalse(identifierChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHasMoreCharsReturningTrue() throws Throwable  {
      // Create an instance of the XPathLexer class with a given input string.
      XPathLexer xPathLexer = new XPathLexer("4l/]");
      
      // Check if there are more characters to be processed in the input string.
      boolean moreChars = xPathLexer.hasMoreChars();
      
      // Assert that the lexer has more characters to process.
      assertTrue(moreChars);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHasMoreCharsReturningFalse() throws Throwable  {
      // Given: There is an instance of the XPathLexer class called xPathLexer
      XPathLexer xPathLexer = new XPathLexer();
      
      // When: The hasMoreChars method is called on xPathLexer
      boolean moreChars = xPathLexer.hasMoreChars();
      
      // Then: The returned value should be false, as there are no more characters left to lex
      assertFalse(moreChars);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetXPathReturningNull() throws Throwable  {
      // Arrange
      XPathLexer lexer = new XPathLexer();
      
      // Act
      String xPath = lexer.getXPath();
      
      // Assert
      assertNull(xPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetXPathReturningNonEmptyString() throws Throwable  {
      // Given a XPath lexer object
      XPathLexer lexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // When the getXPath method is called on the lexer object
      String xPath = lexer.getXPath();
      
      // Then the expected XPath expression should be returned
      assertEquals("com.werken.saxpath.XPathLexer", xPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPreviousTokenReturningNull() throws Throwable  {
      // Given a XPathLexer instance with no previous tokens
      XPathLexer xPathLexer = new XPathLexer("cZM$ib.8p&M[u}Ele/");
      
      // When the getPreviousToken method is called
      Token previousToken = xPathLexer.getPreviousToken();
      
      // Then the returned token should be null
      assertNull(previousToken);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPreviousTokenReturningTokenWhereGetTokenTypeIsPositive() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("u?PXg5rvj~dg\u0004,");
      Token arg0 = xPathLexer.rightParen();
      xPathLexer.setPreviousToken(arg0);
      Token previousToken = xPathLexer.getPreviousToken();
      assertEquals("u", previousToken.getTokenText());
      assertEquals(2, previousToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEndPositionReturningZero() throws Throwable  {
      // Create a new XPathLexer instance
      XPathLexer xPathLexer = new XPathLexer();
      
      // Get the end position of the last token in the lexer's input
      int endPosition = xPathLexer.endPosition();
      
      // Assert that the end position is equal to 0, which means there are no tokens left in the input
      assertEquals(0, endPosition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEndPositionReturningPositive() throws Throwable  {
      // Given a string ".6y" and an XPath lexer
      XPathLexer xPathLexer = new XPathLexer(".6y");
      
      // When the end position of the lexer is requested
      int endPosition = xPathLexer.endPosition();
      
      // Then the end position should be 3, as the string ".6y" has a length of 3 characters
      assertEquals(3, endPosition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCurrentPositionReturningZero() throws Throwable  {
      // Create an instance of the XPathLexer class
      XPathLexer xPathLexer = new XPathLexer();
      
      // Call the currentPosition method and assign its return value to a variable
      int currentPosition = xPathLexer.currentPosition();
      
      // Assert that the returned position is 0
      assertEquals(0, currentPosition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCurrentPositionReturningPositive() throws Throwable  {
      // Given a XPath lexer instance
      XPathLexer xPathLexer = new XPathLexer();
      
      // When the "|" token is requested
      Token pipe = xPathLexer.pipe();
      
      // Then the token type should be "|" (17)
      assertEquals(17, pipe.getTokenType());
      
      // And the current position of the lexer should be 1
      int currentPosition = xPathLexer.currentPosition();
      assertEquals(1, currentPosition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCurrentPositionReturningNegative() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer();
      xPathLexer.consume((-119));
      int currentPosition = xPathLexer.currentPosition();
      assertEquals((-119), currentPosition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLAReturningOtherChar() throws Throwable  {
      // Given a XPathLexer instance with a valid input string
      String input = "u?PXg5rvj~dg\u0004,";
      XPathLexer xPathLexer = new XPathLexer(input);
      
      // When the LA method is called with an argument of 112
      char LA = xPathLexer.LA(112);
      
      // Then the returned character should be '\uFFFF'
      assertEquals('\uFFFF', LA);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLAReturningAlphabeticChar() throws Throwable  {
      // Set up the XPathLexer with a valid input string
      XPathLexer lexer = new XPathLexer("^)!ylTe");
      
      // Consume the first character of the input string
      lexer.consume();
      
      // Test that the next token is correctly parsed and has the expected type and text
      Token nextToken = lexer.nextToken();
      assertEquals(")", nextToken.getTokenText());
      assertEquals(2, nextToken.getTokenType());
      
      // Test that the minus method returns a Token with the correct text and type
      Token minus = lexer.minus();
      assertEquals("!", minus.getTokenText());
      assertEquals(6, minus.getTokenType());
      
      // Test that the LA (lookahead) method returns the expected character
      char laChar = lexer.LA(1);
      assertEquals('y', laChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetXPathReturningEmptyString() throws Throwable  {
      // No Comments were added
      XPathLexer xPathLexer = new XPathLexer("");
      String xPath = xPathLexer.getXPath();
      assertEquals("", xPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRelationalOperatorReturningNull() throws Throwable  {
      // Given a XPathLexer with invalid input
      XPathLexer lexer = new XPathLexer("cZM$ib.8p&M[u}Ele/");
      
      // When we call the relationalOperator method
      Token token = lexer.relationalOperator();
      
      // Then the result should be null
      assertNull(token);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndCallsWhitespace() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("[ (");
      // Given a string representing a valid XPath expression
      Token whitespace = xPathLexer.whitespace();
      // When the lexer encounters a whitespace character
      assertEquals("", whitespace.getTokenText());
      // Then the whitespace token should be returned with an empty string as its text and a token type of -2 (unknown)
      assertEquals((-2), whitespace.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndCallsNumber() throws Throwable  {
      // Given the XPath expression "..L*S"
      XPathLexer xPathLexer = new XPathLexer("..L*S");
      
      // When the lexer is applied to the expression
      Token number = xPathLexer.number();
      
      // Then the lexer should return a token with the text ".", and the type "NUMBER" (31)
      assertEquals(".", number.getTokenText());
      assertEquals(31, number.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOr() throws Throwable  {
      // Given an XPath lexer with the input "[/X:"
      XPathLexer xPathLexer = new XPathLexer("[/X:");
      
      // When calling the "or" method
      Token or = xPathLexer.or();
      
      // Then the result should be null (no token was found)
      assertNull(or);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAnd() throws Throwable  {
      // Create a new XPathLexer with an invalid input string
      XPathLexer xPathLexer = new XPathLexer("cZM$ib.8p&M[u}Ele/");
      
      // Call the and() method on the lexer
      Token and = xPathLexer.and();
      
      // Assert that the token is null
      assertNull(and);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDiv() throws Throwable  {
      // Arrange
      XPathLexer lexer = new XPathLexer("cZM$ib.8p&M[u}Ele/");
      
      // Act
      Token divToken = lexer.div();
      
      // Assert
      assertNull(divToken);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMod() throws Throwable  {
      // Given an instance of the XPathLexer with a valid input string
      XPathLexer xPathLexer = new XPathLexer("u?PXg5rvj~dg\u0004,");
      
      // When we call the mod method on the lexer
      Token mod = xPathLexer.mod();
      
      // Then the result should be null because the input string is not a valid XPath expression
      assertNull(mod);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndCallsOperatorName() throws Throwable  {
      // No Comments were added
      XPathLexer xPathLexer = new XPathLexer("oL\"XZqx`Ho}");
      Token operatorName = xPathLexer.operatorName();
      assertNull(operatorName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOperatorName() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      xPathLexer.star();
      xPathLexer.equals();
      Token operatorName = xPathLexer.operatorName();
      assertNull(operatorName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenAndStarAndNumberAndSetPreviousToken() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // Lexer should return a dollar token with the text "o" when star is called
      Token dollar = xPathLexer.dollar();
      assertEquals(26, dollar.getTokenType());
      assertEquals("o", dollar.getTokenText());
      
      // Lexer should return a pipe token with the text "w" when doubleColon is called
      Token pipe = xPathLexer.pipe();
      assertEquals(17, pipe.getTokenType());
      assertEquals("w", pipe.getTokenText());
      
      // Lexer should return a number token with the text "20" when number is called
      Token arg0 = xPathLexer.number();
      assertEquals(30, arg0.getTokenType());
      assertEquals("20", arg0.getTokenText());
      
      // Lexer should return a doubleColon token with the text "en" when doubleColon is called
      Token doubleColon = xPathLexer.doubleColon();
      assertEquals(19, doubleColon.getTokenType());
      assertEquals("en", doubleColon.getTokenText());
      
      // Lexer should return a plus token with the text "." when plus is called
      Token plus = xPathLexer.plus();
      assertEquals(5, plus.getTokenType());
      assertEquals(".", plus.getTokenText());
      
      // Lexer should return a star token with the text "s" when star is called
      Token star = xPathLexer.star();
      assertEquals(20, star.getTokenType());
      assertEquals("s", star.getTokenText());
      
      // Lexer should return an end-of-input token when nextToken is called
      Token nextToken = xPathLexer.nextToken();
      assertEquals((-1), nextToken.getTokenType());
      assertEquals("axpath.XPathLexer", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenAndNumberAndSetPreviousToken() throws Throwable  {
      // Given a XPathLexer instance
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // When we call number() method on the lexer
      Token arg0 = xPathLexer.number();
      
      // Then we expect the token type to be 30 (integer)
      assertEquals(30, arg0.getTokenType());
      
      // And we expect the previous token to be the number token
      assertSame(arg0, xPathLexer.getPreviousToken());
      
      // When we call nextToken() method on the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then we expect the token type to be -1 (end of input)
      assertEquals(-1, nextToken.getTokenType());
      
      // And we expect the token text to be "com.werken.saxpath.XPathLexer"
      assertEquals("com.werken.saxpath.XPathLexer", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorName() throws Throwable  {
      // Arrange
      XPathLexer xPathLexer = new XPathLexer("!H>@9_z~|L");
      Token previousToken = new Token(29, "", 29, 29);
      xPathLexer.setPreviousToken(previousToken);
      
      // Act
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      
      // Assert
      assertEquals("", identifierOrOperatorName.getTokenText());
      assertEquals(15, identifierOrOperatorName.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenAndDollarAndSetPreviousToken() throws Throwable  {
      // Given: We have a XPathLexer object named "xPathLexer" with the input string "|RN:o?t".
      XPathLexer xPathLexer = new XPathLexer("|RN:o?t");
      
      // When: We call the "dollar()" method on the "xPathLexer" object to get the first token.
      Token arg0 = xPathLexer.dollar();
      
      // Then: The first token should be a vertical bar (|) with a token type of 26 and a token text of "|".
      assertEquals(26, arg0.getTokenType());
      assertEquals("|", arg0.getTokenText());
      
      // Given: We have the next token returned by the "nextToken()" method on the "xPathLexer" object.
      Token nextToken = xPathLexer.nextToken();
      
      // Then: The next token should be a RN with a token type of 15 and a token text of "RN".
      assertEquals(15, nextToken.getTokenType());
      assertEquals("RN", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenAndNotEqualsAndSetPreviousToken() throws Throwable  {
      // Given an XPathLexer object with a valid input string "|RN:&o?t"
      XPathLexer xPathLexer = new XPathLexer("|RN:&o?t");
      
      // When the notEquals() method is called on the lexer
      Token arg0 = xPathLexer.notEquals();
      
      // Then the first token should be "|R" with type 22
      assertEquals("|R", arg0.getTokenText());
      assertEquals(22, arg0.getTokenType());
      
      // When the nextToken() method is called on the lexer after calling notEquals()
      Token nextToken = xPathLexer.nextToken();
      
      // Then the second token should be "N" with type 15
      assertEquals("N", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenAndEqualsAndSetPreviousToken() throws Throwable  {
      // Given an XPath lexer with a valid input string
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // When the lexer is invoked on the input string
      Token arg0 = xPathLexer.equals();
      xPathLexer.setPreviousToken(arg0);
      
      // Then the lexer should return a token with the correct token type and text
      assertEquals(21, arg0.getTokenType());
      assertEquals("c", arg0.getTokenText());
      
      // And the next token in the stream should be valid as well
      Token nextToken = xPathLexer.nextToken();
      assertEquals("com.werken.saxpath.XPathLexer", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndDoubleColon() throws Throwable  {
      // Given a XPathLexer instance with the class name "com.werken.saxpath.XPathLexer"
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // When we call the doubleColon method on the lexer
      Token arg0 = xPathLexer.doubleColon();
      
      // Then the token text should be "co" and the token type should be 19
      assertEquals("co", arg0.getTokenText());
      assertEquals(19, arg0.getTokenType());
      
      // When we call the identifierOrOperatorName method on the lexer
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      
      // Then the token text should be "m.werken.saxpath.XPathLexer" and the token type should be 15
      assertEquals("m.werken.saxpath.XPathLexer", identifierOrOperatorName.getTokenText());
      assertEquals(15, identifierOrOperatorName.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRightParen() throws Throwable  {
      XPathLexer lexer = new XPathLexer("u?PXg5rvj~dg\u0004,");
      Token rightParen = lexer.rightParen();
      assertEquals("u", rightParen.getTokenText()); // Asserts that the token text is "u"
      assertEquals(2, rightParen.getTokenType()); // Asserts that the token type is 2
      
      lexer.slashes();
      Token leftBracket = lexer.leftBracket();
      assertEquals(3, leftBracket.getTokenType()); // Asserts that the token type is 3
      assertEquals("P", leftBracket.getTokenText()); // Asserts that the token text is "P"
      
      Token arg0 = lexer.at();
      Token slashes = lexer.slashes();
      assertEquals(11, slashes.getTokenType()); // Asserts that the token type is 11
      assertEquals("g", slashes.getTokenText()); // Asserts that the token text is "g"
      
      lexer.setPreviousToken(arg0);
      assertEquals("X", arg0.getTokenText()); // Asserts that the token text is "X"
      
      Token colon = lexer.colon();
      assertEquals("5", colon.getTokenText()); // Asserts that the token text is "5"
      assertEquals(18, colon.getTokenType()); // Asserts that the token type is 18
      
      Token nextToken = lexer.nextToken();
      assertEquals("rvj", nextToken.getTokenText()); // Asserts that the token text is "rvj"
      assertEquals(15, nextToken.getTokenType()); // Asserts that the token type is 15
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndSlashes0() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("[/X:");
      Token arg0 = xPathLexer.slashes();
      xPathLexer.setPreviousToken(arg0);
      assertEquals("[/", arg0.getTokenText());
      assertEquals(12, arg0.getTokenType());
      
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      assertEquals(15, identifierOrOperatorName.getTokenType());
      assertEquals("X", identifierOrOperatorName.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndSlashes1() throws Throwable  {
      // Given a XPathLexer with a path containing slashes
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // When we invoke the slashes method on the lexer
      Token arg0 = xPathLexer.slashes();
      
      // Then we expect to get a token with type equal to 11 and text equal to "c"
      assertEquals(11, arg0.getTokenType());
      assertEquals("c", arg0.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMinus() throws Throwable  {
      // Create an instance of the lexer with a sample input string
      XPathLexer xPathLexer = new XPathLexer("u?PXg5rvj~dg\u0004,");
      
      // Call the minus method on the lexer and store the returned token in arg0
      Token arg0 = xPathLexer.minus();
      
      // Assert that the token type is correct
      assertEquals(6, arg0.getTokenType());
      
      // Assert that the token text is correct
      assertEquals("u", arg0.getTokenText());
      
      // Set the previous token on the lexer to the returned token
      xPathLexer.setPreviousToken(arg0);
      
      // Call the identifierOrOperatorName method on the lexer and store the returned token in identifierOrOperatorName
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      
      // Assert that the token type is correct
      assertEquals(15, identifierOrOperatorName.getTokenType());
      
      // Assert that the token text is correct
      assertEquals("", identifierOrOperatorName.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive0() throws Throwable  {
      // Test that the XPathLexer correctly tokenizes a floating-point number with a decimal point
      XPathLexer xPathLexer = new XPathLexer(".9");
      Token nextToken = xPathLexer.nextToken();
      assertEquals(".9", nextToken.getTokenText()); // Verify that the token text is correct
      assertEquals(31, nextToken.getTokenType()); // Verify that the token type is correct
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive1() throws Throwable  {
      // Test that the XPathLexer can tokenize a valid XPath expression with a floating-point number.
      XPathLexer xPathLexer = new XPathLexer(".7/Y");
      Token nextToken = xPathLexer.nextToken();
      assertEquals(31, nextToken.getTokenType()); // assert that the token type is a valid floating-point number (e.g., 31 for ".7")
      assertEquals(".7", nextToken.getTokenText()); // assert that the token text is equal to the expected value (i.e., ".7")
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive2() throws Throwable  {
      XPathLexer xpathLexer = new XPathLexer(".6y");
      Token nextToken = xpathLexer.nextToken();
      // Verify that the token text matches the expected value
      assertEquals(".6", nextToken.getTokenText());
      // Verify that the token type is as expected
      assertEquals(31, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetXPath() throws Throwable  {
      // Given a string containing an XPath expression
      String xPathExpression = "<~Nl:ml<\"*";
      
      // When the XPath lexer is created with this expression
      XPathLexer xPathLexer = new XPathLexer(xPathExpression);
      
      // Then the lexer should have the correct token type and text for the first token
      Token leftParen = xPathLexer.leftParen();
      assertEquals("i", leftParen.getTokenText());
      assertEquals(1, leftParen.getTokenType());
      
      // And the lexer should have the correct token type and text for the second token
      Token nextToken = xPathLexer.nextToken();
      assertEquals(31, nextToken.getTokenType());
      assertEquals(".3", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenAndNotEquals() throws Throwable  {
      // Given an XPathLexer instance created with a valid expression string,
      XPathLexer xPathLexer = new XPathLexer("~,.2J");
      
      // When the notEquals() method is called on the lexer,
      Token notEquals = xPathLexer.notEquals();
      
      // Then the next token should be a NOT_EQUALS operator (token type 22),
      assertEquals(22, notEquals.getTokenType());
      
      // And the text of the token should be "~," (with the tilde and comma escaped).
      assertEquals("~,", notEquals.getTokenText());
      
      // When the nextToken() method is called on the lexer,
      Token nextToken = xPathLexer.nextToken();
      
      // Then the next token should be a decimal point (token type 31),
      assertEquals(31, nextToken.getTokenType());
      
      // And the text of the token should be ".2" (with the dot and digit escaped).
      assertEquals(".2", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive3() throws Throwable  {
      XPathLexer xpathLexer = new XPathLexer(":bL*e");
      
      // Given a string containing an XPath expression
      
      // When the lexer processes the string
      Token nextToken = xpathLexer.nextToken();
      
      // Then it should return the first token, which is the colon character ':'
      assertEquals(":", nextToken.getTokenText());
      
      // And the token type should be 18, which corresponds to the COLON token in the XPath lexer's token stream
      assertEquals(18, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameReturningNull() throws Throwable  {
      // Given a valid XPath expression "^)!y`ae"
      XPathLexer xPathLexer = new XPathLexer("^)!y`ae");
      
      // When we call the notEquals() method on the lexer
      xPathLexer.notEquals();
      
      // Then the nextToken() method should return a token that is not an identifier or operator name
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      assertNull(identifierOrOperatorName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive4() throws Throwable  {
      // Given: We have an XPathLexer object created with a valid XPath expression |RN:o?t
      XPathLexer xPathLexer = new XPathLexer("|RN:o?t");
      
      // When: We call the nextToken() method on the XPathLexer object to get the next token
      Token nextToken = xPathLexer.nextToken();
      
      // Then: We verify that the returned token is a valid identifier token with the correct type and text
      assertEquals(17, nextToken.getTokenType());
      assertEquals("|", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsNegative0() throws Throwable  {
      // Test that the XPathLexer correctly tokenizes the input string
      XPathLexer lexer = new XPathLexer("{Z%Od%6m3");
      Token nextToken = lexer.nextToken();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAt() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("tezOC{7KXJ>vRdZw");
      Token at = xPathLexer.at();
      assertEquals("t", at.getTokenText());
      assertEquals(16, at.getTokenType());
      
      Token leftParen = xPathLexer.leftParen();
      assertEquals("e", leftParen.getTokenText());
      assertEquals(1, leftParen.getTokenType());
      
      Token nextToken = xPathLexer.nextToken();
      assertEquals(15, nextToken.getTokenType());
      assertEquals("zOC", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPreviousTokenReturningTokenWhereGetTokenTypeIsNegative() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("^)!ylTe");
      xPathLexer.consume();
      Token nextToken = xPathLexer.nextToken();
      assertEquals(2, nextToken.getTokenType());
      assertEquals(")", nextToken.getTokenText());
      
      Token minus = xPathLexer.minus();
      assertEquals(6, minus.getTokenType());
      assertEquals("!", minus.getTokenText());
      
      xPathLexer.nextToken();
      Token previousToken = xPathLexer.getPreviousToken();
      assertEquals("ylTe", previousToken.getTokenText());
      assertEquals((-1), previousToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenAndStarAndWhitespace() throws Throwable  {
      // Given: We have a XPath lexer object "xPathLexer" with a string input "com.werken.saxpath.XPathLexer".
      // When: We call the star() method on the xPathLexer object to match the star character in the input string.
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      xPathLexer.star();
      
      // Then: We assert that the token type of the matched character is 26 (the ASCII value for '*').
      Token star = xPathLexer.nextToken();
      assertEquals(26, star.getTokenType());
      assertEquals("*", star.getTokenText());
      
      // Given: We have a XPath lexer object "xPathLexer" with a string input "com.werken.saxpath.XPathLexer".
      // When: We call the dollar() method on the xPathLexer object to match the dollar character in the input string.
      xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      Token dollar = xPathLexer.dollar();
      
      // Then: We assert that the token type of the matched character is 26 (the ASCII value for '$').
      assertEquals(26, dollar.getTokenType());
      assertEquals("$", dollar.getTokenText());
      
      // Given: We have a XPath lexer object "xPathLexer" with a string input "com.werken.saxpath.XPathLexer".
      // When: We call the doubleColon() method on the xPathLexer object to match the double colon character in the input string.
      xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      xPathLexer.doubleColon();
      
      // Then: We assert that the token type of the matched character is 19 (the ASCII value for '::').
      Token doubleColon = xPathLexer.nextToken();
      assertEquals(19, doubleColon.getTokenType());
      assertEquals("::", doubleColon.getTokenText());
      
      // Given: We have a XPath lexer object "xPathLexer" with a string input "com.werken.saxpath.XPathLexer".
      // When: We call the pipe() method on the xPathLexer object to match the pipe character in the input string.
      xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      Token pipe = xPathLexer.pipe();
      
      // Then: We assert that the token type of the matched character is 17 (the ASCII value for '|').
      assertEquals(17, pipe.getTokenType());
      assertEquals("|", pipe.getTokenText());
      
      // Given: We have a XPath lexer object "xPathLexer" with a string input "com.werken.saxpath.XPathLexer".
      // When: We call the consume() method on the xPathLexer object to match the next character in the input string.
      xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      xPathLexer.consume(1);
      
      // Then: We assert that the token type of the matched character is 15 (the ASCII value for '.').
      Token nextToken = xPathLexer.nextToken();
      assertEquals(15, nextToken.getTokenType());
      assertEquals(".", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive5() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("vt02-2yB");
      Token nextToken = xPathLexer.nextToken();
      // Check that the token text is correct
      assertEquals("vt02-2yB", nextToken.getTokenText());
      // Check that the token type is correct
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive6() throws Throwable  {
      // No Comments were added
      XPathLexer xPathLexer = new XPathLexer("tq0\"<FH4FVy");
      Token nextToken = xPathLexer.nextToken();
      assertEquals(15, nextToken.getTokenType());
      assertEquals("tq0", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive7() throws Throwable  {
      // Given an XPathLexer with a valid input string "s|N(Pue_!;7y0|0!b<"
      XPathLexer lexer = new XPathLexer("s|N(Pue_!;7y0|0!b<");
      
      // When we call the nextToken method to get the next token
      Token nextToken = lexer.nextToken();
      
      // Then we expect the token text to be "s" and the token type to be 15
      assertEquals("s", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive8() throws Throwable  {
      XPathLexer lexer = new XPathLexer("q#OK;(fGZM>O_");
      // Create an instance of the XPathLexer class with the input string "q#OK;(fGZM>O_"
      
      Token nextToken = lexer.nextToken();
      // Get the next token from the lexer
      
      assertEquals("q", nextToken.getTokenText());
      // Assert that the token text is equal to "q"
      
      assertEquals(15, nextToken.getTokenType());
      // Assert that the token type is equal to 15 (i.e., a keyword)
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive9() throws Throwable  {
      // Given: We have an XPathLexer object with a string input "p"
      XPathLexer xPathLexer = new XPathLexer("p");
      
      // When: We call the nextToken method on the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then: The token returned should be of type 15 (string literal) and have the text "p"
      assertEquals(15, nextToken.getTokenType());
      assertEquals("p", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive10() throws Throwable  {
      // Create a new XPathLexer instance with the input string "m"
      XPathLexer xPathLexer = new XPathLexer("m");
      
      // Call the nextToken() method on the lexer to get the next token
      Token nextToken = xPathLexer.nextToken();
      
      // Assert that the token text is "m"
      assertEquals("m", nextToken.getTokenText());
      
      // Assert that the token type is 15 (i.e., the token type for the letter "m")
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive11() throws Throwable  {
      // Given a XPath query "l"
      XPathLexer xPathLexer = new XPathLexer("l ");
      
      // When the next token is retrieved
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token text should be "l" and have a type of 15 (IDENTIFIER)
      assertEquals("l", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenAndConsumeTakingNoArguments() throws Throwable  {
      // Create a new instance of XPathLexer with the given input string
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // Test that the lexer is correctly recognizing the '*' character
      Token star = xPathLexer.star();
      assertEquals(20, star.getTokenType());
      assertEquals("c", star.getTokenText());
      
      // Test that the lexer is correctly recognizing the '$' character
      Token dollar = xPathLexer.dollar();
      assertEquals(26, dollar.getTokenType());
      assertEquals("o", dollar.getTokenText());
      
      // Test that the lexer is correctly recognizing the '::' double colon operator
      Token doubleColon = xPathLexer.doubleColon();
      assertEquals(19, doubleColon.getTokenType());
      assertEquals("m.", doubleColon.getTokenText());
      
      // Test that the lexer is correctly recognizing the '|' character
      Token pipe = xPathLexer.pipe();
      assertEquals("w", pipe.getTokenText());
      assertEquals(17, pipe.getTokenType());
      
      // Test that the lexer can consume a single character and return the next token
      xPathLexer.consume(1);
      xPathLexer.consume();
      Token nextToken = xPathLexer.nextToken();
      assertEquals("ken.saxpath.XPathLexer", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive12() throws Throwable  {
      // Create an instance of the XPathLexer class with a sample input string
      XPathLexer xPathLexer = new XPathLexer("jo;-*HgW|Wg(");
      
      // Call the nextToken method and store the returned token in a variable
      Token nextToken = xPathLexer.nextToken();
      
      // Assert that the token text is "jo" and the token type is 15 (as defined in the XPathLexer class)
      assertEquals("jo", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive13() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("hxNS1x~");
      
      // Given a string containing an XPath expression
      
      Token nextToken = xPathLexer.nextToken();
      
      // When we get the next token from the lexer
      
      assertEquals(15, nextToken.getTokenType());
      
      // Then the token type should be 15 (e.g., "hxNS1x")
      
      assertEquals("hxNS1x", nextToken.getTokenText());
      
      // And the token text should be the actual XPath expression
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive14() throws Throwable  {
      // Given an instance of XPathLexer with a valid input string "gA~~@9z'"
      XPathLexer xPathLexer = new XPathLexer("gA~~@9z'");
      
      // When the nextToken method is called on the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token text should be "gA" and the token type should be 15
      assertEquals("gA", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive15() throws Throwable  {
      // Given a XPathLexer object with an input string "fR%n=m9iW!;"
      XPathLexer xPathLexer = new XPathLexer("fR%n=m9iW!;");
      
      // When the nextToken method is called on the XPathLexer object
      Token nextToken = xPathLexer.nextToken();
      
      // Then the next token returned should be of type 15 (the identifier token) with text "fR"
      assertEquals(15, nextToken.getTokenType());
      assertEquals("fR", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsNegative1() throws Throwable  {
      // Given a string containing an XPath expression,
      String xpathExpression = "` 8]a3L3G.P";
      // When the XPath Lexer is instantiated with that string,
      XPathLexer xPathLexer = new XPathLexer(xpathExpression);
      // And a call is made to get the next token from the lexer,
      Token nextToken = xPathLexer.nextToken();
      // Then the test asserts that the token text matches the original string.
      assertEquals("` 8]a3L3G.P", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive16() throws Throwable  {
      // No Comments were added
      XPathLexer xPathLexer = new XPathLexer("_\"q.1:'pRRLIw<%%u");
      Token nextToken = xPathLexer.nextToken();
      assertEquals("_", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsNegative2() throws Throwable  {
      // Given: We have an XPathLexer instance with a string input of "^)!y`ae"
      XPathLexer xPathLexer = new XPathLexer("^)!y`ae");
      
      // When: We call the nextToken() method on the XPathLexer instance
      Token nextToken = xPathLexer.nextToken();
      
      // Then: The nextToken() method should return a Token with the token text of "^)!y`ae"
      assertEquals("^)!y`ae", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive17() throws Throwable  {
      // Given a XPathLexer with input "ZU.2J"
      XPathLexer xPathLexer = new XPathLexer("ZU.2J");
      
      // When the next token is requested
      Token nextToken = xPathLexer.nextToken();
      
      // Then the returned token should have a token type of 15 (number) and token text "ZU.2J"
      assertEquals(15, nextToken.getTokenType());
      assertEquals("ZU.2J", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive18() throws Throwable  {
      // Given: The XPathLexer is created with a valid input string "Y_Iwe"
      XPathLexer xPathLexer = new XPathLexer("Y_Iwe");
      
      // When: The nextToken method is called on the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then: The next token returned should have a token type of 15 and a token text of "Y_Iwe"
      assertEquals(15, nextToken.getTokenType());
      assertEquals("Y_Iwe", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive19() throws Throwable  {
      // Given a valid XPath expression "X"
      String xPathExpression = "X";
      
      // When we create a new instance of the XPathLexer with this expression
      XPathLexer xPathLexer = new XPathLexer(xPathExpression);
      
      // And we call the nextToken method on the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then we expect the token type to be 15 (the value for the "X" character)
      assertEquals(15, nextToken.getTokenType());
      
      // And we expect the token text to be "X"
      assertEquals("X", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive20() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("W7&(4g8ca");
      Token nextToken = xPathLexer.nextToken();
      assertEquals("W7", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive21() throws Throwable  {
      // Given a string that contains an XPath expression
      String input = "Vuo3# 5}/|<15Yto";
      
      // When the XPathLexer is created with the input string
      XPathLexer xPathLexer = new XPathLexer(input);
      
      // Then the next token should be a numeric token with value 15 and text "Vuo3"
      Token nextToken = xPathLexer.nextToken();
      assertEquals(15, nextToken.getTokenType());
      assertEquals("Vuo3", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive22() throws Throwable  {
      // Create a new XPathLexer instance and set its input string to "U:*1"
      XPathLexer xPathLexer = new XPathLexer("U:*1");
      
      // Call the nextToken() method of the XPathLexer object, which returns the next token in the input stream
      Token nextToken = xPathLexer.nextToken();
      
      // Assert that the returned token has the correct text and type
      assertEquals("U", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive23() throws Throwable  {
      // This test case verifies the correctness of the XPath lexer for parsing a simple string containing an operator.
      XPathLexer xPathLexer = new XPathLexer("S|q|'=");
      Token nextToken = xPathLexer.nextToken();
      assertEquals("S", nextToken.getTokenText()); // The first token in the input string is an operator and has a token type of 15 (operator).
      assertEquals(15, nextToken.getTokenType()); // The first token in the input string is an operator and has a token type of 15 (operator).
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenAndLeftParenAndWhitespace() throws Throwable  {
      // Given a string containing a valid XPath expression
      XPathLexer xPathLexer = new XPathLexer("u?PXg5rvj~dg\u0004,");
      
      // When the leftParen() method is called
      Token leftParen = xPathLexer.leftParen();
      
      // Then the left paren token should be returned
      assertEquals(1, leftParen.getTokenType());
      assertEquals("u", leftParen.getTokenText());
      
      // When the whitespace() method is called
      Token whitespace = xPathLexer.whitespace();
      
      // Then the whitespace token should be returned
      assertEquals("", whitespace.getTokenText());
      assertEquals((-2), whitespace.getTokenType());
      
      // When the nextToken() method is called
      Token nextToken = xPathLexer.nextToken();
      
      // Then the next token (PXg5rvj) should be returned
      assertEquals("PXg5rvj", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive24() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("OB#W)\"<");
      // Create a lexer for parsing the XPath expression
      
      Token nextToken = xPathLexer.nextToken();
      // Get the next token from the lexer
      
      assertEquals(15, nextToken.getTokenType());
      // Check that the token type is correct
      
      assertEquals("OB", nextToken.getTokenText());
      // Check that the token text is correct);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive25() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("L");
      // Given a valid input string "L"
      
      Token nextToken = xPathLexer.nextToken();
      // When we call the nextToken() method on the lexer
      
      assertEquals("L", nextToken.getTokenText());
      // Then the token text should be equal to "L"
      
      assertEquals(15, nextToken.getTokenType());
      // And the token type should be 15 (the constant value for the letter 'L')
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive26() throws Throwable  {
      // Create a new instance of the XPathLexer with the input string "Kb]2|q<mU"
      XPathLexer xPathLexer = new XPathLexer("Kb]2|q<mU");
      
      // Call the nextToken() method and store the returned token in the variable nextToken
      Token nextToken = xPathLexer.nextToken();
      
      // Assert that the token type is 15 (the token type for a keyword token)
      assertEquals(15, nextToken.getTokenType());
      
      // Assert that the token text is "Kb"
      assertEquals("Kb", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive27() throws Throwable  {
      // Test that the XPathLexer correctly tokenizes a single character
      XPathLexer xPathLexer = new XPathLexer("J");
      Token nextToken = xPathLexer.nextToken();
      assertEquals("J", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive28() throws Throwable  {
      // Create an instance of the XPathLexer class and pass in a string representing an XPath expression
      XPathLexer xPathLexer = new XPathLexer("IWu$X`");
      
      // Call the nextToken() method to retrieve the next token from the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Assert that the token text is "IWu" and the token type is 15 (as specified in the XPath spec)
      assertEquals("IWu", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive29() throws Throwable  {
      XPathLexer lexer = new XPathLexer("HasnKv(4s"); // Create a new XPathLexer object with the given input string
      
      Token nextToken = lexer.nextToken(); // Get the next token from the lexer
      
      assertEquals("HasnKv", nextToken.getTokenText()); // Check that the token text is "HasnKv"
      
      assertEquals(15, nextToken.getTokenType()); // Check that the token type is 15 (the value of the HasnKv keyword)
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive30() throws Throwable  {
      // Arrange
      XPathLexer xPathLexer = new XPathLexer("F[d&");
      
      // Act
      Token nextToken = xPathLexer.nextToken();
      
      // Assert
      assertEquals(15, nextToken.getTokenType());
      assertEquals("F", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive31() throws Throwable  {
      // Tests the ability of the XPathLexer to correctly lex a simple XPath expression
      XPathLexer xPathLexer = new XPathLexer("D=NDtN/gMH+");
      Token nextToken = xPathLexer.nextToken();
      assertEquals(15, nextToken.getTokenType()); // Asserts that the token type is 15 (i.e., an equals sign)
      assertEquals("D", nextToken.getTokenText()); // Asserts that the token text is "D"
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive32() throws Throwable  {
      // Given a XPathLexer instance with a valid XPath expression
      XPathLexer xPathLexer = new XPathLexer("CB88lqzm@w;,");
      
      // When we call the nextToken method
      Token nextToken = xPathLexer.nextToken();
      
      // Then we expect to get a token with a specific type and text
      assertEquals(15, nextToken.getTokenType());
      assertEquals("CB88lqzm", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive33() throws Throwable  {
      // Given the XPath expression "BNEFy(W;,h\"h"
      XPathLexer xPathLexer = new XPathLexer("BNEFy(W;,h\"h");
      
      // When the next token is extracted from the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token text should be "BNEFy" and the token type should be 15
      assertEquals("BNEFy", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive34() throws Throwable  {
      // Given an XPathLexer instance for the input string "A?.)yg"
      XPathLexer xPathLexer = new XPathLexer("A?.)yg");
      
      // When the nextToken method is called on the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token type should be 15 (the type for "A")
      assertEquals(15, nextToken.getTokenType());
      
      // And the token text should be "A"
      assertEquals("A", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsNegative3() throws Throwable  {
      // Test the XPathLexer class with a simple query
      XPathLexer xPathLexer = new XPathLexer("?x3<9S2hq");
      Token nextToken = xPathLexer.nextToken();
      assertEquals("?)x3<9S2hq", nextToken.getTokenText());
      // The lexer should return the token text as-is, without any modification
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsNegative4() throws Throwable  {
      // Given a XPath Lexer with input ";..7Z"
      XPathLexer xPathLexer = new XPathLexer(";..7Z");
      
      // When the next token is retrieved
      Token nextToken = xPathLexer.nextToken();
      
      // Then the expected token text is returned
      assertEquals(";..7Z", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive35() throws Throwable  {
      // Given a XPathLexer with input "9<L*"
      XPathLexer xPathLexer = new XPathLexer("9<L*");
      
      // When the nextToken method is called on the XPathLexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token text should be "9"
      assertEquals("9", nextToken.getTokenText());
      
      // And the token type should be 30 (LessThan)
      assertEquals(30, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive36() throws Throwable  {
      // Arrange
      XPathLexer xPathLexer = new XPathLexer("8H8dLj$D");
      
      // Act
      Token nextToken = xPathLexer.nextToken();
      
      // Assert
      assertEquals("8", nextToken.getTokenText());
      assertEquals(30, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive37() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("798N)Dx&tYG+@n$V");
      Token nextToken = xPathLexer.nextToken();
      // Asserts that the next token is a number with value 30
      assertEquals(30, nextToken.getTokenType());
      // Asserts that the text of the next token is "798"
      assertEquals("798", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive38() throws Throwable  {
      // Setup
      XPathLexer xPathLexer = new XPathLexer("6>I9IVke{");
      
      // Execute
      Token nextToken = xPathLexer.nextToken();
      
      // Verify
      assertEquals("6", nextToken.getTokenText());
      assertEquals(30, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive39() throws Throwable  {
      // Given a string of XPath expression "5&<Le"
      String input = "5&<Le";
      
      // When we create an instance of the XPathLexer with this string as input
      XPathLexer xPathLexer = new XPathLexer(input);
      
      // And we call the nextToken() method on this lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token returned should have a token type of 30 (integer) and a token text of "5"
      assertEquals(30, nextToken.getTokenType());
      assertEquals("5", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive40() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("4DdD3mRY}Oym@*");
      Token nextToken = xPathLexer.nextToken();
      assertEquals(30, nextToken.getTokenType());
      assertEquals("4", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive41() throws Throwable  {
      // Given a string "3A"
      String input = "3A";
      
      // When the XPathLexer is created with this string
      XPathLexer xPathLexer = new XPathLexer(input);
      
      // Then the next token should be an integer token with type 30 and text "3"
      Token nextToken = xPathLexer.nextToken();
      assertEquals(30, nextToken.getTokenType());
      assertEquals("3", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive42() throws Throwable  {
      // Given a XPathLexer with input "2"
      XPathLexer xPathLexer = new XPathLexer("2");
      
      // When the nextToken method is called
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token type should be 30 (integer)
      assertEquals(30, nextToken.getTokenType());
      
      // And the token text should be "2"
      assertEquals("2", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive43() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("1f`Jo}U~79K&0");
      Token nextToken = xPathLexer.nextToken();
      assertEquals("1", nextToken.getTokenText());
      assertEquals(30, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenAndLeftParen() throws Throwable  {
      // Given an XPath lexer with a valid input string
      String input = "_PHL0";
      XPathLexer xPathLexer = new XPathLexer(input);
      
      // When the lexer tokenizes the input string
      Token star = xPathLexer.star();
      Token dollar = xPathLexer.dollar();
      Token equals = xPathLexer.equals();
      Token leftParen = xPathLexer.leftParen();
      Token nextToken = xPathLexer.nextToken();
      
      // Then the tokens are correctly recognized and their values are correct
      assertEquals(20, star.getTokenType());
      assertEquals("_", star.getTokenText());
      
      assertEquals(26, dollar.getTokenType());
      assertEquals("P", dollar.getTokenText());
      
      assertEquals(21, equals.getTokenType());
      assertEquals("H", equals.getTokenText());
      
      assertEquals(1, leftParen.getTokenType());
      assertEquals("L", leftParen.getTokenText());
      
      assertEquals(30, nextToken.getTokenType());
      assertEquals("0", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive44() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("/kogt+@W");
      
      // Given a string input "/kogt+@W" to the XPathLexer class
      
      Token nextToken = xPathLexer.nextToken();
      
      // When the nextToken method is called on the XPathLexer object
      
      assertEquals(11, nextToken.getTokenType());
      
      // Then we expect the token type to be 11 (the value for "/" in the XPath grammar)
      
      assertEquals("/", nextToken.getTokenText());
      
      // And we expect the token text to be "/"
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive45() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer(".1vwA(+n'0");
      // Given an XPath expression starting with "." and containing a unary plus operator
      
      Token nextToken = xPathLexer.nextToken();
      // When the lexer is created and the first token is retrieved
      
      assertEquals(".1", nextToken.getTokenText());
      // Then the token text should be ".1"
      
      assertEquals(31, nextToken.getTokenType());
      // Then the token type should be "NUMBER" (as defined in the XPath specification)
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive46() throws Throwable  {
      // Given an XPath expression that starts with an asterisk
      XPathLexer xPathLexer = new XPathLexer("*");
      
      // When we call nextToken() on the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then we expect to get a token with type 20 and text "*"
      assertEquals(20, nextToken.getTokenType());
      assertEquals("*", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive47() throws Throwable  {
      // Given a XPath expression "()[4:;G"
      XPathLexer xPathLexer = new XPathLexer("()[4:;G");
      
      // When the next token is extracted from the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token text should be "("
      assertEquals("(", nextToken.getTokenText());
      
      // And the token type should be 1 (i.e. a parentheses)
      assertEquals(1, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsNegative5() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("'ibr~W7mT),c=lXltr");
      Token nextToken = xPathLexer.nextToken();
      // Check if the token is an error token with a value of -1 and an empty string as its text
      assertEquals(-1, nextToken.getTokenType());
      assertEquals("", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenAndIdentifierOrOperatorName() throws Throwable  {
      // Given an instance of XPathLexer with input "5&<Le"
      XPathLexer xPathLexer = new XPathLexer("5&<Le");
      
      // When calling identifierOrOperatorName() method on the lexer
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      
      // Then assert that the token text is "5" and the token type is 15 (IDENTIFIER)
      assertEquals("5", identifierOrOperatorName.getTokenText());
      assertEquals(15, identifierOrOperatorName.getTokenType());
      assertNotNull(identifierOrOperatorName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsNegative6() throws Throwable  {
      // Given a XPathLexer instance with a valid expression
      XPathLexer xPathLexer = new XPathLexer("%r[V&9~_Q`LlY!");
      
      // When the nextToken method is called on the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token text should be equal to the original expression
      assertEquals("%r[V&9~_Q`LlY!", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsNegative7() throws Throwable  {
      // Test that the XPath lexer correctly tokenizes a string with special characters
      XPathLexer xPathLexer = new XPathLexer("$#%'&{m");
      Token nextToken = xPathLexer.nextToken();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive48() throws Throwable  {
      // Given an input string "">~Nlmlb<"*", which contains a combination of special characters and whitespace
      XPathLexer xPathLexer = new XPathLexer("\">~Nlmlb<\"*");
      
      // When the lexer is used to tokenize the input string
      Token nextToken = xPathLexer.nextToken();
      
      // Then the lexer should return a token with a type of 27 and text ">~Nlmlb<"
      assertEquals(27, nextToken.getTokenType());
      assertEquals(">~Nlmlb<", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsNegative8() throws Throwable  {
      // Create an XPath lexer with a single space as input
      XPathLexer xPathLexer = new XPathLexer(" ");
      
      // Call the nextToken method and store the returned token
      Token nextToken = xPathLexer.nextToken();
      
      // Assert that the token text is an empty string
      assertEquals("", nextToken.getTokenText());
      
      // Assert that the token type is -1 (an unknown token)
      assertEquals((-1), nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenAndConsumeTakingInt() throws Throwable  {
      // Given an XPathLexer instance initialized with an input string " ~f.4H?"
      XPathLexer xPathLexer = new XPathLexer(" ~f.4H?");
      
      // When we consume 3 characters from the lexer
      xPathLexer.consume(3);
      
      // Then the next token should be a floating-point number with value ".4"
      Token nextToken = xPathLexer.nextToken();
      assertEquals(31, nextToken.getTokenType());
      assertEquals(".4", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive49() throws Throwable  {
      // Arrange
      XPathLexer xPathLexer = new XPathLexer("-");
      
      // Act
      Token nextToken = xPathLexer.nextToken();
      
      // Assert
      assertEquals(6, nextToken.getTokenType());
      assertEquals("-", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndStar() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer();
      Token arg0 = xPathLexer.star();
      xPathLexer.setPreviousToken(arg0);
      assertEquals(20, arg0.getTokenType());
      
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      assertEquals(15, identifierOrOperatorName.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive50() throws Throwable  {
      XPathLexer lexer = new XPathLexer("=o!");
      Token token = lexer.nextToken();
      // Given a valid input string "=o!"
      
      // When the nextToken method is called on the lexer object
      
      // Then the token type should be 21, which represents an equals operator
      assertEquals(21, token.getTokenType());
      
      // And the token text should be "=", which is the actual equals operator
      assertEquals("=", token.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive51() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("@4UXtC'3q{C");
      Token nextToken = xPathLexer.nextToken();
      assertEquals(16, nextToken.getTokenType());
      assertEquals("@", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRightBracket() throws Throwable  {
      // Arrange
      XPathLexer xPathLexer = new XPathLexer("[/X:");
      
      // Act
      Token rightBracket = xPathLexer.rightBracket();
      
      // Assert
      assertEquals(4, rightBracket.getTokenType());
      assertEquals("[", rightBracket.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesXPathLexerTakingStringAndNextTokenAndNextTokenReturningTokenWhereGetTokenTypeIsPositive52() throws Throwable  {
      // Given: A XPathLexer object is created with a valid XPath query string
      XPathLexer xPathLexer = new XPathLexer("::]Mf]VZ#H'3Wqy(:,");
      
      // When: The nextToken method is called on the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then: The token text and type are asserted to be as expected
      assertEquals("::", nextToken.getTokenText());
      assertEquals(19, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLeftBracket() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("fz?[]Dkl?L%C=vrA\"<");
      // Given a string of characters that represents an XPath expression, create an instance of the XPathLexer class with the input string.
      
      Token leftBracket = xPathLexer.leftBracket();
      // When the leftBracket() method is called on the XPathLexer object, a Token object is returned that represents the opening bracket character in the expression.
      
      assertEquals("f", leftBracket.getTokenText());
      // Then the token text should be "f".
      
      Token whitespace = xPathLexer.whitespace();
      // When the whitespace() method is called on the XPathLexer object, a Token object is returned that represents a whitespace character in the expression.
      
      assertEquals((-2), whitespace.getTokenType());
      // Then the token type should be -2.
      
      assertEquals("", whitespace.getTokenText());
      // Then the token text should be an empty string.
      
      Token plus = xPathLexer.plus();
      // When the plus() method is called on the XPathLexer object, a Token object is returned that represents the plus character in the expression.
      
      assertEquals("?", plus.getTokenText());
      // Then the token text should be "?".
      
      assertEquals(5, plus.getTokenType());
      // Then the token type should be 5.
      
      Token nextToken = xPathLexer.nextToken();
      // When the nextToken() method is called on the XPathLexer object, a Token object is returned that represents the next character in the expression.
      
      assertEquals(3, nextToken.getTokenType());
      // Then the token type should be 3.
      
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      // When the identifierOrOperatorName() method is called on the XPathLexer object, a Token object is returned that represents an identifier or operator name in the expression.
      
      assertEquals("", identifierOrOperatorName.getTokenText());
      // Then the token text should be an empty string.
      
      assertEquals(15, identifierOrOperatorName.getTokenType());
      // Then the token type should be 15.);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testColon() throws Throwable  {
      // Given a XPath lexer with a colon character
      XPathLexer xPathLexer = new XPathLexer();
      
      // When the lexer reads the colon character
      Token arg0 = xPathLexer.colon();
      
      // Then the lexer returns a token with type COLON (18)
      assertEquals(18, arg0.getTokenType());
      
      // And the previous token is set to the returned token
      assertSame(arg0, xPathLexer.getPreviousToken());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndPipe() throws Throwable  {
      // Given a XPathLexer instance
      XPathLexer xPathLexer = new XPathLexer();
      
      // When the pipe method is called
      Token arg0 = xPathLexer.pipe();
      
      // Then the token type should be 17 (|)
      assertEquals(17, arg0.getTokenType());
      
      // Given an identifier or operator name
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      
      // When the identifier or operator name is parsed
      assertEquals(15, identifierOrOperatorName.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifier() throws Throwable  {
      XPathLexer lexer = new XPathLexer("OcZp!=.p!hSdklx%");
      Token identifier = lexer.identifier();
      assertEquals(15, identifier.getTokenType()); // Verify that the token type is correct for an identifier.
      assertEquals("OcZp", identifier.getTokenText()); // Verify that the text of the identifier token is correct.
      
      Token nextToken = lexer.nextToken();
      assertEquals("!=", nextToken.getTokenText()); // Verify that the text of the "!=" operator token is correct.
      assertEquals(22, nextToken.getTokenType()); // Verify that the token type is correct for an "!=" operator token.
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndLeftParen() throws Throwable  {
      // Given
      XPathLexer lexer = new XPathLexer();
      
      // When
      Token leftParenToken = lexer.leftParen();
      lexer.setPreviousToken(leftParenToken);
      Token identifierOrOperatorNameToken = lexer.identifierOrOperatorName();
      
      // Then
      assertNotNull(identifierOrOperatorNameToken);
      assertEquals(15, identifierOrOperatorNameToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testComma() throws Throwable  {
      XPathLexer lexer = new XPathLexer("798N)Dx&tYG+@n$V");
      Token comma = lexer.comma();
      // Check that the comma token has the correct text and type
      assertEquals("7", comma.getTokenText());
      assertEquals(32, comma.getTokenType());
      
      char LA = lexer.LA(0);
      // Check that the lookahead character is equal to the expected value
      assertEquals('7', LA);
  }
}
