#,Group,# Variety,Experience T1,Experience T2,what factors make finding bugs easier for you,Importance of understandability on bug fixing ,Understandability T1,Understandability T2,Why Do you feel this way
1,Academic,1,Yes,Yes,-,4,3,4,-
2,Academic,3,No,No,"Readability of the code, concretely defined expected behavior",4,4,2,"In task 2 I found it hard to understand what the program was supposed to do, this made it hard to find and fix the bugs"
3,Academic,1,No,No,Clear source code and simply defined unit tests testing single line statements in methods.,4,3,4,The test cases in Task 2 were more difficult to read but what they tested was more limited in scope and had less overlap with different methods in the class under test.
4,Academic,2,Yes,Yes,if is logically make sense.,4,3,3,"Because the test data includes less useful information, some data may help but request more detail."
5,Industry,4,No,No,"Comments, good descriptive method/variable names, clean and straightforward logic",5,4,4,"Most of the test cases had clear names, comments and imperative code that tested only one isolated part of the app functionality"
6,Academic,2,No,No,"Knowing what parts you changed in the first place, frequent committing and making sure test still succeed after you make small changes. Huge changes to codebase can make it very hard to debug and fix.",3,4,4,"tbf i just fixed it in the source code without looking at the tests too much, they guided me I guess to parts of the code where I had to look when I had an initial skim over the code. After the ""noticeable"" bugs were fixed I looked at the remaining failing tests to fix the rest"
7,Academic,3,Yes,Yes,"Documented methods, particularly when there's some math involved, e.g. Test 2 had some math computation and methods where not documented. Moreover, for ""magic numbers"" within tests should be clear what they meant for.",4,5,2,"The test cases of Task1 had variables name self-explainatory, instead Task 2 had stuff like 'budget0' or 'timeOfDay0'. Expecially when working with Dates :)"
8,Academic,4,No,No,"Clear, well-structured code, both of the main application and test cases (method name, variable names) is the most important, as it allows to build a mental model quickly and to identify basic logic issues. To aid further with debugging, extra context can be quite helpful, such as comments and easily understandable data/mocking.",5,4,5,"Both codebases and respective test suites were understandable. Task 1 method names are verbose but are easily comprehensible. Task 1 identifiers could be more human-like. Task 1 benefits from the test cases being relatively straightforward, but for more complex test cases readability would not be great."
9,Industry,3,Yes,Yes,Good docs and good test coverage,5,4,2,Lack of specification in the Task2
10,Academic,4,No,Yes,"The already existing tests that in theory should infer the correct output of the code and the Javadoc that explains the intent and the behavior of the code e.g. return type, calculation formula etc.",2,4,3,"For task 2, the calorie counter the Javadoc was saying that some outputs should be integers and the tests were asserting doubles. In a test-driven development setting, the tests should actually be the actual behavior of the code so the src should have been modified no the tests. On the other hand, the javadoc was explaining a different behavior of the code. I think the understandability reflects a lot the coding practices the developers used writing the code."
11,Academic,1,Yes,Yes,The javadoc above methods definitely helped and I also really appreciate being able to use a debugger (or print statements in this case),4,4,3,"I liked that there were comments about what each step did, and the variables were named in a clear way. I was somewhere confused in Task 1 by why some test cases first retrieved the value, then verified the calories per hour and then verified the value under test, but it was not really an issue with clarity."
12,Academic,2,No,No,"The type of bug, numerical bugs with floats are very difficult to precisely test. Logical bugs involving boolean and simple comparisons are simpler to reason about.",5,1,4,You need to explain the reasoning model and precisely specify the validity envelop of the source code to help with maintainability.
13,Academic,3,No,No,"context: being familiar with classes and methods, and aslo business logic in general",5,3,4,I think the concept of calories per hour and day is generally more understandable than shooting damage and damage bonuses
14,Industry,2,No,No,Knowing the observable behaviour that's supposed to be different from what it is,5,3,5,"Task 1 is structured in a way that relies on the state of the real world, making the tests brittle. It was not clear whether I've fixed all the bugs, because even the fixed functions still were reported as faulty, and vice versa."
15,Academic,4,Yes,No,Explicit test cases which test one thing at a time. Also it's a bit confusing when 1 line of code does multiple things (like chained booleans) because you don't know exactly which statement created the bug.,5,5,4,"Every test case contained an initialisation line which was very explicit. Every assertion was explicit, although the numbers were difficult to understand because I didn't know exactly what the computation was behind them."
16,Academic,1,Yes,Yes,- A clear test case that consistently triggers the bug - Understanding what a code snippet is supposed to do in the first place - Readable variable names (clean code in general),2,4,4,"I understood the code and could read it just fine; it followed the standard stages of 1. Creating the objects to be tested. 2. Performing the action you wish to test. 3. Asserting whether the action has the desired value. In particular, knowing the action that was tested made it easy to pinpoint exactly where to begin searching for the bug. One nitpick is that I couldn't gather the ""why"" from the test cases: Why is this the expected value? E.g. in the second task a test failed that tested the ""isGoldenGun"" method, but I have no idea why it should/should not be a golden gun. The only reason I was able to find the bug is because there was an obvious wrong null check for which I did not need to understand it."
17,Industry,1,Yes,Yes,Navigation features provided by IDE,5,3,5,"I was nervous at the first task, at the second I understood it can't go worse:)"
18,Industry,2,No,No,Documentation and comments for both source code and test code are important for finding bugs when I have no context or knowledge about the code. The method name is also important for both the source code and test code. It helps me to understand what is the expectation of the method and what it is testing.,5,3,5,"The test data of task1 made me confused. And the code is a bit dense, which made it is a bit hard to understand. The test cases of Task2 provide more clear information about the test case, because of the format and comment, and because the number is simpler."
19,Academic,4,Yes,Yes,"Code quality, well-written test suite",5,4,2,"First task was quite clear; second one had tests that didn't make sense, even though they were heavily commented, the comments didn't make sense too."
20,Industry,3,No,No,Several tests running over the same code.,4,4,3,
21,Academic,2,No,Yes,Knowing the data-types involved and class structure/layout,4,4,4,"To me, it is more important to have the code itself be readable, but readable tests are part of that. Fixing bugs is easier when code is understandable and you know what is being tested."
22,Academic,3,Yes,Yes,Clean and well organized code. Abstractions. Code which is well separated based on functionality (do not clutter multiple things in one method/class),4,3,3,"Some test cases were using too many assertions, most of them not really needed for the scope of that test."
23,Industry,1,No,No,"Documentation, assertions",1,2,4,"Task1: ""timeFromNow"" what is ""now"" in the test? Poor assertions, not all data is being checked. Task2: Testing single function per test is good."
24,Academic,1,No,No,"Clear javadocs, introduction into what the purpose of the code base is and how the codebase is (roughly) structured",4,4,4,"I felt the test cases itself were quite readable/understandable in principle, however, especially with task 2 it was quite vague to me how to underlying code was supposed to work (e.g. retrieving data from a production csv file, negative damage bonuses, nested class) which caused me to sometimes look way too deep in the codebase, as all the bugs were just very minor errors."
25,Industry,4,No,No,Having a test suite with expected inputs and outputs makes it easier to understand what the code is supposed to do,3,3,4,"Task2 is written as Arrange/Act/Assert You set up an object, interact with it, and then assert It helps me to understand the business logic Task1 feels generated, checking equalities of objects. Helps to find the bugs, but it did not help me to understand the business logic of the system under test, so I had to really look at the source code and read the JSDoc comments to understand what it was supposed to do."
26,Industry,2,Yes,Yes,Tests in task 2 were better organized,5,2,4,Absurd test cases and test data in task 2 Given -&gt; then -&gt; when description provided
27,Industry,3,No,No,Correct specifications helped (but they were absent most of the time).,1,3,3,"The problem is actually in not being familiar with the code, and the lack of specifications. The tests were almost irrelevant to me."
28,Academic,2,No,No,When it is just a call with wrong parameters. When the specifications are explicit.,5,1,5,"In the first task, there are a lot of magic numbers that are based on specific time so it's difficult to understand where the bug comes from. In the second task, there are a lot of comments and specification so it's easier to check if there is a bug in a method."
29,Industry,4,No,No,Tests that are failing Specifications,2,4,4,Functionality that was tested was well isolated by remaining functionality
30,Academic,4,Yes,Yes,naming methods and variables correctly and in a verbose way,5,4,4,"The code was well documented, each line was well explained and the variables and methods had straightforward names"
31,Academic,3,No,No,"- having a working debugger :( - knowing the program logic (I have some experience with legacy software, so I know how to handle those) - Knowing & using IDE features",4,4,2,"For better understandability, there should be more use of constants and common setup (like a mocked clock). Task1 is more understandable because it does not have the inherent complexity of clocks and time attached to it."
32,Industry,1,No,No,,5,1,2,
Trial,Trial,,,,,,,,
5,Academic,4,No,No,"Having a working debugger, not having to resort to println.",5,3,2,"A test should clearly explain what it is trying to test, and many tests didn't. Also, many unit tests were missing, which would have detected some of the errors more fundamentally without having to try to understand the bigger picture."
,,,,,,,,,
,,Yes,12,13,,,,,
,,,37.50%,40.63%,,,,,
,,No,20,19,,,,,
,,,62.50%,59.38%,,,,,
,,,,,,4.03030303,UTG,3.806451613,
,,,,,,4,Evo,3.35483871,
,,,,,,UTG,,,
,,,,,,1,1,3.13%,
,,,,,,2,2,6.25%,
,,,,,,3,8,25.00%,
,,,,,,4,16,50.00%,
,,,,,,5,5,15.63%,
,,,,,,EVO,,,
,,,,,,1,2,6.25%,
,,,,,,2,6,18.75%,
,,,,,,3,8,25.00%,
,,,,,,4,14,43.75%,
,,,,,,5,2,6.25%,